P38

# 第3章 Hookings into React

 不要在循环、条件语句或嵌套函数内部调用 Hooks。相反，应始终在 React 函数的最外层（任何提前返回语句之前）使用 Hooks。

# 第4 章 使用状态快速启动组件

### 比较状态

我们之前提到过，React 在比较两个状态时会使用 `Object.is` 函数。

JavaScript 内置了七种原始数据类型：字符串（string）、数字（number）、大整数（bigint）、布尔值（Boolean）、未定义（undefined）、符号（symbol）和空值（null）。这些数据类型一旦在内存中创建，其值便无法被修改。

在 JavaScript 中，对于像对象（object）或数组（array）这样的非原始类型，会使用引用（也称为指针）来指向特定的内存空间。

这意味着，如果你创建两个新的对象，它们不会指向同一个内存空间。因此，即使这两个对象 `{}` 和 `{}` 包含完全相同的内容，对它们进行比较也会返回 `false`。

刚开始可能需要一些时间来适应使用 `Object.is` 函数或严格相等运算符（`===`）。你可以问自己一个简单的问题：要比较的值是否可变？如果可变，则按引用比较；如果不可变，则按值比较。

### 多个 dispatches  

# 第5章 使用 Effect 处理副作用

这里似乎出现了一个规律——如果 Effect 回调函数使用了某个变量，那么这个变量通常需要被添加到 `deps` 数组中。这句话在实际开发中几乎总是成立的（准确率高达 99.9%）。如果你确实希望某个变量变化时**不触发屏幕更新** ，那么你可以选择不把它添加到依赖数组中。不过，React 官方并不推荐这种做法。为了帮助开发者发现潜在的依赖遗漏问题，React 甚至专门提供了一个 ESLint 插件（`eslint-plugin-react-hooks`）。

# 第6章 使用 Memo 来提高性能

133

