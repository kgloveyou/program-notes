# advanced-react

# Chapter 1. Intro to re-renders

P8：如果没有触发状态更新，那么改变 props 将被“吞噬”：React 不会监控它们。

https://advanced-react.com/examples/01/02

这里的`prop`只是一个内部变量，并不是从外部传入的`prop`。所以，上面的说法存疑。

在重新渲染的情况下，组件的属性是否发生变化只在一种情况下才会有影响：如果所说的组件被包裹在React.memo高阶组件中。只有在这种情况下，React才会停止其自然的重新渲染链，并首先检查属性。如果没有任何属性发生变化，那么重新渲染将在那里停止。如果有一个属性发生变化，它们将像平常一样继续重新渲染。

正确地使用记忆化来防止重新渲染是一个复杂的话题，有许多注意事项。

## 自定义 hooks 的危险性

毕竟，它们被引入的目的正是为了让我们能够抽象出有状态逻辑。



因此，状态的放置位置非常重要。理想情况下，为了避免未来的性能问题，你应该尽可能将状态隔离到尽可能小而轻的组件中。

## 要点总结

- 重新渲染是React使用新数据更新组件的方式。没有重新渲染，我们的应用程序将失去互动性。

- 状态更新是所有重新渲染的初始源头。
- 如果触发了组件的重新渲染，那么该组件内部的所有嵌套组件都将被重新渲染。

- 在正常的React重新渲染周期中（没有使用记忆化的情况下），props 的变化并不重要：即使组件没有任何props，它们也会重新渲染。

- 在大型应用程序中，我们可以使用“向下移动状态”的模式来防止不必要的重新渲染。

- 在钩子中的状态更新将触发使用该钩子的组件的重新渲染，即使状态本身未被使用。

- 在使用其他钩子的钩子的情况下，该钩子链中的任何状态更新都将触发使用第一个钩子的组件的重新渲染。

# Chapter 2. Elements, children as props, and re-renders  

P28