源码

https://github.com/PacktPublishing/React-Anti-Patterns/

# 1  React 反模式介绍

本书深入探讨了 React 反模式的世界。反模式不一定是技术性错误——代码最初通常可以正常运行——但尽管它们起初看似正确，随着代码库的扩展，这些反模式可能会引发问题。

在阅读本书的过程中，我们将仔细分析可能并未体现最佳实践的代码示例；有些代码可能难以理解，有些则难以修改或扩展。虽然某些代码片段在小规模任务中尚可使用，但在规模扩大时就会失效。此外，我们还将探索来自广阔软件世界的经过时间检验的模式和原则，并将它们无缝融入我们的前端讨论中。

我追求实用性。书中的代码示例要么来自过往项目，要么来自购物车、用户资料组件等常见领域，尽量减少你对专业术语的理解负担。为了提供全面视角，末尾几章将展示详细的全流程示例，带来更有条理且沉浸式的体验。

具体来说，在本引言章节中，我们将探讨构建高级 React 应用程序的复杂性，重点说明状态管理和异步操作如何使代码清晰度变得模糊。我们将列举常见的反模式，并对本书后续详细阐述的补救策略进行简要介绍。

在本章中，我们将涵盖以下主题：  
• 理解构建用户界面的难点  
• 理解状态管理  
• 探索“异常路径”  
• 探索 React 中的常见反模式

## 理解构建用户界面的难点

## 理解状态管理

在现代前端开发中，管理状态是一项复杂的任务。几乎每个应用都需要通过网络从远程服务器获取数据 —— 我们可以将这类数据称为**远程状态（remote state）**。远程状态源自外部源，通常是后端服务器或 API。这与**本地状态（local state）**形成对比，后者完全是在前端应用内部生成和管理的。

远程状态存在许多潜在的“暗坑”，如果不加以注意，会让前端开发变得困难重重。下面我仅列出几个显而易见需要考虑的问题：

- **异步特性**：从远程源获取数据通常是一个异步操作。这在时机控制上增加了复杂性，尤其是当你需要同步多份远程数据时。

- **错误处理**：与远程源的连接可能会失败，或者服务器可能返回错误。要为用户提供流畅的体验，妥善处理这些情况颇具挑战性。

- **加载状态**：在等待远程数据到达期间，应用需要有效地处理“加载中”状态。这通常涉及显示加载指示器，或者在请求的组件不可用时使用临时的备用 UI。

- **一致性**：保持前端状态与后端同步可能很困难，尤其是在实时应用中，或者多个用户同时修改同一份数据的情况下。

- **缓存**：将部分远程状态缓存在本地可以提升性能，但也会带来新的挑战，比如缓存失效和数据过时（staleness）。换句话说，如果远程数据被其他人更改了，我们需要一种机制来接收更新或重新拉取数据以更新本地状态，这会引入大量复杂性。

- **更新与乐观 UI**：当用户做出更改时，你可以乐观地更新 UI，假定服务器调用会成功。但如果调用失败，你就需要有一种方式来撤销前端状态中的这些变更。

以上只是远程状态管理中的一部分挑战。

当数据被存储并能够立即在前端访问时，你的思维方式基本上是线性的。这意味着你可以按照一个直接的操作序列来访问和操作数据，一个操作接着另一个操作，从而形成一条清晰而直接的逻辑流程。这种思维方式与代码的同步特性非常契合，使得开发过程更加直观，也更容易理解和跟踪。

让我们来比较一下，渲染静态数据和渲染远程数据时，我们分别需要编写多少代码。想象一个经典的“名言应用”，它的功能是在页面上展示一系列名言。



当你的应用复杂度达到一定程度，使得状态追踪变得困难时，使用诸如 Redux 或 MobX 这样的第三方状态管理库可能会带来好处。然而，使用第三方状态管理库并非没有缺点（比如学习曲线、特定库的最佳实践、迁移成本等），因此应当慎重考虑。正因如此，越来越多的开发者开始倾向于使用 React 内置的 Context API 来进行状态管理。

此外，在现代前端应用中，还有一类常被许多开发者忽视、但却至关重要的复杂性，那就是“异常路径（unhappy paths）”。这类问题就像冰山一样，表面之下隐藏着更多需要深入关注的挑战。接下来，我们就来具体看看这些“异常路径”是什么。

## 探索“异常路径”（Unhappy Paths）

谈到 UI 开发，我们的主要关注点往往集中在“快乐路径”上——即一切按计划进行的最佳用户体验流程。然而，忽视“异常路径”会让你的 UI 变得比你最初想象的复杂得多。以下是一些可能导致异常路径，从而增加 UI 开发难度的场景。

### 来自其他组件抛出的错误

想象一下，你在应用中使用了一个第三方组件，甚至是另一个团队提供的组件。如果该组件抛出了一个错误，它可能会破坏你的 UI，或者引发一些你必须处理的意外行为。这可能需要你添加条件逻辑或错误边界来优雅地处理这些错误，从而使你的 UI 比最初预想的更加复杂。

举个例子，在一个渲染项目数据的 MenuItem 组件中，让我们看看当我们尝试访问传入的 prop item 中不存在的内容时会发生什么（在这个例子中，我们查找的是一个恰如其名的 item.something.doesnt.exist）。

MenuItem 组件接收一个 item 对象和一个 onItemClick 函数作为 props。它显示了该项目的名称和描述，并包含一个“加入购物车”按钮。当点击该按钮时，会调用 onItemClick 函数，并将 item 作为参数传入。

这段代码试图访问一个不存在的属性 item.something.doesnt.exist，这将导致运行时错误。如图 1.4 所示，当后端服务返回了一些意外的数据后，应用程序就停止工作了。



如果不将错误隔离到错误边界中，这可能会导致整个应用程序崩溃。如图 1.4 所示，菜单没有显示出来，但分类和页面标题仍然可以正常使用；被我用红色虚线圈起来的区域，就是本应显示菜单的地方。

在 React 中，错误边界是一种功能，它允许你捕获子组件中发生的 JavaScript 错误，记录这些错误，并显示一个备用 UI，而不是让整个应用程序崩溃。错误边界可以捕获其下方整个组件树在渲染过程中、生命周期方法中以及构造函数中发生的错误。

在实际项目中，你的 UI 可能依赖于各种微服务或 API 来获取数据。如果其中任何一个下游系统出现故障，你的 UI 就必须对此进行处理。你需要设计备用内容、加载指示器，或者友好的错误提示信息，以指导用户接下来该怎么做。有效地处理这些情况通常既涉及前端逻辑，也涉及后端逻辑，从而为你的 UI 开发任务又增加了一层复杂性。

### 应对意料之外的用户行为

无论你的 UI 设计得多么完美，用户总会以你未曾预料的方式使用你的系统。他们可能会在文本框中输入特殊字符，过快地提交表单，或者使用干扰网站功能的浏览器扩展。因此，你必须设计你的 UI，使其能够处理这些边缘情况。这意味着需要实现额外的验证、检查和安全措施，而这些都会让你的 UI 代码库变得更加复杂。

理解并有效管理这些异常路径对于创建一个健壮、有韧性且用户友好的界面至关重要。它们不仅使你的应用更加可靠，还能促成更全面、更周到的用户体验。

我相信你现在应该对在 React 中构建现代前端应用的挑战有了更清晰的认识。应对这些难题并非易事，尤其是因为 React 并没有提供明确的指导，比如应该采用哪种方法、如何组织代码结构、管理状态、确保代码可读性（进而保证长期的可维护性），以及如何利用已有的设计模式来提供帮助等。这种缺乏指导的情况常常导致开发者创建出短期内可能可行，但实际上却充斥着反模式的解决方案。

## 探索 React 中的常见反模式

在软件开发领域，我们经常会遇到一些做法和方法，它们乍一看似乎能为特定问题提供有益的解决方案。这些被称为“反模式”的实践，可能带来即时的缓解或看似快速的修复，但它们往往掩盖了潜在的问题。随着时间的推移，对这些反模式的依赖可能会导致更大的复杂性、低效性，甚至引发它们本意要解决的问题。

识别和理解这些反模式对开发者至关重要，因为这能帮助他们预判潜在的陷阱，避免采用那些从长远来看可能适得其反的解决方案。在接下来的章节中，我们将结合代码示例，重点介绍常见的反模式。我们会针对每个反模式进行分析，并概述可能的解决方案。不过，我们不会在此深入探讨，因为后续有专门的章节会详细讨论这些话题。

### Props drilling（属性层层传递）

在复杂的 React 应用中，管理状态并确保每个组件都能获取其所需的数据可能会变得具有挑战性。这种情况通常表现为 **props drilling（属性层层传递）**，即属性从父组件通过多个中间组件逐层传递，最终到达真正需要这些数据的子组件。

在 React 中，避免 props drilling 的一种潜在解决方案是利用 **Context API**。它提供了一种在组件之间共享值（数据和函数）的方式，而无需显式地通过组件树的每一层传递 props。

### 组件内数据转换  

React 以组件为中心的开发方式，旨在将任务和关注点拆分为可管理的部分，从而提升可维护性。然而，一个常见的误区是，开发者直接在组件内部引入复杂的数据转换逻辑。  

尤其是在处理外部 API 或后端数据时，常常会接收到前端并不理想的格式或结构的数据。开发者没有在更高层级或通过工具函数来调整这些数据，而是直接在组件内部定义数据转换逻辑。

通过直接在组件中嵌入数据转换逻辑，我们会遇到以下几个问题：

- **清晰度下降**：将数据获取、转换和渲染任务集中在一个组件中，使得组件的具体职责更难被识别。

- **复用性降低**：如果其他组件也需要相同或类似的转换逻辑，我们就不得不重复编写代码。

- **测试难度增加**：现在测试该组件时，还需要考虑数据转换逻辑，导致测试变得更加复杂。

为了解决这一反模式，建议将数据转换逻辑与组件分离。这可以通过使用工具函数或自定义 Hook 来实现，从而确保设计更加清晰和模块化。通过将这些转换逻辑抽离到组件外部，组件可以专注于渲染，而业务逻辑则保持集中，进而构建出更易于维护的代码库。

### 视图中的复杂逻辑

现代前端框架（包括 React）的魅力之一，在于其清晰的关注点分离。从设计上来说，组件应当对业务逻辑的复杂性保持“无知”，而专注于展示功能。然而，开发者常犯的一个错误，就是在视图组件中混入业务逻辑。这不仅破坏了清晰的分层结构，还会让组件变得臃肿，同时增加了测试和复用的难度。

为了确保我们的组件具备良好的复用性和可维护性，采用**关注点分离原则**是一个明智的选择。该原则指出，软件中的每个模块或函数都应只负责应用程序功能中的一个特定部分。通过将业务逻辑与展示层分离，并采用分层架构，我们可以确保代码的每一部分都只处理其特定的职责，从而构建出更加模块化且易于维护的代码库。

### 缺乏测试

想象一下，你正在为一个在线商店构建一个购物车组件。这个购物车至关重要，因为它负责处理商品的添加、移除以及总价的计算。尽管看起来可能很简单，但它实际上包含了多个相互关联的逻辑部分和动态行为。如果没有为它编写测试，你就为未来埋下了隐患，比如价格计算错误、商品无法正确添加或移除，甚至可能引发安全漏洞。

引入测试驱动开发（TDD）。测试驱动开发（TDD）强调在实际编写组件或逻辑之前先编写测试。以我们的 ShoppingCart 组件为例，这意味着需要先编写测试来验证商品能否正确添加或移除、总价是否能够正确调整，以及诸如处理折扣等边界情况是否得到妥善管理。只有在这些测试就位之后，才去实现实际的组件逻辑。

TDD 不仅仅是为了更早地发现错误，它还倡导编写结构良好、易于维护的代码。对于 ShoppingCart 组件而言，采用 TDD 就需要编写测试来确保商品能按预期添加或移除、总价能正确计算，同时边界情况也能被无缝处理。这样，随着应用的不断扩展，基于 TDD 编写的这些基础测试能够确保每一次修改或新增功能时，应用的整体完整性与正确性都能得以保持。

### 重复代码

在许多代码库中，我们经常会看到这样的场景：相同或非常相似的代码片段散布在应用程序的不同部分。重复代码不仅会让代码库变得臃肿，还会引入潜在的故障点。当发现一个 Bug 或需要对某项功能进行增强时，可能需要对每处重复的代码都进行修改，这大大增加了引入新错误的可能性。

DRY（Don't Repeat Yourself，不要重复自己）原则在这里就能派上用场。通过将通用逻辑抽取并集中到工具函数或高阶组件（HOCs）中，代码会变得更易于维护、更具可读性，同时也更不容易出错。以这个例子来说，我们可以将过滤逻辑抽象出来并复用，从而确保逻辑来源的唯一性，并让后续更新变得更加简单。

### 组件过于庞大，承担过多职责

React 鼓励开发者创建模块化、可复用的组件。然而，随着功能的不断增加，一个组件很容易在体积和职责上迅速膨胀，最终变成一个难以驾驭的“庞然大物”。一个负责多项任务的冗长组件，会变得难以维护、难以理解，同时也更难进行测试。

这样的组件违反了**单一职责原则（Single Responsibility Principle，SRP）**，该原则主张一个组件应该只负责一项明确的职责。当一个组件承担了多个角色时，它的复杂度就会上升，可维护性也会随之下降。以 `OrderContainer` 组件为例，我们需要分析它的核心职责是什么——比如它可能是专门用于管理订单状态或与后端交互的容器组件。然后，我们就应该把辅助性的逻辑（如表单处理、数据展示、筛选逻辑等）拆分出去，放到其他更小、更专注的子组件中，或者使用 **自定义 Hook** 来分离业务逻辑。这样不仅能让每个模块更加清晰，也便于后续的维护与测试。

> **注意**  
> 这些列出的反模式存在不同的变体，我们将在后续章节中相应地讨论其解决方案。除此之外，本书还将介绍一些更为通用的设计原则和设计模式，以及一些经过验证的工程实践，例如重构和测试驱动开发（TDD）。

### 揭示我们消除反模式的策略  

在应对常见的反模式时，一系列设计模式便成为我们的有力工具。诸如 **render props（渲染属性）**、**高阶组件（HOCs）** 和 **Hooks** 等技术，能够在不偏离组件主要职责的前提下，增强组件的功能；而采用 **分层架构** 和 **关注点分离** 等基础设计原则，则能确保代码结构清晰，将逻辑、数据和展示有条理地划分开来。这些实践不仅提升了 React 应用的可持续性，也为开发团队之间的高效协作奠定了基础。  

与此同时，**面向接口编程（Interface-Oriented Programming）** 的核心在于围绕软件模块之间的交互来构建软件，主要通过接口来实现。这种方式增强了软件的灵活性，使模块不仅更加内聚，也更容易适应变化。而 **无头组件（Headless Components）** 模式则体现为：组件本身不直接负责渲染，而是专注于管理状态或逻辑，并将 UI 渲染的任务交给使用它们的组件来完成，从而提升了组件的适应性与复用性。  

通过深入掌握这些设计模式，并合理加以运用，我们能够有效规避常见误区，从而提升 React 应用的整体质量与可维护性。

此外，在编码生态系统中，**测试驱动开发（TDD）** 与 **持续重构** 这两大支柱成为了提升代码质量的强有力工具。TDD 秉持“先写测试，再写代码”的核心理念，为潜在的问题提供了即时的反馈机制。与 TDD 相辅相成的是 **持续重构** 的理念，它确保代码始终处于优化与精炼的状态。这些方法论不仅树立了代码卓越的标杆，还为应对未来的变化赋予了更强的适应性。

在我们探索重构的世界时，深入理解这些技术的本质、洞察其精妙之处以及最佳应用时机至关重要。合理运用这些重构手段，将有助于提升代码的清晰度、可维护性以及整体效率。而这正是我们贯穿全书将要持续实践的内容！

## 本章小结

在本章中，我们探讨了 UI 开发所面临的挑战，从复杂性到状态管理问题都进行了深入分析。同时，我们也讨论了由于 UI 开发本身的复杂性而产生的一些常见反模式，并简要介绍了我们结合最佳实践与有效测试策略的应对方法。这些内容为后续实现更高效、更健壮的前端开发奠定了基础。

在接下来的章节中，我们将深入剖析 React 的核心要点，为你提供掌握这一强大库所需的工具与知识。敬请期待！

# 2 理解 React 核心要点

## 理解 React 中的静态组件

React 应用是由组件构建而成的。一个组件可以很简单，只是一个返回 HTML 片段的函数；也可以很复杂，它能够发起网络请求、动态生成 HTML 标签，甚至能根据后端服务的变更自动刷新页面。

让我们从一个基础场景入手，来定义什么是**静态组件**。在 React 中，**静态组件**（也被称为展示型组件或“无逻辑组件 / 哑组件”，英文常称为 *presentational components* 或 *dumb components*）指的是这样一种组件：它内部没有状态（state），不处理数据交互逻辑，也不响应用户事件。它唯一的职责，就是根据接收到的属性（*props*）来渲染界面。下面是一个简单的例子：

```tsx
const StaticArticle = () => {
  return (
    <article>
      <h3>Think in components</h3>
      <p>It's important to change your mindset when coding with React.</p>
    </article>
  );
};
```

## 通过 Props 创建组件

在 React 中，组件可以通过一种称为 props（属性） 的方式接收输入。Props 允许我们将数据从父组件传递给子组件。这种机制使得组件具有高度的可复用性和灵活性 —— 因为通过传入不同的 props，我们可以定制组件的行为和外观。

## 将 UI 拆分为多个组件

让我们来看一个更复杂的用户界面，并探讨如何将其拆分成多个组件，然后分别实现它们。在这个例子中，我们将以一个天气应用为例来进行说明。

## 在 React 中管理内部状态

在 React 中，状态（state） 是指组件可以持有并管理的内部数据。它允许组件存储和更新信息，从而实现动态的用户界面更新、交互功能以及数据的持久化表现。状态是 React 中的一个核心概念，它为构建响应式和交互式的应用程序提供了基础支持。

## 理解 React 的渲染过程

当 React 组件所依赖的数据发生变化时 —— 无论是由于 props（属性）被更新，还是 state（状态）被修改 —— React 都需要更新用户界面以反映这些变化。这个过程就叫做 渲染（rendering），它主要包含以下几个步骤：

- 初始渲染（Initial render）
  当一个函数式组件首次被渲染时，它会生成该组件 UI 的一个 虚拟表示（virtual representation），也就是我们常说的 虚拟 DOM（Virtual DOM）。这个虚拟表示描述了 UI 元素的结构和内容，但并不是真实的 DOM，而是一个轻量级的 JavaScript 对象，用于提高渲染效率。

- 状态与属性的变化（State and props changes）
  当组件的 state（状态） 或 props（属性） 发生变化时，React 会重新执行该组件的函数体（对于函数组件而言）。然后，React 会运行一个称为 diffing（差异比较）算法 的过程，来比较当前渲染结果（新的函数返回值）与上一次渲染结果（旧的虚拟 DOM）之间的差异。

- 协调（Reconciliation）
  基于差异比较的结果，React 会判断出 UI 中 哪些部分真正需要更新，哪些可以保持不变。这个过程叫做 协调（Reconciliation），它的目标是尽量减少对真实 DOM 的操作，只更新必要的部分，从而提升性能。

- 重新渲染（Re-rendering）
  React 会根据最新的函数体（即新的 state 或 props 下的组件输出），重新生成一份 新的虚拟 DOM 表示。这个过程就是所谓的 重新渲染（Re-rendering），但它并不是直接操作浏览器中的真实 DOM，而是在内存中对虚拟 DOM 进行更新。

- 更新真实 DOM（DOM update）
  最后，React 会将新的虚拟 DOM 与之前的虚拟 DOM 进行对比，计算出最终需要应用到真实 DOM 上的最小变更集。随后，React 会高效地更新真实 DOM，比如添加新元素、移除旧元素或者修改已有元素的属性和内容，从而使用户界面反映出最新的 state 和 props 状态。

这一过程确保了用户界面与组件的状态和属性保持同步，从而实现一个响应式且动态的用户界面。React 高效的渲染方式最大程度地减少了不必要的 DOM 操作，为函数组件提供了高性能的渲染体验。  

在本书中，我们将探讨那些对编写高性能代码至关重要的场景，确保组件只在必要时重新渲染，同时保留未变化的部分。要实现这一点，需要有效地使用 Hooks 并采用各种技术来优化渲染过程。  

在一个应用中，数据管理至关重要，但我们也会遇到诸如网络请求、DOM 事件以及在组件间共享数据等副作用问题。 为了应对这些挑战，React 提供了一系列常用的 Hooks，它们是构建应用程序的强大工具。  让我们来探索这些 Hooks，看看它们如何能在我们的开发过程中提供巨大帮助。

## 探索常用的 React Hooks

### useEffect

在 React 中，**副作用（side effect）** 指的是任何不直接参与组件渲染，但却对组件作用域之外产生影响的代码。 副作用通常涉及与外部资源的交互，例如发起 API 请求、直接操作底层 DOM（而非使用 React 的虚拟 DOM）、订阅事件监听器或管理定时器等。

React 提供了一个内置的 Hook，名为 **useEffect**，用于在函数组件中处理副作用。  **useEffect** Hook 允许你在组件渲染完成后，或在某些特定依赖项发生变化时，执行副作用操作。

通过使用 **useEffect** Hook，你可以确保副作用在组件生命周期中的适当时机执行。  这有助于保持应用的一致性与完整性，同时将副作用逻辑与核心渲染逻辑分离开来。



值得一提的是，在开发模式下开启严格模式（Strict Mode）时，React 会在实际执行初始化逻辑之前，**额外多运行一次组件的初始化和清理函数**。实际上，你可以将整个应用包裹在 React 提供的内置组件 **StrictMode** 中，这样你的组件会多渲染一次，从而帮助发现由非纯渲染（impure rendering）引起的 bug，同时进行其他检查。

另外需要注意的是，**useEffect 的第二个参数非常重要**。我们之前使用了空数组 `[]`，是因为我们不希望副作用在每次渲染时都触发；但在某些情况下，我们希望**当某个依赖项发生变化时，就执行该副作用**。

```tsx
  useEffect(() => {
    const controller = new AbortController();
    const signal = controller.signal;
    const fetchArticleDetail = async (id: string) => {
      fetch(`/api/articles/${id}`, { signal })
        .then((res) => res.json())
        .then((data) => setArticle(data));
    };

    fetchArticleDetail(id);

    return () => {
      controller.abort();
    };
  }, [id]);
```

在这个代码片段中，我们在 `useEffect` Hook 内部使用了一个 **AbortController** 来管理网络请求的生命周期。当组件挂载时，`useEffect` 被触发，创建一个新的 `AbortController` 实例，并提取其 `signal`。  这个 `signal` 被传递给 `fetch` 函数，从而将请求与控制器关联起来。

如果组件在请求完成之前被卸载，那么清理函数（cleanup function）就会被调用，利用控制器的 `abort` 方法来取消正在进行的 `fetch` 请求。 这样可以避免潜在的问题，比如尝试更新一个已卸载组件的状态，从而提升性能并防止内存泄漏。

接下来，让我们把注意力转向另一个关键的 Hook，它通过在重新渲染时避免不必要的函数创建，从而提升性能。

### useCallback  

### The React Context API  

# 3  组织你的 React 应用程序

欢迎来到本章，我们将深入探讨组织 React 项目的各种策略。在这里，我们将超越代码本身，进入引人入胜的应用程序架构世界——这是软件开发中至关重要的一部分，但在前端领域往往没有得到应有的重视。

在本章中，你将了解不同的 React 项目结构策略，包括基于功能的结构（feature-based structure）、基于组件的结构（component-based structure）、原子设计结构（atomic design structure）以及模型-视图-视图模型结构（Model-View-ViewModel，简称 MVVM 结构），并学习每种方法所带来的独特优势与潜在陷阱。你还将看到这些结构的实际示例，了解何时选择某一种结构而非另一种，以及每种决策背后的权衡。

但为什么我们首先需要关注项目结构呢？一个结构良好的项目可以显著提高代码的可维护性，让新团队成员更容易理解系统，增强可扩展性，甚至影响项目的整体成功。相反，一个低效的结构可能导致代码异味、复杂度增加，并成为技术债务的来源。

通过理解这些结构策略，你将更有能力做出对项目健康和长期成功具有深远影响的决策。你将能够评估项目的具体需求和约束，并将这些策略作为指引，从而构建出能提升代码质量、营造高效开发环境并最终促成项目成功的项目结构。

## 理解结构松散的项目所存在的问题

## 理解前端应用程序的复杂性

## 探索 React 应用中的常见结构

在组织大型 React 应用时，有多种不同的方式。在接下来的小节中，我们将讨论四种最常见的结构：

- 基于功能的结构（Feature-based structure）  
- 基于组件的结构（Component-based structure）  
- 原子设计结构（Atomic design structure）  
- MVVM 结构（MVVM structure）  

每种结构都有其自身的优点和缺点，选择哪种结构取决于项目的具体需求和复杂程度。有时，我们可能需要以某种方式将它们混合使用，以便更好地适应项目的特定需求。

为了更深入地探讨这些不同的结构方法，我们将以一个在线购物应用为例，因为该应用相对复杂，而且你应该已经对这个领域有所了解。该应用还包含诸如 API 调用、路由器和状态管理等元素。

### 基于功能的结构

### 基于组件的结构

### 原子设计结构

### MVVM 结构

## 保持项目结构有序

基于功能的结构通常是一个很好的起点。随着项目规模的扩大，重复的模式开始显现，此时可以引入额外的层级来消除冗余。

# 4  设计您的 React 组件

欢迎来到这一关于掌握 React 组件设计的关键章节。在本章中，我们将开启一段富有收获的旅程，去识别并消除在 React 组件设计中常见的反模式（anti-patterns），包括诸如大型单体组件（large monolithic components）、属性钻取（prop drilling）等问题，以及其他常令开发者困惑、并影响 React 应用可维护性与可扩展性的常见陷阱。

首先，我们将介绍**单一职责原则（Single Responsibility Principle）**。在 React 的领域中，该原则指导我们确保每个组件只承担一个特定的职责。遵循这一原则，可以让组件更易于理解、测试和维护，同时也能使代码更具可读性和可管理性。

接下来，我们将探讨**不要重复自己原则（Don’t Repeat Yourself，简称 DRY）**。这是高效编程的核心原则之一，鼓励开发者尽量减少代码重复，提倡复用。在 React 的上下文中，这一原则可能是构建更精简、高效且易于维护的代码库的关键所在。

最后，我们将深入研究**组件组合原则（Component Composition Principle）**。组合允许我们通过将更简单、可复用的组件组合在一起，来构建复杂的用户界面。在 React 中，组合比继承更受推崇，这使得组件更加灵活且更易于管理。

在本章中，我们将深入剖析每一个原则，提供实际案例和实用应用。通过这些内容，我们旨在指导你打造更高效的组件，加深你对 React 潜力的理解，并提升你在这个强大库中的问题解决能力。

因此，在本章中，我们将涵盖以下主题：  
- 探索**单一职责原则**  
- 了解**不要重复自己原则（DRY）**  
- 使用**组件组合**  
- 结合运用**组件设计原则**  

## 探索单一职责原则

单一职责原则（Single Responsibility Principle，简称 SRP）是软件工程中的一个基本概念，它主张一个函数、类，或者在 React 的语境下，一个组件，应该只有一个修改的理由。换句话说，每个组件最好只负责处理一项任务或一种功能。遵循这一原则可以使你的代码更具可读性、更易于维护，同时也更便于测试和调试。

```tsx
import React, { useState, useEffect } from "react";
import fetchPostById from "./fetchPostById";

interface PostType {
  id: string;
  title: string;
  summary: string;
}

const BlogPost = ({ id }: { id: string }) => {
  const [post, setPost] = useState<PostType>(EmptyBlogPost);
  const [isLiked, setIsLiked] = useState(false);
  useEffect(() => {
    fetchPostById(id).then((post) => setPost(post));
  }, [id]);
  const handleClick = () => {
    setIsLiked(!isLiked);
  };
  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <button onClick={handleClick}>
        {isLiked ? "Unlike" : "Like"}
      </button>
    </div>
  );
};

export default BlogPost;
```

虽然这段代码能够正常运行，但它违反了**单一职责原则（SRP）**。它同时承担了三个不同的职责：获取数据、展示博客文章内容，以及处理点赞功能。为了更好地遵循 SRP，我们应该将其重构为几个更小、职责更单一的组件：



在这里，我们将 BlogPost 拆分为更小、具有单一职责的组件：  
• useFetchPost 是一个自定义 Hook，负责获取博客文章数据  
• LikeButton 是一个组件，负责处理点赞功能  
• BlogPost 现在只负责渲染博客文章内容和 LikeButton  

每个部分都只有一个职责，可以独立进行测试和维护，从而形成一个更易于管理的代码库。

那么，在第一节中，我们探讨了**单一职责原则（SRP）**。该原则鼓励每个组件只负责一项功能，从而使我们的代码更易于维护和理解。在这里，我们应用这一原则，将庞大、臃肿的组件拆分为更小、更易管理的部分。

随着我们在设计之路上继续深入，下一节将引导我们认识一个与 SRP 理念紧密相连的原则——**不要重复自己原则（Don’t Repeat Yourself，简称 DRY）**。

## 不要重复自己（DRY 原则）

**不要重复你自己（Don’t Repeat Yourself，简称 DRY）** 是软件开发中的一个基本原则，旨在减少代码中的重复内容。遵循这一原则可以提高代码的可维护性、可读性和可测试性，并有助于避免因逻辑重复而引发的错误。

## 使用组合（Using Composition）

在 React 中，**组合（Composition）** 是组件模型的一个自然模式。例如，JSX 的标记语言语法让我们可以无缝地将一个 `<div>` 与 `<h2>` 标签搭配使用，而无需引入任何额外的机制。

自定义组件与内置组件（比如 `<div>`）并没有本质上的区别：你可以像使用 `<p>` 标签一样，将 `<Cart>` 组件与 `<div>` 一起使用。这种模式使得组件的复用更加直接，有助于编写更简洁、更易于维护的代码。



重构后的 **UserDashboard** 组件之所以更优秀，主要基于以下几个原因：

- **关注点分离（Separation of Concerns）**：通过将组件的不同部分（如用户资料、好友列表和帖子列表）拆分成独立的组件（即 **UserProfile**、**FriendList** 和 **PostList**），确保每个组件只负责一项任务。这大大提升了代码的可维护性。

- **可读性增强（Readability）**：新的 **UserDashboard** 版本更易于阅读和理解。我们可以一眼看出这个组件渲染了哪些内容：用户资料、好友列表和帖子列表。无需深入查看每个部分的渲染细节，整体结构一目了然。

- **可复用性提升（Reusability）**：现在，**UserProfile**、**FriendList** 和 **PostList** 这些组件可以在应用的其他地方根据需要进行复用，从而促进代码复用，减少冗余。

- **更易测试（Testability）**：更小、职责单一的组件更容易进行测试，因为它们通常具有更少的交互逻辑和依赖关系。关于测试及可测试性的内容，我们将在第 5 章详细讨论。

这虽然只是一个简单的例子，但它很好地展示了 React 中 **组合（Composition）** 的核心思想。当处理带有自身状态或逻辑的组件时，组合可能会变得更加复杂，但其核心原则始终不变：**通过将多个小而可复用的组件组合在一起，构建出更大、功能更丰富的组件**。

本节让我们认识到了 React 中 **组合的强大能力**。借助组合，我们能够高效地组织和组合组件，从一个个职责单一的小组件构建出复杂的用户界面。同时，我们也看到，组合使我们能够充分发挥 **单一职责原则（SRP）** 和 **不要重复自己原则（DRY）** 的优势，最终打造出既复杂又易于理解、测试和维护的用户界面。

## 组合运用组件设计原则  

我们已经分别分析了单一职责、不要重复自己以及组合这三个原则。然而，在实际的编码场景中，情况可能变得复杂，需要同时运用多个原则来提升代码的可读性与可维护性。



Page 组件承担了多个职责，并且它拥有一个很长的 props 列表，这可能会使它的使用变得困难。当一个组件的 props 超过五个时——也就是所谓的“长 props 列表”——通常意味着需要对组件进行拆分。这是因为记住每个 prop 的用途可能会很有挑战性，同时也增加了传错 prop 或者 prop 顺序出错的可能性。

## 总结  

本章介绍了在 React 中设计和开发组件时涉及的几个关键原则：**单一职责原则（SRP）**、**不要重复自己原则（DRY）** 以及 **组件组合（Component Composition）**。这些原则各自提供了不同的策略，以实现代码的整洁性、可维护性和可扩展性。  

通过理解和应用这些原则，我们能够为 React 应用打下坚实的基础。这些策略有助于构建更加有条理、可扩展且健壮的代码库，最终让我们的开发工作更加高效、更加愉快。  

在下一章中，我们将开始探讨 React 应用中一个令人兴奋的主题 —— **测试**，并了解良好的结构化测试如何帮助我们避免错误，同时提升代码质量。

# 5  React 中的测试
欢迎来到这一深入探讨 React 测试的章节。在本章中，我们将学习软件测试的重要性，了解不同类型的测试——包括单元测试（Unit Testing）、集成测试（Integration Testing）和端到端测试（End-to-End，简称 E2E 测试），并深入研究一些流行的测试工具，例如 **Cypress**、**Jest** 和 **React Testing Library**。此外，我们还将揭开诸如 **存根（Stubbing）** 和 **模拟（Mocking）** 等概念的神秘面纱，确保你能够应对复杂的测试场景。

我们的总体目标是帮助你建立对测试策略及其在 React 中实践的扎实理解。我们旨在提升你编写测试的能力，从而让你的应用更具抵御 Bug 和回归问题的能力，并确保新功能的无缝添加。

在本章结束时，你将对 React 测试有一个全面的认识，并准备好在你的项目中实施高效的测试实践。那么，让我们开始，一起踏入 React 测试这个令人兴奋的世界吧！

在本章中，我们将涵盖以下主题：

- 了解我们为什么需要测试  
- 学习不同类型的测试  
- 使用 Jest 进行单元测试  
- 学习集成测试  
- 学习使用 Cypress 进行端到端测试（E2E）

## 了解不同类型的测试

在软件开发领域，测试并非一种“一刀切”的方法。相反，它被分为不同的类型，每种类型都有其独特的目的，能够从不同角度揭示应用程序的功能与可靠性。理解这些分类对于确保应用的总体健康状态和稳健性至关重要。通常，在一个代码库中，你会看到 **单元测试（Unit Tests）**、**集成测试（Integration Tests）** 和 **端到端测试（End-to-End，简称 E2E 测试）** 这几种类型。

下面我们将对这些类型进行简要定义，并在后续小节中逐一详细讨论：

- **单元测试（Unit Tests）**：这类测试专注于单独测试某个组件或函数，以确保它们在隔离状态下按预期工作。
- **集成测试（Integration Tests）**：这类测试检查不同模块或服务之间的交互，以验证它们能否协同一致地工作。
- **端到端测试（E2E Tests）**：这类测试模拟真实用户行为，从头到尾测试整个应用流程，以验证系统作为一个整体是否正常运行。

你在一个项目中如何组织这些测试同样非常重要。例如，你应该拥有大量运行快速并能提供详细反馈的 **单元测试**，而 **端到端测试** 则应该相对较少，主要用于确保所有部分能够协同工作。这种做法符合 **测试金字塔（Test Pyramid）** 的原则。

**测试金字塔** 最初由 Mike Cohn 提出，它建议在项目中应包含比集成测试或端到端测试数量更多的 **单元测试**。其背后的逻辑很简单：**单元测试运行更快、更简单，且维护成本更低**。

然而，在现代前端开发领域，这一模型正在不断演变。由于前端应用变得越来越复杂且交互性更强，集成测试和端到端测试的价值正日益凸显。诸如 Cypress 和 Puppeteer 等工具使得编写能够模拟用户在浏览器中行为的端到端测试变得更加容易，而像 React Testing Library 这样的库则通过简化组件交互的测试，鼓励开发者编写更多的集成测试。

前端应用中也引入了一些新的测试类型，其中之一便是**视觉回归测试（Visual Regression Testing）**。

视觉回归测试是一种测试方法，它会捕获 Web 应用的视觉呈现，并将其与之前的状态或版本进行对比。这种测试特别适用于捕捉开发过程中可能无意中引入的用户界面视觉错误或变化。

视觉回归测试的工作原理是：在不同的阶段对网页或组件进行截图（或称为快照），然后逐像素比较这些截图，以识别任何视觉上的差异。当检测到差异时，该差异会被标记出来供审查。审查人员随后可以判断该变化是预期的（比如由于新功能或设计更新所致），还是意外的回归问题，需要进行修复。

在前端测试中，**静态检查（Static Checks）** 指的是在不执行代码的情况下分析代码，以发现错误并确保代码规范。这包括检查语法错误、通过代码检查工具（linting）强制执行编码风格、通过类型检查验证数据类型是否正确、分析代码复杂度、检查依赖项以及识别安全漏洞等。

你的测试金字塔的具体形态可能会因应用的需求而有所不同，但关键要点在于：要制定一个**平衡的测试策略**，从而在应用的不同层级上提供**快速且有价值的反馈**。

本章接下来的几节将带你动手实践，为 React 应用编写这些不同类型的测试，确保你能够充分掌握这些概念，并将其运用到自己的项目中。让我们继续前进吧！

## 使用 Jest 测试单个单元  

单元测试是测试金字塔中最小也是最基础的部分，用于验证代码中单个单元（如函数、方法或组件）在隔离环境下的行为。这类测试编写和执行速度都很快，能为开发者提供即时的反馈。

在本书中，我们将使用 Jest 来编写单元测试和集成测试。Jest 是由 Facebook 开发的一个功能全面的 JavaScript 测试框架，以简洁易用为核心设计理念。它功能强大，支持异步测试、模拟（mocking）和快照测试（snapshot testing），因此是 React 应用非常理想的选择。

### 编写你的第一个测试

让我们来写一个简单的测试。假设你在名为 `math.ts` 的文件中有一个 `add` 函数：

```typescript
export function add(a: number, b: number) {
  return a + b;
}
```

为了测试这个函数，你需要在同一目录下创建一个名为 `math.test.ts` 的文件：

```typescript
import { add } from './math';

test('add adds numbers correctly', () => {
  expect(add(1, 2)).toBe(3);
});
```

现在，你已经写出了你的第一个测试！`test` 函数接受两个参数：一个是描述该测试的字符串，另一个是实现测试逻辑的回调函数。`expect` 是 Jest 提供的一个函数，用于传入实际值；而 `toBe` 是一个匹配器（matcher）函数，用于将实际值与期望值进行比较。

另一种编写测试的方式是使用 `it` 函数。在 Jest 中，`test` 和 `it` 实际上是同一个函数，可以互换使用，只是名称来源于不同的测试惯例：

- **test**：这是许多测试框架和编程语言中常见的测试函数命名方式。如果你之前使用过其他测试库，可能会觉得 `test` 更加直观或熟悉。
  
- **it**：这个名称来源于行为驱动开发（Behavior-Driven Development，简称 BDD）风格的测试框架，比如 Jasmine 或 Mocha。

使用 `it` 的目的是让测试读起来更像自然语言中的句子。例如：

```typescript
it("adds 1 + 2 to equal 3", () => expect(1 + 2).toBe(3));
```

这句话读起来就像是：“it adds 1 + 2 to equal 3.  ”这样的写法有助于提高测试代码的可读性，尤其是在编写更复杂的测试场景时。



这取决于团队的偏好以及哪种方式最符合你们团队的测试理念——有些团队更喜欢 `it` 所提供的类似句子的结构，因为它通常能让测试试图验证的内容更加清晰，尤其对于非开发人员来说更是如此；而另一些团队可能认为 `test` 更直接、更简洁。在本书中，我们将采用符合 BDD（行为驱动开发）风格的测试编写方式。

### 分组测试

将相关的测试放在一个块（block）中进行分组，可以显著提高测试文件的可读性。通过清晰地划分不同功能区域，测试块能够让阅读测试代码的人一眼就了解整个测试套件的上下文。这种增强的理解对于弄清楚正在验证哪些功能至关重要。在一个大型代码库中，面对大量的测试用例，这种组织方式可以大大降低理解应用程序各部分是如何被测试所需的认知负担。

在 Jest 中，我们可以使用 `describe` 函数将相关的测试归为一组。例如，假设有一个 `add` 函数，它包含多种情况：正数相加、一负一正数相加、小数相加，甚至涉及虚数的计算等。将这些不同的测试用例归类到一个 `describe` 块中是明智的做法，如下所示：

```typescript
import { add } from './math';

describe('math functions', () => {
  it('adds positive numbers correctly', () => {
    expect(add(1, 2)).toBe(3);
  });

  it('adds negative numbers correctly', () => {
    expect(add(-1, -2)).toBe(-3);
  });

  // 更多测试...
});
```

**describe 函数用于将相关的测试归为一组——在本例中，是对某些数学函数的测试。**  在这个组中，有两个 `it` 函数，每个都代表一个单独的测试。第一个测试检查 `add` 函数是否能正确地将两个正数相加，第二个测试则检查 `add` 函数是否能正确地将两个负数相加。

使用 Jest 时，你可以嵌套 `describe` 块，以便更有系统地组织测试。例如，假设我们要扩展测试套件，使其包含计算器功能中的减法、乘法和除法。我们可以按以下方式构建测试套件：

```typescript
describe('calculator', () => {
  describe('addition', () => {
    it('adds positive numbers correctly', () => {
      expect(add(1, 2)).toBe(3);
    });
    it('adds negative numbers correctly', () => {
      expect(add(-1, -2)).toBe(-3);
    });
    // 更多测试...
  });

  describe('subtraction', () => {
    it('subtracts positive numbers', () => {});
  });
  // 其他用于乘法和除法的 describe 块
});
```

在这个代码片段中，我们有一个顶层的 `describe` 块，标记为 `calculator`。在这个块中，我们为每种数学运算嵌套了单独的 `describe` 块。例如，在 `addition` 块中，我们为不同数字相加的场景编写了单独的 `it` 测试。同样地，我们为减法新建了一个 `describe` 块。这种嵌套结构使得我们的测试套件更加有条理、更易读，也更容易导航，尤其是在处理大量测试或复杂场景时。

### 测试 React 组件

正如我们之前提到的，Jest 是一个强大的工具，可用于测试各种类型的应用程序，并且开箱即用地支持 React 应用。虽然可以单独使用 Jest，但相比使用像 React Testing Library 这样的专用库，单独使用 Jest 会显得更加繁琐和冗长。

**React Testing Library** 是一个轻量级但功能强大的库，专门用于测试 React 组件。它基于流行的 JavaScript 测试框架 Jest 构建，并为处理 React 组件添加了一些专门的工具。React Testing Library 的核心理念是鼓励你编写更贴近用户实际使用方式的测试。它鼓励你像用户一样与应用程序进行交互，也就是说，你测试的是功能，而不是实现细节。这种测试方式能够带来更健壮、更易于维护的测试用例，让你对应用在生产环境中的表现更有信心。

本书中提供的代码已经为你配置好了 React Testing Library。你只需将“技术要求”部分提到的代码克隆到本地目录，就可以直接开始使用了。

好了，让我们从一个简单的 React 组件开始，看看如何使用 React Testing Library 对其进行测试。**Section 组件** 是一个展示型组件，它接收两个 props：`heading` 和 `content`，并将它们渲染在一个 `<article>` 标签中：

```typescript
type SectionProps = {
  heading: string;
  content: string;
};

const Section = ({ heading, content }: SectionProps) => {
  return (
    <article>
      <h1>{heading}</h1>
      <p>{content}</p>
    </article>
  );
};

export { Section };
```

为了测试这个组件，我们可以在 `Section.tsx` 旁边创建一个新的文件，命名为 `Section.test.tsx`，我们的测试代码将写在这个文件中。接下来，我们将使用 React Testing Library 来检测 `Section` 组件。


```typescript
import React from "react";
import { render, screen } from "@testing-library/react";
import { Section } from "../component/Section";

describe("Section", () => {
  it("renders a section with heading and content", () => {
    render(<Section heading="Basic" content="Hello world" />);
    expect(screen.getByText("Basic")).toBeInTheDocument();
    expect(screen.getByText("Hello world")).toBeInTheDocument();
  });
});
```

这段测试代码使用了 **@testing-library/react** 来验证 **Section** 组件是否按预期工作 —— 即页面中应该包含文本 `"Basic"` 和 `"Hello world"`。其中，**@testing-library/react** 提供的 **render** 函数用于渲染 **Section** 组件，并传入特定的 props：标题为 `"Basic"`，内容为 `"Hello world"`。

在组件渲染完成后，使用 **screen.getByText** 函数来查询 DOM（该 DOM 表示的是 **Section** 组件的渲染输出），查找包含特定文本的元素。

接着，使用 **expect** 和 **toBeInTheDocument** 断言这些元素的状态。具体来说，该测试断言 DOM 中存在包含文本 `"Basic"` 的元素，以及包含文本 `"Hello world"` 的元素，这意味着 **Section** 组件已正确渲染了它的 `heading` 和 `content` 这两个 props。

这个针对 React 组件的简单单元测试是一个很好的起点。然而，在复杂的真实项目中，我们经常会遇到多个组件需要协同工作的场景。例如，一个结账页面可能会集成地址收集组件、支付组件以及价格计算逻辑组件。

为了确保这些不同组件之间能够无缝协作，我们必须采用一种更全面的测试策略：**集成测试（integration tests）**。

## 了解集成测试

集成测试位于测试金字塔的更高层级，用于验证多个代码单元之间的交互。这些单元可以是组件之间的交互，也可以是客户端与服务器端之间的交互。集成测试旨在发现当系统的不同部分组合在一起时可能产生的问题。

一个典型的例子是测试两个独立组件之间的交互，以确保它们能够正确地协同工作 —— 这属于 UI 组件层面的集成测试。此外，如果你希望确保前端代码与后端服务之间能够顺畅协作，那么为此编写的测试也属于集成测试，这类测试验证的是应用程序的不同层级能否正确地一起工作。

让我们来看一个针对 React 组件的集成测试示例。在图 5.3 中，有一个“条款与条件”部分，其中包含一段关于法律信息的长文本，以及一个供用户勾选同意的复选框。此外还有一个“下一步”按钮，默认情况下是禁用的。但是，一旦用户勾选了“我接受条款与条件”，该按钮就会被启用，用户便可以继续操作。

这个集成测试可以用以下代码片段来描述 —— 我们并不是分别测试复选框（Checkbox）和“下一步”按钮（Next button），而是验证它们之间的交互行为：

```typescript
describe('Terms and Conditions', () => {
  it("renders learn react link", () => {
    render(<TermsAndConditions />);
    const button = screen.getByText('Next');
    expect(button).toBeDisabled();
    const checkbox = screen.getByRole('checkbox');
    act(() => {
      userEvent.click(checkbox);
    });
    expect(button).toBeEnabled();
  });
});
```

这里的 `describe` 函数用于将与 `TermsAndConditions` 组件相关的所有测试归为一组，形成一个所谓的**测试套件（test suite）**。在这个套件中，我们有一个单独的测试用例，由 `it` 函数表示。该测试的描述为 `"renders learn react link"`，但从这个测试中实际执行的操作来看，这个描述似乎不太准确。一个更合适的描述可能是：**"Enables the next button upon accepting terms and conditions"（在用户接受条款与条件后启用下一步按钮）**。

首先，调用 `render` 函数来渲染 `TermsAndConditions` 组件。这个函数会生成一系列输出，也就是组件的渲染结果，我们可以通过多种方式对这些结果进行查询，以判断组件是否按预期工作。



在这个代码中，唯一被导出的组件是 **TermsAndConditions**，这也是我们测试策略的主要对象。在我们的测试中，我们使用了 **userEvent.click** 来在 **jsdom** 环境中触发一次点击事件。

本质上，我们关注的重点并不是去测试那些独立的 React 组件（比如 **CheckBox** 和 **Button**；这些组件应该有它们自己的单元测试），而是关注 **DOM 元素以及它们之间的交互行为**。需要明确的是，我们并没有启动一个完整的浏览器，而是一个运行在内存中的、无界面的 **jsdom（headless jsdom）** 版本。尽管这些集成测试是在一个**模拟的环境**中运行的，但它们仍然能够为我们提供足够的信心，确认点击事件和按钮的启用功能都按预期正常工作。

> **注意：**
>
> *jsdom** 是一个基于 JavaScript 的无界面（headless）浏览器，它可以用来创建一个逼真的测试环境，模拟浏览器的运行环境。它完全使用 JavaScript 实现了对诸如 **HTML、DOM、CSS** 等 Web 标准的支持。
>
> 当我们在浏览器中运行操作 DOM 的 JavaScript 代码时，浏览器本身提供了 DOM 环境。然而，当我们使用像 **Jest** 这样的测试框架，在 **Node.js 环境** 下运行测试时，默认情况下是没有 DOM 的。这时候，**jsdom 就派上了用场**。它提供了一个虚拟的 DOM，从而让我们的测试代码即使在 **Node.js 环境中运行，也能像是在真实的浏览器环境中一样执行**。
>
> 为什么我们需要 jsdom？在现代前端开发中，尤其是在使用 **React、Angular 和 Vue** 等框架时，我们的 JavaScript 代码经常直接与 DOM 进行交互。为了使测试具有实际意义，测试环境需要能够模拟这种与 DOM 的交互行为。**jsdom 允许我们在不打开真实浏览器窗口的情况下，模拟出这样的交互环境**，使得我们可以在命令行或 CI/CD 流程中高效地进行前端组件的功能测试，尤其是集成测试和部分 UI 行为的测试。

在集成测试中，我们主要关注的是各个模块之间的交互。然而，即使这些交互本身按预期工作，整个系统仍然有可能出现故障。用户的使用流程（user journeys）通常涉及多个步骤，因此，我们需要一个能够将这些步骤无缝连接起来的流程，以确保软件在整体上依然能够可靠地运行。

## 了解使用 Cypress 进行端到端（E2E）测试

端到端测试位于测试金字塔的顶端。这类测试模拟真实的用户操作流程和交互，对整个系统进行测试。它们有助于确保应用程序的所有部分——从用户界面到后端系统——都能如预期般协同工作。

在本教程中，我们将使用 Cypress 作为端到端测试框架。Cypress 是一个功能强大的工具，专门用于现代 Web 应用程序的端到端测试。它采用了一种独特的方法，使其与许多其他测试工具区别开来——它不像许多测试系统那样使用 Selenium（一种常见的测试引擎），而是直接在实际浏览器中运行，从而带来更可靠的测试结果和更出色的调试体验。

### 安装 Cypress

你可以将 Cypress 安装到现有项目中（就像本书中所做的那样），也可以将其安装在项目之外的其他文件夹中。在 GitHub 上提供的代码库（详见“技术要求”部分）中，Cypress 已经作为项目依赖项添加到了代码中，因此你只需要在项目根目录下运行 `npm install` 即可（更多信息请参考官方文档：https://docs.cypress.io/guides/getting-started/installing-cypress）。

### 运行我们的第一个端到端（E2E）测试

### 拦截网络请求

在某些情况下，我们并不希望 UI 为了正常工作而发送真正的网络请求；而在另一些情况下，直接依赖响应内容也不切实际。我们想通过检查内容来验证引语是否正确渲染，但由于引语内容是随机生成的，我们在发起网络请求之前无法预知其具体内容。这意味着我们需要一种机制来固定响应内容，但同时仍然希望发送该请求。

实现这一目标的一种方法是拦截发送到该端点的网络请求，并返回一些固定的数据。在 Cypress 中，我们可以通过 `cy.intercept` API 来实现这一点。

## 总结

在本章中，我们踏上了探索 React 应用程序测试世界的旅程。我们认识到，测试的必要性不仅仅在于验证代码的正确性；它还为代码的可维护性铺平了道路，提升了代码的可读性，并推动应用程序的不断演进，最终确保我们构建出始终符合预期的软件。

测试是软件开发中的一项关键实践——它不仅确保我们的应用程序能够正常运行，还使其能够抵御未来的变更。React 生态系统为我们提供了强大的工具集，如 Jest、React Testing Library 和 Cypress，让我们能够实施全面的测试策略，从而增强应用程序的健壮性与可靠性。

在下一章中，我们将探讨常见的重构技术，并了解测试如何在重构过程中为我们提供帮助。

# 6 探索常见的重构技术

## 在重构前添加测试

因为我们不希望在重构过程中引入任何可观察到的行为变化，所以需要检查代码，以确保我们有足够的测试来覆盖当前的行为。如果没有适当的测试，很容易出错，这不仅风险较高，而且效率较低，因为我们需要反复手动检查修改后的代码。

假设我们有一个来自在线购物应用的 TypeScript 代码 —— 这段代码运行良好，但没有任何与之相关的测试。为了改进代码，使其更易于理解和扩展，我们需要对其进行重构：

## 使用“用管道替换循环”技术

顾名思义，“用管道替换循环”（Replace Loop with Pipeline）重构技术，指的是用一系列转换操作（即管道）来替代循环结构。在像 JavaScript 这样的函数式编程语言中，通常通过使用高阶函数或方法（如 map、filter 和 reduce）来实现这种替换。

## 使用提取函数（Extract Function）

“提取函数”是一种重构技术，它通过将一个庞大或复杂的函数拆分为更小、更易管理的部分，从而提高代码的可读性和可维护性。

## 使用引入参数对象（Introduce Parameter Object）

“引入参数对象”是一种重构技术，用于当某个函数拥有大量参数，或者多个函数共享相同参数时。在这种技术中，你将相关的参数组合成一个单独的对象，并将该对象传递给函数，而不是逐个传递参数。

函数中存在大量参数可能会让人感到困惑且难以管理。将相关参数组合成一个对象，可以提高代码的可读性，使人更容易理解该函数的作用。同时，它也能让函数调用变得更简洁、更清晰。此外，如果同一组参数在多个函数调用中被重复使用，这种技术还能减少因参数顺序错误而导致问题的可能性。

## 使用分解条件语句（Decompose Conditional）

“分解条件语句”是一种重构技术，其核心思想是将条件语句（如 if-else 或 switch）中的逻辑提取到独立的函数中。这种技术有助于提升代码的可读性，使代码更易于理解。

在该技术中，条件判断部分、if 分支以及 else 分支（如果存在的话）都会被分别提取为独立的函数。这些函数会根据它们所执行的操作或所检查的内容来命名。这种重构方式非常有益，因为它用命名良好的函数替代了可能需要注释才能理解的代码，从而使代码本身就能自我解释。

## 使用移动函数（Move Function）

“移动函数”是一种重构方法，其核心在于将某个函数从一个位置迁移到更合适或更恰当的地方。这个位置可以是在同一个类内、不同的类中，甚至可以迁移到一个独立的模块中。该方法的目标是通过确保函数被放置在逻辑上最合适的位置，从而提升代码的可读性、可维护性以及整体结构。

当类的职责随着时间推移而发生变化时，这种重构就变得很有必要。你可能会发现某个函数放在另一个类中更有意义，或者某个类中有一组功能相关的函数，它们更适合被放在一个独立的类或模块中。

通过“移动函数”重构，可以将函数迁移到其功能最为相关或需要的地方，从而降低类的复杂度。这有助于实现**高内聚**原则，即将相关的代码集中在一起；同时也有助于实现**低耦合**，通过减少代码不同部分之间不必要的依赖关系，使系统更加灵活和易于维护。

## 总结  

本章重点介绍了多种对维护和改善代码库结构、可读性与可维护性至关重要的代码重构技术。

所介绍的重构技术包括：  **重命名变量（Rename Variable）**：通过使用更具描述性的变量名，提高代码清晰度；  **提取变量（Extract Variable）**：通过将复杂表达式拆分为更小、更易管理的部分，简化代码；  **用管道替代循环（Replace Loop with Pipeline）**：将传统的 for/while 循环转换为更简洁、声明式的高阶函数，如 map、filter 和 reduce。

此外，  **提取函数（Extract Function）**：通过将大函数拆分为多个小函数，每个函数具有单一、明确的职责，提升代码的模块化与可复用性；  **引入参数对象（Introduce Parameter Object）**：将相关参数组合成一个对象，从而降低函数签名的复杂度；  **分解条件语句（Decompose Conditional）**：将复杂的条件逻辑拆分为多个独立函数，增强可读性；  **移动函数（Move Function）**：将函数放置在代码库中最合理、逻辑上最合适的位置，促进高内聚与低耦合。

在应用所有这些技术的过程中，我们强调了保持系统整体行为不变的重要性，并依靠测试来确保重构后功能的一致性。正确应用这些方法，可以打造出更易理解、更易维护、更健壮的代码库。

在下一章中，我们将探讨一种提升代码质量的卓越方法——即测试驱动开发（Test-Driven Development）。

# 8  探索 React 中的数据管理

在现代前端开发中，我们处理状态和数据访问的方式，往往决定着一个应用的成败。无论你是独立开发者，还是大型团队中的一员，理解最佳实践和常见陷阱都至关重要。本章旨在提升你在 React 应用中对状态管理和数据处理的能力，重点关注可扩展且易于维护的方法。

状态管理本身就具有挑战性，尤其是在 React 中，开发者在日常工作中常常会遇到许多问题。其中一个挑战就是业务逻辑在代码库中的位置。当业务逻辑渗透到 UI 组件中时，就会损害这些组件的可复用性。许多领域对象以及计算逻辑，无论是有意还是无意，都被分散在 UI 组件中，这会导致逻辑纠缠不清，难以跟踪、调试和测试。它还可能引发性能问题，进而影响用户体验。

另一个问题是属性钻取（prop drilling），即从父组件向深层嵌套的子组件传递属性，这种方式既繁琐又容易出错。这通常会导致代码重复，因为相同的代码片段出现在多个文件中，使得未来的更新变得复杂。

最后，在 React 应用中共享状态也面临一系列挑战。虽然存在多种实现机制，但选择最高效的方式来跨组件共享有状态逻辑却相当令人困惑。我们将深入探讨状态共享的问题，并了解 React 的 Context API 如何提供帮助。

## 理解业务逻辑泄漏

业务逻辑指的是对业务应用程序的运行至关重要的规则、计算过程和业务流程。当这些业务逻辑“泄漏”到不属于它的组件或应用区域中时，就被称为业务逻辑泄漏。

这个问题在各种项目中经常出现，部分原因是在 React 中处理业务逻辑并没有一个被广泛认可的标准方法。该框架的灵活性允许你直接在组件、Hooks 或辅助函数中实现这些逻辑；因此，开发者往往会将逻辑直接嵌入到组件中——也就是逻辑被“立即需要”的地方——从而导致泄漏。

这种泄漏会引发诸多问题。业务逻辑泄漏可能导致组件之间高度耦合，使其难以进行测试、维护或复用。当业务逻辑散布在应用的不同部分时，会导致代码重复和不一致，使应用更容易出错，也更难调试。此外，这种分散性还会让未来对业务规则的修改变得更加复杂，因为修改很可能需要在多个地方进行，从而增加了引入新问题的风险。

有多种迹象可以表明业务逻辑正在泄漏到你的代码中，但最常见的表现是将数据转换直接嵌入到视图或 UI 组件中。在本节中，我们将深入探讨这一问题；在下一节中，我们将探索缓解这一问题的解决方案。

数据转换是一种函数，它接收一种形式（或格式）的数据（通常来自其他模块或远程服务），并将这些数据映射为适合另一种用途的形式。以下是一个典型的例子，你会在许多 React 应用中看到，展示了一个 UserProfile 函数：



后端服务可以采用多种不同技术所支持的数据格式来返回数据 —— 有些使用 RESTful API，有些则采用 GraphQL。从前端代码的角度来看，这些格式的具体细节是被抽象掉的。例如，某个组件可能负责将 XML 数据（以橙色菱形表示）转换为内部类型 X（以蓝色方块表示）。与此同时，另一个组件可能与 GraphQL 接口交互，将接收到的数据（以红色圆圈表示）处理成同样的内部类型 X。

这种差异导致数据转换需要在代码的多个地方进行。当这些转换被重复实现时，就更容易忽略某些变更，特别是在后端更改了其数据结构的情况下。

所有这些不同的转换都可以集中到一个统一的位置，在那里进行数据的重塑，同时还可以进行空字段检查、字段重命名以及移除不必要的字段等操作。这就自然引出了我们接下来的话题：防腐层（Anti-Corruption Layer，简称 ACL）。

## 引入防腐层（ACL）

在软件开发中，防腐层（ACL）就像是一个翻译者或中介，连接着可能“语言不通”的不同子系统。想象一下，你有两个系统，每个系统都有自己的一套规则、结构和复杂性。如果这两个系统直接交互，就有可能以意想不到的方式相互影响，从而导致所谓的领域逻辑污染（corruption）。

在前端开发中，尤其是在复杂的应用程序里，防腐层对于管理前端与各个后端或 API 之间的交互至关重要。前端开发者经常需要与多个服务打交道，而这些服务可能具有不一致或复杂的数据格式。在前端实现防腐层，可以让你创建一个统一的接口来与这些服务进行交互。

例如，如果你的前端应用需要与多个 RESTful API、GraphQL 服务，甚至 WebSocket 服务器进行通信，那么每一个服务都可能有自己的一套规则、数据结构和复杂性。前端防腐层（ACL）的作用就是将这些不同形式的数据，转换成你的前端应用能够理解的格式。这意味着你的 UI 组件无需关心每个服务数据格式的复杂细节，从而使组件更易于开发、测试和维护。

防腐层也可以作为一个策略性的地方，用来处理缓存、错误转换以及其他横切关注点（cross-cutting concerns）。通过将这些功能集中起来，你可以避免将相似的逻辑分散在整个前端代码库中，从而遵循“不要重复自己”（Don't Repeat Yourself，简称 DRY）原则。

<img src="React Anti-Patterns.assets/image-20250919145652635.png" alt="image-20250919145652635" style="zoom:50%;" />

图 8.2：引入用于数据转换的 ACL

如图 8.2 所示，所有的数据转换现在都被集中到了一个地方，从而消除了在视图中进行这类操作的需求。你可能会好奇如何在代码中实际实现这一点。

### 引入一个典型用法

首先，让我们基于上一节的示例，构建一个基础函数作为我们 ACL 的起点。我们需要先识别外部数据格式以及我们实际使用的数据格式，然后定义相应的转换函数，最后将它们放到一个公共的位置。



UserProfile 组件依赖于 fetchUserData 辅助函数来从 API 获取并处理用户数据。这种设计使得 UserProfile 完全不需要了解远程数据的结构。如果未来 RemoteUser 类型发生变化，UserProfile 也不会受到影响，因为所有调整都将局限在 transformer.ts 文件中。

为远程数据专门设立一个函数，并将其塑造成符合上层视图需求的形式，这样做是有好处的。然而，当后端未能返回所需数据时，问题就出现了。在这种情况下，就需要在这一层添加额外的逻辑，以设置回退值或默认值。

### 使用回退值或默认值

另一个与数据转换相关的常见问题是在 React 视图中过度使用防御性编程。虽然防御性编程通常是一种良好的实践，在多种场景下都很有用，但在 React 组件中过多地使用空值检查和回退逻辑会使代码变得臃肿且难以理解。

> 注意  
> 防御性编程是一种编写代码的实践方式，其目的是提前预判可能出现的错误、故障或异常情况，并对其进行妥善处理。通过最小化意外情况带来的影响，该做法旨在提高应用程序的健壮性与可维护性。

这类逻辑可以更好地通过将其移入一个如 transformUser 这样的函数中进行管理，从而实现更全面的测试：

```typescript
export const transformUser = (remoteUser: RemoteUser): User => {
  return {
    id: remoteUser.user_identification ?? 'N/A',
    name: remoteUser.user_full_name ?? 'Unknown User',
    isPremium: remoteUser.is_premium_user ?? false,
    subscription: (remoteUser.subscription_details?.level ?? 'Basic') as UserSubscription,
    expire: remoteUser.subscription_details?.expiry ?? 'Never',
  };
};
```

transformUser 函数将来自远程用户数据结构中的字段映射到应用期望的用户数据结构中，并为每个字段提供默认值，以防这些字段缺失或为 null。

例如，如果 remoteUser.user_identification 为 null，它将使用 'N/A' 作为默认 ID。

需要注意的是，这里我们使用了可选链操作符（?.），它允许你在不逐级检查嵌套的情况下访问深层属性。如果 subscription_details 或 level 为 null 或 undefined，那么最终得到的 subscription 值也会是 undefined，而不会抛出错误。

我们还使用了空值合并运算符（??）来实现回退逻辑 —— 如果左侧的值不为 null 或 undefined，则取左侧的值；否则，取右侧的值。

现在，所有的转换和回退逻辑都被封装在一个统一的地方 —— ACL（应用控制层）。如果后续远程或本地数据结构发生变化，都可以轻松地在这一层进行调整，而无需在整个代码库中查找各种不同的使用点。

非常好 —— ACL 模式有效地将业务逻辑与视图隔离开来。然而，在 React 应用中管理数据时还存在其他挑战，比如在组件之间共享数据以及避免 prop drilling（属性层层传递）。在下一节中，我们将探讨如何使用 Context API 来解决这些问题。

## 探索 prop drilling 问题

**Prop drilling（属性层层传递）** 是指当你需要将数据从父组件一路传递给深层嵌套的子组件，但中间那些并不需要这些数据的组件也不得不接收并继续向下传递该数据的情况。这种情况常常会导致代码变得更难阅读、理解和维护。

幸运的是，Context API 为 prop drilling 问题提供了一个优雅的解决方案，我们将在下一节中探讨（我们在第 2 章中介绍了使用 Context API 的基础知识，如果你想复习相关内容，可以重新查阅那一章）。

## 使用 Context API 解决 prop drilling 问题

使用 Context API 来解决 prop drilling 问题的核心思想是：为某个公共父组件下的所有子组件创建一个共享的数据容器。这样就不需要显式地通过 props 从父组件一层一层地向下传递数据了。子组件可以在需要的时候直接访问这个共享的上下文（context）。使用 Context API 的另一个优势是：当上下文中的数据发生变化时，它会自动触发依赖该数据的组件的重新渲染。

code\src\ch8\searchable-list-props-drilling\SearchableListContext.tsx

```tsx
import { createContext } from "react";
import { Item } from "./types";

type SearchableListContextType = {
  onSearch: (keyword: string) => void;
  onItemClicked: (item: Item) => void;
};

const noop = () => {};

const SearchableListContext = createContext<SearchableListContextType>({
  onSearch: noop,
  onItemClicked: noop,
});

export { SearchableListContext };
```



如上所示，使用 Context API 能带来更清晰的结构。它允许你在对子组件进行结构调整时，无需再担心需要不断通过层级向下传递 props。这简化了组件的接口，使其更易于阅读和理解。

## 总结

在本章中，我们深入探讨了 React 开发中常见的一些棘手问题，例如业务逻辑泄露、prop drilling 带来的复杂性以及共享状态管理的困难。为了应对这些问题，我们引入了一些强有力的解决方案，比如 ACL（访问控制层）和 Context API。这些策略旨在优化你的代码结构，使其更具可维护性，也更适用于长期项目。

接下来，我们将深入研究一些常见的 React 设计模式，帮助你进一步提升编码技能。敬请期待！

# 9 在 React 中应用设计原则

在一个典型的 React 项目中，组件之间常常会共享状态和行为，彼此嵌套，并在整个应用的不同部分被复用。如果不遵循设计原则，你可能会陷入一个错综复杂的依赖网络中，导致代码难以修改甚至难以理解。例如，忽视单一职责原则（Single Responsibility Principle，简称 SRP）可能会导致组件难以测试和重构；而忽略接口隔离原则（Interface Segregation Principle，简称 ISP）则可能让你的组件复用性降低，与特定使用场景耦合得更紧。

此外，随着 React 的不断发展，诸如 Hooks 和并发模式等新特性的出现，采用以设计原则为中心的开发方式可以确保你在面对这些变化时无需进行大规模重写。这使得你可以专注于构建功能、修复问题并交付价值，而不是被技术债务所困扰。

在 React 开发中遵循设计原则不仅是一种最佳实践，更是一种必要手段。它能主动应对复杂性问题，让你的 React 代码更易于阅读、测试和维护。

在本章中，我们将首先回顾单一职责原则（SRP），这是一个常作为编写整洁、可维护代码基础的核心概念。我们将从一个简单的字符串转换函数开始，逐步探索这一原则如何扩展到渲染属性（render props）等更复杂的场景中，从而提升你 React 组件的结构清晰度与可读性。

从那里出发，我们进一步引入**依赖倒置原则（Dependency Inversion Principle，简称 DIP）**，这是一种具有变革性的组件设计方法。本节重点强调：**关注接口而非实现细节，是实现组件可复用性和易理解性的关键路径**。

在章节结尾，我们将深入探讨**命令查询职责分离（Command and Query Responsibility Segregation，简称 CQRS）**——这一模式在 React 应用规模和复杂度增加时显得尤为重要。通过对 CQRS 的讨论，你将了解到如何将应用程序中的“命令”和“查询”职责进行分离，从而使系统更加易于管理和扩展。

本章旨在为你提供对关键设计原则的全面理解，从而为后续深入学习与掌握 React 打下坚实的基础。

在本章中，我们将涵盖以下主题：

- 重温单一职责原则（Single Responsibility Principle）  
- 拥抱依赖倒置原则（Dependency Inversion Principle）  
- 理解 React 中的命令查询职责分离（Command and Query Responsibility Segregation）

## 重温单一职责原则（Single Responsibility Principle）

在第四章中，我们曾在设计 React 组件的背景下探讨过单一职责原则（SRP）。然而，这一原则具有更广泛的适用性，它是许多其他编程准则的基石。为了更直观地理解这一理念，让我们通过一些实际示例来深入探讨。

**识别组件的核心职责是遵循 SRP 的关键。**一旦你明确了该组件最根本的用途，就能更容易地对其进行重构，并将辅助功能抽离出来。SRP 是一个高层次的指导原则，当它直接应用于代码层面时尤其具有优势。实现这一原则的方法有很多，但**关键在于识别何时应该应用它，尤其是在复杂度逐渐上升时**。

我们最常使用的两种技术是渲染属性（Render Props）和组合（Composition）。渲染属性是 React 中一种通过在组件之间传递一个值为函数的 prop 来共享代码的技术。一个使用渲染属性的组件接收一个返回 React 元素的函数，并调用该函数，而不是自己实现渲染逻辑。另一方面，React 中的组合是一种开发模式，你将组件构建为小型、可复用的部分，然后将它们组合在一起，以创建更复杂的用户界面。

在接下来的部分中，我们将通过两个具体的示例，分别展示如何使用 **渲染属性（Render Props）** 和 **组合（Composition）** 在实践中贯彻这一原则（即单一职责原则）。

## 探索渲染属性模式

> 注意  
> 在许多编程语言（包括 JavaScript）中，**高阶函数（higher-order function）** 是指**接收另一个函数作为参数、返回一个函数，或者两者兼而有之的函数**。这些函数是函数式编程的基础，能帮助你编写模块化且可复用的代码。  高阶函数常用于数组操作（如 `map`、`filter` 和 `reduce`）、函数组合、柯里化（currying）以及事件处理等场景。它们能够简化代码结构、提高可维护性，并支持更高级的编程技巧。

在 React 中，这个高阶函数并不一定要命名为 render。我们同样可以轻松地使用 children 属性来实现更直观的设计，如下所示：

```tsx
const Title = ({
  title,
  children,
}: {
  title: string;
  children: (s: string) => React.ReactNode;
}) => <div>{children(title)}</div>;
```

这样，我们就可以像调用普通函数一样来调用 children：

```tsx
<Title title="This is a title">
  {(s: string) => {
    const formatted = s.toUpperCase();
    return <h3>{formatted}</h3>;
  }}
</Title>
```

在这个例子中，**Title 组件接收一个 title 属性和一个子函数（后者通常被称为渲染属性，即 render prop）**。这个子函数接收一个字符串 s，将其转换为大写形式，并在一个 `<h3>` 标签中渲染它。**Title 组件会将传入的 title 属性作为参数，调用这个子函数，从而实现自定义的渲染逻辑。**

在 React 中，**渲染属性（render prop）模式** 指的是将一个函数作为 prop 传递给组件，该函数返回 JSX，而这个 JSX 将作为组件输出的一部分被渲染出来。这种模式通过让父组件控制子组件部分渲染逻辑，使得组件更加灵活和可复用。它特别适用于在多个组件之间共享行为。

需要注意的是，这里体现了一个核心设计思想：**抽象（abstraction）**。一开始，我们可能认为 `<h2>` 或 `<h3>` 是具体的标题标签，但当我们从更高的层面来看时，就会意识到它们其实属于一个更广泛的抽象概念：**一个 React 组件，或者更准确地说，是一个 ReactNode（React 节点）**。

这一认识让我们理解了使用渲染属性或把 children 当作高阶函数的价值所在。它们不仅仅是功能特性，更代表了我们所达到的抽象层次。现在，我们不再局限于某个特定的 HTML 标签（比如 `<h3>`），而是可以传入任意 JSX 元素作为参数，从标题到完全样式化的组件都可以。

通过我们新创建的使用渲染属性的通用组件，我们实际上构建了一个可复用的框架。其美妙之处在于，我们只需要编写一次这种通用代码即可。

**渲染属性和组合（composition）正是实现这一目标的绝佳技术。它们允许你在不修改组件核心逻辑的前提下，扩展或定制组件的行为。这使得组件保持简洁、模块化且易于测试，因为每个组件都只做一件事，并把它做好。**我们已经通过 `Title` 组件的演进了解了渲染属性的工作方式，接下来，让我们来看看 **组合（composition）** 的应用。

## 使用组合来实现单一职责原则（SRP）

组合（Composition）是我们在这本书中多次提到的一个术语，其核心思想就是 **单一职责原则（Single Responsibility Principle，简称 SRP）**。如果系统的每一部分都能很好地完成自己的职责，那么它们就可以被组合在一起协同工作。让我们来看一个具体的例子。

## 拥抱依赖倒置原则（Dependency Inversion Principle）

DIP 是构成 **SOLID** 原则之一的五个设计原则之一，SOLID 是一套旨在帮助开发者创建更具可维护性、灵活性和可扩展性的软件的指导方针。具体来说，**DIP 鼓励开发者依赖于抽象，而不是具体的实现。**

依赖倒置原则（DIP）解决了开发者在构建和维护大型系统时面临的几个挑战。其中一个问题就是由模块间紧密耦合所带来的僵化性。当高层模块依赖于低层模块时，即使对底层代码进行很小的改动，也可能产生广泛的影响，从而需要对整个系统进行修改。

### 理解依赖倒置原则（DIP）的工作原理

## 理解 React 中的命令查询职责分离（CQRS）

命令查询职责分离（Command and Query Responsibility Segregation，简称 CQRS，也称为命令与查询分离原则）是一种软件设计原则，它建议方法或函数要么是用于修改系统状态的命令（commands），要么是用于返回系统状态信息的查询（queries），但不应同时兼具两者。

命令（或称修改器）是指执行某个操作或改变对象状态但**不返回值**的方法；而查询则是用于读取对象状态但**不进行任何更改**的方法。将命令与查询分离有助于减少组件之间的耦合，从而使测试、维护和修改代码变得更加容易。它也有助于更清晰地理解代码的行为，并能提升系统的整体设计质量。

尽管这种模式通常在大规模场景下使用，比如在设计系统架构时，但它同样适用于代码层面。我将在一个 **ShoppingCart（购物车）组件** 中演示这一原则。



我们将使用 React 的 **Context API** 和 **useReducer Hook** 来为 **ShoppingApplication 组件** 实现命令查询职责分离（CQRS）。现在让我们一起来看一下它们是如何工作的。

### 介绍 useReducer  

### 在上下文中（context）使用 reducer 函数

因此，CQRS 是一种设计模式，它将系统的修改（写）和查询（读）功能分离开来，从而提升系统的可扩展性、可维护性和简洁性。我们通过实现一个购物车功能来演示这一原则——修改购物车状态的命令（例如添加或移除商品）与查询（例如获取商品列表和计算总价）被分离开来；这种分离通过使用 React 的 Context API 和自定义 Hook 得到了清晰的体现，每个职责都被有效地隔离。这不仅提高了代码的可读性，也使得未来对应用的管理和扩展更加容易。

## 总结

在本章中，我们深入探讨了三个关键的设计原则：  **单一职责原则（SRP）**，用于构建专注且易于理解的组件；  **依赖倒置原则（DIP）**，用于编写模块化且可测试的代码；  **命令查询职责分离（CQRS）**，用于明确区分命令与查询，增强可维护性。  这些原则为构建可扩展、高质量的软件提供了坚实的基础。

在下一章中，我们将更深入地研究组合原则，以进一步完善我们对 React 应用程序设计的思路。

# 10  深入探究组合模式

## 通过高阶组件理解组合模式

组合可能是软件设计中最重要的技术之一，与其他许多基本设计原则一样，它适用于多个不同的层面。在本节中，我们将回顾如何利用高阶函数及其在 React 世界中的变体——高阶组件（Higher-Order Components，简称 HOC）——来实现组合。

### 回顾高阶函数

我们在第 9 章中讨论过高阶函数的一些示例，但这是一个非常重要的概念，我想在这里再稍作回顾。高阶函数（Higher-Order Function，简称 HOF）是指这样一种函数：它要么接受另一个函数作为参数，要么返回一个函数，或者两者兼具。能够接受一个函数作为参数这一特性具有很多优势，尤其是在涉及组合时。

### 介绍高阶组件（HOC）

高阶组件本质上是一个函数，它接收一个组件并返回该组件的一个增强版本。高阶组件背后的原理非常简单——它们允许你向现有组件注入额外的功能。当您希望在多个组件之间复用某些行为时，这种模式尤其有益。

让我们深入看一个例子：

```tsx
import React from "react";

export const checkAuthorization = () => {
  //checking local storage or send request to remote
  return false;
};

const Login = () => <div>Login</div>;

const withAuthorization = (Component: React.FC): React.FC => {
  return (props: any) => {
    const isAuthorized = checkAuthorization();
    return isAuthorized ? <Component {...props} /> : <Login />;
  };
};

export default withAuthorization;
```

在这个代码片段中，我们定义了一个函数 checkAuthorization 来处理授权检查。然后，我们创建了一个高阶组件 withAuthorization。这个高阶组件接收一个组件（Component）作为参数，并返回一个新的函数。这个返回的函数在被渲染时，会根据用户是否已授权来决定渲染原始组件（如果用户已授权），还是渲染一个 Login 组件（如果用户未授权）。

现在，假设我们有一个需要保护的 ProfileComponent，我们可以使用 withAuthorization 来创建一个经过保护的新版本 ProfileComponent：

```tsx
const Profile = withAuthorization(ProfileComponent);
```

这意味着，每当渲染 **Profile** 组件时，它都会首先检查用户是否已获得授权。  如果用户已授权，则渲染 **ProfileComponent**；否则，将用户重定向到 **Login** 组件。

现在我们已经了解了如何通过 **withAuthorization** 利用高阶组件来控制访问权限，接下来我们把注意力转向如何增强用户交互体验。我们将深入探讨一个 **ExpandablePanel** 组件，展示高阶组件如何管理交互式 UI 元素以及状态转换。

### 实现一个 ExpandablePanel 组件



如果您有面向对象编程的背景，那么这个概念可能会让您产生共鸣，因为它与装饰器设计模式相契合。如果您不太熟悉，装饰器模式是通过将对象包装在额外的对象中来动态地为其添加行为，而不是修改其结构。  这种方式比继承更加灵活，因为它可以在不修改原始对象的情况下扩展功能。

虽然高阶组件（HOCs）在类组件和函数组件中仍然在多种场景下具有优势，但 React Hooks 提供了一种更轻量级的方式来实现组件组合。接下来，让我们来了解一下 Hooks。

## 探索 React Hooks

Hooks 提供了一种从组件中提取有状态逻辑的方法，使得该逻辑能够独立进行测试和复用。它们为实现有状态逻辑的复用铺平了道路，而无需改变组件的层级结构。  本质上，Hooks 让你能够从函数组件中“钩入”React 的状态及其他生命周期特性。



Hooks 体现了一组简洁的可复用逻辑包，它们与组件本身隔离，但又能轻松集成。  与高阶组件（HOCs）的包裹方式不同，Hooks 提供了一种插件机制，使其更加轻量，并且能被 React 很好地管理。  Hooks 的这一特性不仅促进了代码的模块化，还为我们提供了一种更简洁、更直观的方式来为组件增添额外功能。

不过需要注意的是，Hooks 的灵活性远超表面所见。它们不仅适用于管理 UI 相关的状态，还能有效处理 UI 副作用，例如数据获取和全局事件处理（比如页面级别的键盘快捷键）。  我们之前已经看到了如何使用 Hooks 处理键盘事件，那么接下来，让我们一起探索 Hooks 如何简化网络请求的处理。

### 揭示远程数据获取

在前面的章节中，我们利用 `useEffect` 来实现数据获取，这是一种常见的方式。  当从远程服务器获取数据时，通常需要引入三种不同的状态 —— 加载中（loading）、错误（error）和数据（data）。

### 为了优雅与可复用性而重构

将数据获取逻辑直接嵌入到组件中虽然可行，但这并不是最优雅或最具可复用性的做法。让我们通过将数据获取逻辑提取到一个单独的函数中来对其进行重构：

## 开发一个下拉列表组件

200

## 介绍无头组件模式  

无头组件模式为我们提供了一种强有力的方式，将 JSX 代码与底层逻辑清晰地分离。虽然使用 JSX 编写声明式 UI 是自然而然的，但真正的挑战在于管理状态。这时无头组件就派上用场了，它承担了所有复杂的状态管理任务，引领我们迈向一个更高层次的抽象新境界。

本质上，无头组件是一个函数或对象，它封装了逻辑，但本身并不渲染任何内容。它将渲染部分交给使用者，从而在如何渲染 UI 方面提供了极大的灵活性。当我们需要重用复杂逻辑，并且这些逻辑需要在不同的视觉表现中使用时，这种模式会极其有用。



总结无头组件模式时，值得一提的是，尽管它可以通过高阶组件（HOC）或渲染属性（render props）来实现，但以 React Hook 的形式实现更为常见。在无头组件模式中，所有可共享的逻辑都被封装起来，从而可以无缝切换到其他 UI，而无需对有状态逻辑进行任何修改。

### 无头组件模式的优点与缺点  

无头组件模式的优点包括：  
• **可复用性：** 无头组件模式中封装的逻辑可以在多个组件间复用，这有助于在代码库中贯彻“不要重复自己”（DRY）原则。  
• **关注点分离：** 通过将逻辑与渲染解耦，无头组件促进了清晰的关注点分离，这是可维护代码的基石。  
• **灵活性：** 它们允许采用不同的 UI 实现方式，同时共享相同的核心逻辑，从而更容易适应不同的设计需求或框架。  

无头组件模式的缺点包括：  
• **学习曲线：** 对于不熟悉该模式的开发者来说，该模式可能会带来一定的学习成本，初期可能影响开发效率。  
• **过度抽象：** 如果没有谨慎管理，无头组件所创建的抽象可能会导致一定程度的间接性，使代码更难理解。

### 相关库及进一步学习资源  

无头组件模式已被多个库采纳，用于更方便地构建具备可访问性、可定制性和可复用性的组件。以下是一些值得关注的库及其简要说明：  

• **React Aria：** 由 Adobe 推出的库，提供用于构建包容性 React 应用的可访问性基础组件和 Hooks。它包含一系列用于管理键盘交互、焦点管理和 ARIA 标注的 Hooks，使得创建可访问的 UI 组件更加容易。  

• **[Headless UI：](https://headlessui.com/)** 一个完全无样式、完全可访问的 UI 组件库，旨在与 Tailwind CSS 完美集成。它提供行为和可访问性基础，让你可以在此基础上构建自己的样式化组件。  

• **React Table：** 一个用于构建快速且可扩展表格和数据网格的无头工具库。它提供一个灵活的 Hook，让你可以轻松创建复杂的表格，而 UI 表现则由你自己决定。  

• **Downshift：** 一个极简主义的库，帮助你创建可访问且可定制的下拉菜单、组合框等控件。它处理所有逻辑，而将渲染部分交由你来定义。  

这些库都体现了无头组件模式的精髓，通过封装复杂逻辑和行为，使得创建高度交互且可访问的 UI 组件变得简单直接。  虽然本文提供的示例可以作为学习的一个起点，但在实际项目中，合理利用这些经过生产验证的库，将有助于构建健壮、可访问且可定制的组件。  

该模式不仅教会我们如何管理复杂逻辑和状态，还鼓励我们去探索那些已经精炼了无头组件方法的、适用于真实场景的生产级库，从而获得更强大、更可访问、更灵活的组件解决方案。

## 本章小结

在本章中，我们深入探讨了 React 中的高阶组件（HOC）与 Hooks，研究了它们在增强组件逻辑的同时保持代码整洁、可读的实用性。通过创建可展开面板和下拉列表的实例，我们展示了高阶组件的组合能力以及 Hooks 提供的有状态逻辑封装。随后，我们转向一个更复杂的下拉列表示例，引入了异步数据获取，演示了 Hooks 如何简化数据加载场景中的状态管理。

接着，我们进入了无头组件（Headless Component）这一强大模式的世界。该模式将逻辑与 JSX 代码分离，为管理状态提供了稳健的框架，同时将 UI 呈现部分交由开发者掌控。通过具体示例，我们展示了这种分离如何有助于创建可复用、可访问且可定制的组件。我们还结合 React Table、Downshift、React Aria 和 Headless UI 等知名库，进一步丰富了讨论，这些库都体现了无头组件模式的精髓，为构建交互性强、可访问的 UI 组件提供了开箱即用的解决方案。

在下一章中，我们将实现本章所讨论的各种模式，并深入探讨提升模块化的架构策略。同时，我们也将应对大型应用所带来的挑战。

# 第 11 章：React 中的分层架构介绍

随着 React 应用的规模和复杂度不断增长，高效管理代码成为一项挑战。功能的线性增长往往会导致复杂度的指数级上升，使得代码库难以理解、测试和维护。这时，分层架构（Layered Architecture）作为一种设计方法应运而生——它不仅适用于后端系统，在客户端应用中同样具有显著优势。

以分层方式组织 React 应用能够解决多个关键问题：

- **关注点分离（Separation of Concerns）：** 不同层级负责不同职责，使得代码库更易于导航和理解。
- **可复用性（Reusability）：** 业务逻辑和数据模型能够在应用的不同部分之间轻松复用。
- **可测试性（Testability）：** 分层架构让编写单元测试和集成测试变得更加简单，从而构建出更健壮的应用。
- **可维护性（Maintainability）：** 随着应用规模扩大，遵循分层结构能让功能迭代和代码变更变得更加轻松。

在本章中，我们将探讨分层架构在 React 应用中的实践，深入研究如何提取应用关注点层级、定义清晰的数据模型，以及如何运用策略模式。通过一个逐步推进的示例，我们将了解如何实际应用这些概念，以及为什么它们对于大型应用而言不可或缺。

本章将涵盖以下主题：

- 理解 React 应用的演进过程  
- 增强 Code Oven 应用  
- 实现 ShoppingCart 组件  
- 深入探究分层架构  

## 理解 React 应用的演进过程

不同规模的应用需要采用不同的开发策略。对于小型项目或一次性项目，你可能会发现所有的业务逻辑都直接写在 React 组件内部。这类项目通常只包含一两个组件，代码看起来很像普通的 HTML，仅使用了一些变量或状态来让页面“动态”起来。整体上，代码简单易懂，也便于修改。

然而，随着应用的不断成长，越来越多的代码被添加到代码库中，如果没有合理的组织方式，代码库很快就会进入一种难以维护的状态。这意味着，即使只是添加一个小功能，也会因为开发者需要花费更多时间去阅读和理解现有代码而变得耗时费力。

在本节中，我将介绍几种不同的 React 应用结构方式，以确保我们的代码始终保持健康状态，让新功能的添加变得轻而易举，同时也让已有缺陷的扩展和修复更加方便。我们将从一个简单的结构开始，逐步演进，以应对规模扩大带来的挑战。接下来，让我们快速回顾一下构建可扩展前端应用的关键步骤。

### 单组件应用

单一组件承担了多种任务，包括从远程服务器获取数据、管理其内部状态、处理领域逻辑以及进行渲染。这种方式可能适用于只有一个表单的小型应用，或者适合那些希望了解如何将自己的应用从其他框架迁移到 React 的开发者。

然而，你很快会意识到，将所有内容整合到一个组件中会使代码难以理解和维护。所有逻辑都集中在一个组件中很快就会变得难以应对，尤其是在处理诸如遍历项目列表以创建各个组件之类的逻辑时。这种复杂性凸显了将单一组件拆分为更小、职责更明确的组件的必要性。

### 多组件应用

最好让每个部分拥有清晰的职责。然而，随着应用的扩展，职责不再局限于视图层，还扩展到了诸如发送网络请求、为视图重塑数据以便消费，以及收集数据回传给服务器等任务。此外，可能还会有一些在数据获取后对其进行转换的逻辑。将这些计算逻辑放在视图层中并不合适，因为它们与用户界面并没有直接关系。而且，有些组件可能会因过多的内部状态而变得混乱不堪。

### 使用 Hooks 进行状态管理  

将这些逻辑拆分到不同的地方是更好的做法。幸运的是，在 React 中，你可以定义自己的 Hooks。这是一种很好的方式，可以在状态发生变化时共享这些状态和相关逻辑。

### 提取业务模型  

于是，你开始意识到，将这些逻辑抽取到另一个地方可以带来诸多好处。例如，通过这样的拆分，逻辑可以更加内聚，并且不依赖于任何视图层。接下来，你提取出了一些领域对象（domain objects）。  

这些简单的对象能够处理数据映射（比如在不同格式之间转换）、检查空值，并根据需要使用默认值。随着这类领域对象的数量逐渐增多，你会发现可能需要借助继承或多态来使代码结构更加清晰。于是，你将许多在其他地方发现很有用的设计模式，也应用到了前端应用中。

### 分层的前端应用  

随着应用的不断演进，某些模式开始显现出来。你会注意到有一组对象并不属于任何用户界面，而且它们对底层数据的来源（无论是来自远程服务、本地存储还是缓存）毫不在意。因此，你希望将它们划分到不同的层次中。我们需要为应用的这些不同部分引入一种更合理的组织方式。

## 增强 Code Oven 应用程序

### 通过自定义 Hook 重构 MenuList

### 转向基于类的模型  

如第8章所述，采用防腐层（Anti-Corruption Layer，ACL）模式是有效管理数据的战略举措。我们将使用TypeScript中的类，将数据和逻辑封装在统一位置（称为模型）。朝此方向的重要一步是将MenuItem类型定义转换为类，从而将该类的所有映射逻辑集中处理。这种设置将成为未来数据结构变更及相关逻辑的专用中心。

***基于类模型的优势***

从简单类型转向类模型能带来一系列长期收益，这些优势将显著提升应用的可维护性与扩展性：

• 封装性：类将相关属性和方法集中在一个逻辑单元中，既促进代码结构的清晰组织，又通过限制直接数据访问来增强控制力与数据完整性。
• 方法行为：针对菜单项的复杂操作（无论是数据加工还是业务逻辑），类提供了结构化平台来定义这些方法，使相关行为具备明确的归属。
• 继承与多态：当菜单项存在层级关系或需要多态行为时，类结构不可或缺——它支持不同菜单类型继承公共基类，并按需重写或扩展行为。
• 统一接口：类为数据交互提供一致的访问入口，这对多个应用模块协同操作菜单项的场景至关重要。
• 只读属性：类允许定义只读属性以控制数据变更，既是保障数据完整性的关键手段，也是处理不可变数据结构的基础能力。

当前，在通过购物车功能扩展应用时，我们必须运用数据建模过程中积累的经验。这种经验驱动的开发方式，将确保新功能的实现既结构化又高效，最终为用户打造流畅的在线订购体验。

## 实现 ShoppingCart 组件

