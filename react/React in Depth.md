# React in Depth

源码：https://github.com/React-in-Depth/react-in-depth

```sh
git clone https://github.com/React-in-Depth/react-in-depth.git  

npm install

npm run dev -w chXX/YYY
```

P16

# 第2章 高级组件模式

- Provider  

- Composite  

- Summary  

## 2.1 The Provider pattern  

P26

## 2.2 The Composite pattern  

38

## 2.3 The Summary pattern  

### 2.3.4 总结模式有多有用？

总结来说，总结模式因其能够简化和组织 React 组件的能力而脱颖而出。在通过单个或多个自定义 Hook 探索其应用后，我们看到这种模式在提升代码清晰度和可维护性方面起到了关键作用。

总结模式的优势在于其多功能性和可扩展性。无论是通过单个 Hook 简化组件，还是在更复杂的场景中协调多个 Hook，它都提供了管理组件逻辑的定制化方法。这种模式不仅能清理代码，还能培养可重用的思维方式，使其在需要保持一致性的大型项目中非常宝贵。

本质上，虽然总结模式可能并不引人注目，但它在创建高效且易于管理的 React 应用程序中所做的贡献是不可否认的。它体现了这样一个原则：有效的解决方案通常蕴含于简洁和深思熟虑的组织中。

## 总结

- 有效的软件开发反映了建筑的核心原则，强调稳定性、结构性以及适当模式的使用。
- React 中的 Provider 模式集中并简化了数据管理，使其在复杂应用程序的全局状态控制中不可或缺。
- 通过使用 Provider 模式，React 开发人员可以高效地在组件层次结构中传递数据和函数，增强了组织性和功能性。
- React 中的组合模式（Composite pattern）提供了一种管理复杂 UI 结构的策略性方法，能够实现模块化和灵活的组件架构。
- 采用组合模式可以实现动态且复杂的 UI 设计，促进组件的重用性和结构完整性，提升 React 项目的可维护性。
- React 中的总结模式（Summary pattern）旨在通过将逻辑抽象到自定义 Hook 中来减少代码杂乱，从而产生更简洁、更易维护的组件。
- 实施总结模式可以增强 React 组件的可读性和可扩展性，有助于提高开发效率并促进团队协作的编码实践。
- 在 React 开发中，遵循如 Provider、Composite 和 Summary 等基础设计模式，确保了稳健且创新应用的创建。
- 掌握这些 React 设计模式为开发人员提供了构建多样且稳定的数字结构的工具，类似于物理建筑中的构造。

# 第3章 优化 React 性能

## 3.1 理解 React 渲染

要优化 React 渲染，我们首先需要理解它。一个函数组件会由于以下三种原因之一进行渲染：

- 组件刚刚被挂载。（它之前不在组件树中，现在加入了组件树。）
- 父组件刚刚重新渲染。
- 组件使用了某个 Hook，该 Hook 触发了此组件的重新渲染。

就是这样。如果以上三种情况都没有发生，你的组件将不会重新渲染，这是可以保证的。如果其中任何一种情况发生，组件一定会重新渲染。不过，React 可能会在多个事件发生后进行批量渲染。例如，如果一个状态值发生了变化并且父组件重新渲染，组件可能会重新渲染一次，也可能会渲染两次。这个过程由 React 控制，取决于一些微妙的时间细节。

你现在应该对这些内容有了比较好的理解，基于你对 React 的基础知识，所以我不会详细展开讨论。但我会讨论一些与此相关的误解。特别是，我将介绍以下两个常见的误区：

- **误区一**：React 会在属性改变时重新渲染组件。技术上来说，这个说法不准确，而这个技术细节非常重要。
- **误区二**：在 React 18 的严格模式（Strict Mode）中，React 会两次挂载每个组件。实际上情况稍有不同。

让我们讨论这两个误区，因为它们非常重要。

### 3.1.1 改变属性是无关紧要的

在 React 开发圈中有一个常见的误解，认为组件会因为属性（props）的变化而重新渲染，但实际上并非如此。我们可以通过两种方式来证明这一点：

- 我们可以创建一个属性发生变化但不会重新渲染的组件。
- 我们也可以创建一个多次使用相同属性渲染却每次都重新渲染的组件。

这两种情况都很容易想象。首先，我们需要一个能够清楚显示它是否重新渲染的组件。接下来，我们可以创建一个这样的组件，如以下代码所示。

## 3.2 通过最小化重新渲染来优化性能

**什么是记忆化**

**记忆化（Memoization）**是一种优化技术，它通过记住纯函数的上一次输入和输出来避免重复计算。如果下一次调用该函数时，输入与上次相同，记忆化会直接返回之前计算的结果，而不需要再次执行函数。

记忆化的关键是它仅适用于**纯函数**，即返回值完全取决于其输入，而不依赖任何外部信息或随机性。

虽然记忆化可以被看作是一种缓存，但与传统缓存不同，缓存通常存储多种输入和输出的对应关系，而记忆化通常只记住**最近一次**函数调用的输入和输出，随后比较下一次调用的输入是否相同，若相同则复用上次的结果。

在 React 中，有一个 `memo()` 函数可以用于记忆化组件，但它不适用于非组件的函数。如果你想记忆化常规函数（不仅限于 React 组件），可以使用像 `memoizee` 这样的包。例如：

```javascript
import memoize from 'memoizee';

const rawAddition = (a, b) => a + b;
const addition = memoize(rawAddition);
```

在这个例子中，如果多次调用未记忆化的函数 `rawAddition()`，即使传入相同的值，每次都会重新进行计算。但如果调用记忆化的 `addition()` 函数，并传入相同的值，则计算只会在第一次执行，随后相同的输入会直接返回缓存的结果，而不再进行重复计算。这可以大大提高性能，尤其是在处理计算密集型操作时。

### 3.2.1 Memoize a component  

66