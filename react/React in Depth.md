# React in Depth

源码：https://github.com/React-in-Depth/react-in-depth

```sh
git clone https://github.com/React-in-Depth/react-in-depth.git  

npm install

npm run dev -w chXX/YYY
```

P16

# 第2章 高级组件模式

- Provider  

- Composite  

- Summary  

## 2.1 The Provider pattern  

P26

## 2.2 The Composite pattern  

38

## 2.3 The Summary pattern  

### 2.3.4 总结模式有多有用？

总结来说，总结模式因其能够简化和组织 React 组件的能力而脱颖而出。在通过单个或多个自定义 Hook 探索其应用后，我们看到这种模式在提升代码清晰度和可维护性方面起到了关键作用。

总结模式的优势在于其多功能性和可扩展性。无论是通过单个 Hook 简化组件，还是在更复杂的场景中协调多个 Hook，它都提供了管理组件逻辑的定制化方法。这种模式不仅能清理代码，还能培养可重用的思维方式，使其在需要保持一致性的大型项目中非常宝贵。

本质上，虽然总结模式可能并不引人注目，但它在创建高效且易于管理的 React 应用程序中所做的贡献是不可否认的。它体现了这样一个原则：有效的解决方案通常蕴含于简洁和深思熟虑的组织中。

## 总结

- 有效的软件开发反映了建筑的核心原则，强调稳定性、结构性以及适当模式的使用。
- React 中的 Provider 模式集中并简化了数据管理，使其在复杂应用程序的全局状态控制中不可或缺。
- 通过使用 Provider 模式，React 开发人员可以高效地在组件层次结构中传递数据和函数，增强了组织性和功能性。
- React 中的组合模式（Composite pattern）提供了一种管理复杂 UI 结构的策略性方法，能够实现模块化和灵活的组件架构。
- 采用组合模式可以实现动态且复杂的 UI 设计，促进组件的重用性和结构完整性，提升 React 项目的可维护性。
- React 中的总结模式（Summary pattern）旨在通过将逻辑抽象到自定义 Hook 中来减少代码杂乱，从而产生更简洁、更易维护的组件。
- 实施总结模式可以增强 React 组件的可读性和可扩展性，有助于提高开发效率并促进团队协作的编码实践。
- 在 React 开发中，遵循如 Provider、Composite 和 Summary 等基础设计模式，确保了稳健且创新应用的创建。
- 掌握这些 React 设计模式为开发人员提供了构建多样且稳定的数字结构的工具，类似于物理建筑中的构造。

# 第3章 优化 React 性能

## 3.1 理解 React 渲染

要优化 React 渲染，我们首先需要理解它。一个函数组件会由于以下三种原因之一进行渲染：

- 组件刚刚被挂载。（它之前不在组件树中，现在加入了组件树。）
- 父组件刚刚重新渲染。
- 组件使用了某个 Hook，该 Hook 触发了此组件的重新渲染。

就是这样。如果以上三种情况都没有发生，你的组件将不会重新渲染，这是可以保证的。如果其中任何一种情况发生，组件一定会重新渲染。不过，React 可能会在多个事件发生后进行批量渲染。例如，如果一个状态值发生了变化并且父组件重新渲染，组件可能会重新渲染一次，也可能会渲染两次。这个过程由 React 控制，取决于一些微妙的时间细节。

你现在应该对这些内容有了比较好的理解，基于你对 React 的基础知识，所以我不会详细展开讨论。但我会讨论一些与此相关的误解。特别是，我将介绍以下两个常见的误区：

- **误区一**：React 会在属性改变时重新渲染组件。技术上来说，这个说法不准确，而这个技术细节非常重要。
- **误区二**：在 React 18 的严格模式（Strict Mode）中，React 会两次挂载每个组件。实际上情况稍有不同。

让我们讨论这两个误区，因为它们非常重要。

### 3.1.1 改变属性是无关紧要的

在 React 开发圈中有一个常见的误解，认为组件会因为属性（props）的变化而重新渲染，但实际上并非如此。我们可以通过两种方式来证明这一点：

- 我们可以创建一个属性发生变化但不会重新渲染的组件。
- 我们也可以创建一个多次使用相同属性渲染却每次都重新渲染的组件。

这两种情况都很容易想象。首先，我们需要一个能够清楚显示它是否重新渲染的组件。接下来，我们可以创建一个这样的组件，如以下代码所示。

## 3.2 通过最小化重新渲染来优化性能

**什么是记忆化**

**记忆化（Memoization）**是一种优化技术，它通过记住纯函数的上一次输入和输出来避免重复计算。如果下一次调用该函数时，输入与上次相同，记忆化会直接返回之前计算的结果，而不需要再次执行函数。

记忆化的关键是它仅适用于**纯函数**，即返回值完全取决于其输入，而不依赖任何外部信息或随机性。

虽然记忆化可以被看作是一种缓存，但与传统缓存不同，缓存通常存储多种输入和输出的对应关系，而记忆化通常只记住**最近一次**函数调用的输入和输出，随后比较下一次调用的输入是否相同，若相同则复用上次的结果。

在 React 中，有一个 `memo()` 函数可以用于记忆化组件，但它不适用于非组件的函数。如果你想记忆化常规函数（不仅限于 React 组件），可以使用像 `memoizee` 这样的包。例如：

```javascript
import memoize from 'memoizee';

const rawAddition = (a, b) => a + b;
const addition = memoize(rawAddition);
```

在这个例子中，如果多次调用未记忆化的函数 `rawAddition()`，即使传入相同的值，每次都会重新进行计算。但如果调用记忆化的 `addition()` 函数，并传入相同的值，则计算只会在第一次执行，随后相同的输入会直接返回缓存的结果，而不再进行重复计算。这可以大大提高性能，尤其是在处理计算密集型操作时。

### 3.2.1 Memoize a component  

### 3.2.3 Memoize properties to memoized components  

```jsx
<Items
  items={items}
  onDelete={(item) => setItems((ls) => ls.filter((i) => i !== item))}
/>
```

由于这个函数是在 JavaScript 中内联定义的，因此每次渲染都会创建一个新函数。你可能会认为每次渲染时它是同一个函数，因为每个函数的定义都相同，但这并不是 JavaScript 的工作方式。在使用记忆化时，每次渲染都传递新的属性是不可行的。为了让记忆化生效，我们的值必须在引用上是相同的。因此，需要将这个回调函数进行记忆化。使用专门为此目的设计的 `useCallback` 钩子是更好的选择。请参见以下代码示例。

```jsx
// Todo component
const onDelete = useCallback(
    (item) => setItems((list) => list.filter((i) => i !== item)),
    []
  );

<Items items={items} onDelete={onDelete} />

// Items component
const Items = memo(function Items({ items, onDelete }) {
  return (
    <>
      <h2>Todo items</h2>
      <ul>
        {items.map((todo) => (
          <li key={todo}>
            {todo}
            <button onClick={() => onDelete(todo)}>X</button>
          </li>
        ))}
      </ul>
    </>
  );
});
```



通常，当你开始对组件进行记忆化时，就会发现对属性进行记忆化也是必要的。属性记忆化主要针对内联创建的对象和数组，尤其是对函数更为重要，这也是 `useCallback` 钩子存在的主要原因以及在 React 中频繁使用的原因。

记忆化并不是等到项目末期、发现应用程序有些缓慢时才进行的工作。记忆化是在开发过程中就应该执行的，以确保平稳、优化的用户体验。使用本节中介绍的工具，你应该能够将这个示例应用于自己的项目中。

同时，过早优化也会带来问题。如果你优化了那些运行良好的部分，最终可能适得其反。调用优化函数本身会带来轻微的运行时开销，如果这些优化无法加速应用，反而会使其变慢。

如果你是新手开发者，不要过早优化。但如果你清楚自己在做什么，当你预测到优化会有所影响时，可以进行记忆化。

### 3.2.4 Memoization hooks in detail  

在本节中，我将详细介绍两个记忆化钩子的使用场景和最佳实践。简单来说，你可以使用 `useMemo` 来记忆化任何值，使用 `useCallback` 来特别记忆化函数。但什么时候应该进行记忆化？如何确保在必要时值能够正确更新？

**使用 `useMemo` 记忆化任何值**

这个钩子在渲染之间记忆化值，主要用于两个目的（也可以同时用于这两个目的）：

- 防止代价高昂的重新计算
- 保持引用相等

`useMemo` 接收一个函数和一个依赖项数组。如果自上次渲染以来依赖项数组中的任何值发生了变化，该函数就会执行，且函数的返回值将作为 `useMemo` 的返回值。如果自上次渲染以来依赖项数组中的值没有发生变化，那么 `useMemo` 会返回上一次渲染时的值（见图 3.4）。

**MEMOIZE FUNCTIONS WITH USECALLBACK**  

## 3.3 Understanding dependency arrays  

如果你指定了一个非空数组，钩子会在渲染时检测数组中任何一个值的变化。任何单个值的变化都会触发该钩子。React 使用**引用相等性**来判断值是否发生了变化。

>>**引用相等性**
>>
>>在 JavaScript（以及许多其他语言）中，值分为两类：**基本类型**和**复杂对象**。JavaScript 有七种基本类型（`number`、`bigint`、`Boolean`、`string`、`symbol`、`null` 和 `undefined`）以及一种复杂类型（`object`）。也许你会想，类、正则表达式、数组和函数呢？这些也被认为是对象（尽管在某种意义上类和函数可以视为函数，而函数是对象的一个子类型）。
>>
>>你可以使用三等号运算符 `===` 来比较值是否严格相等。普通的双等号运算符 `==` 会进行类型转换，因此 `"1" == 1` 为 `true`，而严格相等要求类型也相同。
>>
>>在比较两个基本类型的值时，如果它们代表相同的数据，即使是不同变量，它们也会被认为是严格相等的。例如，`2 === 1+1` 是 `true`。
>>
>>但对于复杂类型来说，严格相等表示**引用相等**。只有当对象是同一个对象时，才会被认为是相同的，更新其中一个也会同时更新另一个。因此，`{} !== {}` 和 `[] !== []`，即使我们分别比较的是两个空对象和空数组。它们不被认为是严格相等的，因为它们不是同一个对象（或数组），只是相似的数据结构。
>>
>>当我们说 React 使用**引用相等性**时，我们的意思是 React 会使用严格相等运算符（`===`）来比较值。因此，只有当对象或数组是指向同一个对象的引用时，React 才会认为它们是相同的，而不仅仅是包含相似数据的两个不同值。

### 3.3.1什么是依赖项？

钩子的依赖项是钩子中使用的所有变量和引用的一个子集。依赖项指的是任何在组件作用域内本地存在的变量，而不是组件作用域外也存在的变量。图 3.6 显示了一些示例。

依赖项包括在组件中定义的任何变量（如 `const`、`let` 或 `var`）、在组件内部定义的任何函数，以及传递给组件的任何参数（主要是属性，但也可能是转发的引用）。任何在组件外部定义或从其他文件导入的函数或变量对于钩子来说都不是相关的依赖项。最后，在钩子内部定义的任何变量也不是依赖项，因为它们不在外部组件中存在。

### 3.3.2 Run on every render by skipping the dependency array  

假设你希望你的效果在每次渲染时都执行，而不管组件重新渲染的原因是什么。也许你想跟踪所有的渲染以用于追踪或统计目的。你可以添加一个依赖项数组，列出所有存在的属性和状态值，这样在这些值中的任何一个发生变化时，效果都会被执行。

但是请记住，组件之所以重新渲染，也可能是因为其父组件重新渲染，而这种父组件触发的渲染可能没有任何属性或状态值的变化。因此，无论你在依赖项数组中放入多少个值，你的效果都不会在每一个可能的渲染中执行。

有一个简单的解决方案：跳过依赖项数组。根本不提供任何依赖项数组，这样你的效果将会在每次渲染时执行，无论渲染发生的原因是什么：

```javascript
function Component({ ... }) {
  useEffect(() => track('Component rendered'));
  ...
}
```

请注意，我们只向 `useEffect` 函数提供了一个参数。我们只是忽略了传递第二个参数。

你可能会问，为什么要在钩子中运行效果？为什么不直接像下面这样在内联中运行代码？

```javascript
function Component({ ... }) {
  track('Component rendered');
  ...
}
```

在效果钩子中执行跟踪函数是出于优化考虑。前面的 `track` 函数可能会稍慢，这个函数调用的响应性不应该阻塞组件的渲染。因此，通过在效果中运行这个函数，你将效果的执行与组件的渲染解耦。

**MEMOIZATION WITHOUT DEPENDENCIES IS MEANINGLESS**  

**NO DEPENDENCY ARRAY IS DIFFERENT FROM AN EMPTY ARRAY**  

### 3.3.3 Skip stable variables from dependencies  

85