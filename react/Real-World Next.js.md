# Real-World Next.js

[什么是Headless CMS?](https://www.jianshu.com/p/e1d25b62e5c1)

[headless cms,无头CMS？](https://cloud.tencent.com/developer/article/1837496)

# 1 Next.js 简介

Next.js 是一个用于 React 的开源 JavaScript Web 框架，它提供了一组丰富的开箱即用功能，例如服务器端渲染、静态站点生成和增量静态再生。

## 介绍 Next.js

​		只有一个问题：默认情况下，React 在客户端运行（意味着它在 Web 浏览器上运行），因此完全使用该库编写的 Web 应用程序可能会对搜索引擎优化 (SEO) 和初始加载性能产生负面影响，因为 在屏幕上正确渲染需要一些时间。 实际上，要显示完整的 Web 应用程序，浏览器必须下载整个应用程序包，解析其内容，然后执行它并在浏览器中渲染结果，这可能需要几秒钟（对于非常大的应用程序）。

​		许多公司和开发人员开始研究如何在服务器上预渲染应用程序，让浏览器将渲染的 React 应用程序显示为纯 HTML，使其在 JavaScript 包传输到客户端后立即进行交互。

​		然后，Vercel 提出了 Next.js，结果证明它改变了游戏规则。

- 静态站点生成
- 增量静态生成
- 原生 TypeScript 支持
- 自动 polyfills  
- 图像优化
- 支持国际化
- 性能分析

​		使用Next.js的案例：https://nextjs.org/showcase

## 将 Next.js 与其他替代方案进行比较

### Gatsby  

非常擅长为静态生成的页面提供服务

### Razzle  

### Nuxt.js  

如果您有使用 Vue 的经验，那么 Nuxt.js 可以成为 Next.js 的有效竞争对手。

### Angular Universal  

## 从 React 迁移到 Next.js

​		在单个 Next.js 应用程序中，您可以指定哪些页面应在服务器端渲染，哪些应在构建时静态生成，而无需编写任何配置文件或类似的东西。 你只需要从你的页面导出一个特定的函数，然后让 Next.js 发挥它的魔力（我们将在第 2 章，探索不同的渲染策略中看到）。

​		React 和 Next.js 之间最显着的区别在于，虽然 React 只是一个 JavaScript 库，但 Next.js 是一个框架，用于在客户端和服务器端构建丰富而完整的用户体验，并添加了大量非常有用的功能。每个服务器端渲染或静态生成的页面都将在 Node.js 上运行，因此您将无法访问某些特定于浏览器的全局对象，例如 `fetch`、`window` 和 `document`，以及一些 HTML 元素，例如 `canvas`。 在编写 Next.js 页面时，您始终需要牢记这一点，即使框架提供了自己的方式来处理必须使用此类全局变量和 HTML 元素的组件，正如我们将在第 2 章中看到的那样 ，探索不同的渲染策略。

​		另一方面，有时您可能想要使用 Node.js 特定的库或 API，例如 fs 或 child_process，而 Next.js 允许您通过在每个请求或构建时运行服务器端代码来使用它们 将数据发送到客户端之前的时间（取决于您选择渲染页面的方式）。

​		但是即使你想创建一个客户端渲染的应用程序，Next.js 也可以成为众所周知的 create-react-app 的一个很好的替代品。 事实上，Next.js 可以用作编写渐进式和离线优先的 Web 应用程序的框架，利用其令人难以置信的内置组件和优化。 所以让我们开始使用 Next.js。

## Next.js 入门

# 2、探索不同的渲染策略

​		但是 Next.js 将这些概念提升到了一个全新的水平，让您决定哪些页面应该在构建时渲染，哪些页面应该在运行时动态提供，为每个请求重新生成整个页面，使您的应用程序的某些部分非常动态。该框架还允许您决定哪些组件应该专门在客户端渲染，从而使您的开发体验非常令人满意。

在本章中，我们将仔细研究：

- 如何使用服务器端渲染为每个请求动态渲染页面
- 仅在客户端渲染某些组件的不同方式
- 在构建时生成静态页面
- 如何在生产环境中使用增量静态重新生成静态页面

## Server-side rendering (SSR)  

尽管服务器端渲染 (SSR) 在开发人员的词汇中听起来像是一个新术语，但它实际上是提供网页服务的最常见方式。 如果您想到 PHP、Ruby 或 Python 等语言，它们都会在将 HTML 发送到浏览器之前在服务器上渲染 HTML，一旦加载了所有 JavaScript 内容，就会使标记动态化。

谈到采用特定渲染策略的优势，SSR 提供了比标准 React CSR 更多的好处：

- 更安全的网络应用程序：

- 更兼容的网站：

- 增强的搜索引擎优化：

​		当你想在服务器端渲染你的页面时要记住的另一件事是你给每个请求增加了一些延迟。 您的页面可能需要调用一些外部 API 或数据源，并且他们会在每次页面渲染时调用它。 在服务器端渲染的页面之间导航总是比在客户端渲染或静态提供的页面之间导航要慢一些。

​		正如本节开头所见，SSR 提供了一些显着的优势，但也有一些警告。 如果你想使用依赖于浏览器特定 API 的任何组件，你需要在浏览器上显式渲染它，因为默认情况下，Next.js 在服务器上渲染整个页面内容，它不会暴露某些 API，例如`window`  或`document`  。 因此，CSR 的概念就出现了。

## Client-side rendering (CSR)  

客户端渲染的主要优点是：



### 使用 React.useEffect hook  

### 使用 process.browser 变量

### 使用动态组件加载

###  

​		CSR 可以成为 SSR 的绝佳替代品，用于构建非常动态的网页。 如果您正在处理不需要被搜索引擎索引的页面，那么首先加载应用程序的 JavaScript，然后从客户端从服务器获取任何必要的数据可能是有意义的； 这将减轻服务器端的工作量，因为这种方法不涉及 SSR，并且您的应用程序可以更好地扩展。

## 静态站点生成

到目前为止，我们已经看到了两种不同的方式来渲染我们的 Web 应用程序：客户端和服务器端。 Next.js 为我们提供了第三个选项，称为**static site generation   (SSG)**。

Next.js 将在构建阶段渲染这些页面，并始终提供特定的 HTML，就像 SSR 一样，由于 React 水合过程，这些 HTML 将变得可交互。

与 CSR 和 SSR 相比，SSG 带来了很多优势：

- 易于扩展：

- 性能出色：

- 更安全的请求

SSG 可能是构建高性能和高度可扩展的前端应用程序的最佳解决方案之一。 这种渲染技术最大的 concern 是，一旦页面构建完成，内容将保持不变，直到下一次部署。

Next.js 提供了一种独特的方法来解决这个问题：增量静态再生 (incremental static regeneration , ISR)。 多亏了 ISR，我们可以在页面级别指定 Next.js 在重新渲染更新其内容的静态页面之前应该等待多长时间。

例如，假设我们要构建一个显示一些动态内容的页面，但由于某种原因，数据获取阶段需要很长时间才能成功。 这会导致性能不佳，给我们的用户带来糟糕的用户体验。 SSG 和 ISR 的组合将通过在 SSR 和 SSG 之间采用混合方法来解决这个问题。

假设我们已经构建了一个非常复杂的仪表板，可以处理大量数据……但是对这些数据的 REST API 请求最多需要几秒钟才能成功。 在这种情况下，我们很幸运，因为在这段时间内数据不会发生太大变化，因此我们可以使用 SSG 和 ISR 将其缓存长达 10 分钟（600 秒）：

`getStaticProps`  在构建时被 Next.js 用于获取数据和渲染页面，并且在下一次构建之前不会再次调用它。如前所述，虽然这可能非常强大，但它是有代价的：如果我们想更新页面内容，我们必须重建整个网站。

为了避免整个网站重建，Next.js 最近引入了一个名为 `revalidate` 的选项，可以在我们的 `getStaticProps` 函数的返回对象中设置它。 它指示一旦新请求到达，我们应该在多少秒后重建页面。

*请记住，ISR 进程是惰性的，因此如果 10 分钟后没有请求发生，Next.js 将不会重建其页面。*

如果您想知道，目前无法通过 API 强制 ISR 重新验证； 部署您的网站后，您必须等待重新验证选项中设置的到期时间长度才能重建页面。

静态站点生成是创建快速和安全网页的好方法，但有时我们可能希望拥有更多动态内容。 多亏了 Next.js，我们总能决定哪个页面应该在构建时（SSG）或请求时（SSR）渲染。 我们可以通过使用 SSG + ISR 来充分利用这两种方法，使我们的页面成为 SSR 和 SSG 之间的“混合体”，这是现代 Web 开发的游戏规则改变者。

# 3、Next.js 基础和内置组件

## 路由系统

### 在我们的页面中使用路由变量

### 在组件中使用路由变量