## Fluent React 

## Build Fast, Performant, and Intuitive Web Applications

## 第一章 入门知识

作为补充，我们提到了防抖 (debouncing) 和节流 (throttling) 这两个概念。为了清楚起见，**防抖会延迟函数的执行，直到距离上一次事件触发经过设定时间之后才执行**（例如，等待用户停止输入后再处理输入内容）。**节流则限制函数每隔设定时间间隔最多只运行一次**，确保其不会过于频繁地执行（例如，以设定的间隔处理滚动事件）。这两种技术通过控制函数的执行速率来优化性能。

## 进入React

### 声明式与命令式代码

React提供了对DOM的声明式抽象。我们稍后会在书中更详细地讨论它是如何做到这一点的，但基本上它为我们提供了一种编写代码的方式，表达我们想要看到的内容，同时又负责处理代码如何执行，确保我们的用户界面以安全、可预测和高效的方式创建并运行。

让我们考虑一下我们之前创建的列表应用程序。在React中，我们可以像这样重写它：

注意在返回语句中，我们实际上写的是看起来像HTML的东西：它看起来就像我们想要看到的内容。我想看到一个带有NewItemForm的框和一个列表。咔嚓。如何实现这一点？这是由React来解决的。我们是批处理列表项以一次性添加它们的一部分吗？我们是逐个添加它们，一个接一个吗？React处理了这是如何完成的，而我们仅仅描述了我们想要做的事情。在后续章节中，我们将深入探讨React，并详细探索它在编写时是如何做到这一点的。

那么我们是否依赖于类名来引用HTML元素？我们是否在JavaScript中使用getElementById？不是的。React在幕后为我们创建了唯一的“React元素”，它用于检测更改并进行增量更新，因此我们不需要从用户代码中读取类名和其他标识符，我们无法保证其存在：我们的真相来源仅仅是JavaScript与React。

我们将我们的 MyList 组件导出给 React，React 将其显示在屏幕上，以一种安全、可预测和高效的方式——无需多问。组件的任务只是返回一个描述这个 UI 部分应该是什么样子的描述。它通过使用虚拟 DOM（vDOM）来实现这一点，虚拟 DOM 是对预期 UI 结构的轻量级描述。然后，React 在更新发生后将虚拟 DOM 与更新之前的虚拟 DOM 进行比较，并将其转换为对真实 DOM 的小型、高效的更新，使其与虚拟 DOM 匹配。这就是 React 如何能够更新 DOM。

### 虚拟 DOM

虚拟 DOM 是一个编程概念，它代表了真实 DOM，但作为一个 JavaScript 对象。如果这对现在来说有点太复杂了，不用担心：第三章专门介绍了这个概念，并以更详细的方式进行了解释。目前，重要的是要知道虚拟 DOM 允许开发人员更新 UI 而不直接操作实际的 DOM。React 使用虚拟 DOM 来跟踪组件的更改，并仅在必要时重新渲染组件。这种方法比每次有更改时更新整个 DOM 树更快、更高效。

在 React 中，虚拟 DOM 是实际 DOM 树的轻量级表示。它是一个普通的 JavaScript 对象，描述了 UI 元素的结构和属性。React 创建和更新虚拟 DOM 以匹配实际 DOM 树，对虚拟 DOM 进行的任何更改都将使用一种称为协调的过程应用到实际 DOM 上。

第四章专门介绍了这个概念，但在我们当前的上下文讨论中，让我们简要总结一下，并举几个例子。为了理解虚拟 DOM 的工作原理，让我们回顾一下我们的点赞按钮的例子。我们将创建一个 React 组件，显示一个点赞按钮和点赞的数量。当用户点击按钮时，点赞的数量应该增加一。

下面是我们组件的代码：

```jsx
import React, { useState } from "react";
function LikeButton() {
  const [likes, setLikes] = useState(0);
  function handleLike() {
    setLikes(likes + 1);
  }
  return (
    <div>
      <button onClick={handleLike}>Like</button>
      <p>{likes} Likes</p>
    </div>
  );
}
export default LikeButton;

```

在这段代码中，我们使用了 useState 钩子来创建一个状态变量 likes，它保存着点赞的数量。回顾一下我们可能已经了解的关于 React 的知识，钩子是一种特殊的函数，允许我们在函数组件内部使用 React 的功能，比如状态和生命周期方法。钩子使我们能够重用有状态逻辑而不改变组件层次结构，使得从组件中提取和共享钩子变得容易，甚至可以将其作为独立的开源包与社区共享。

我们还定义了一个名为 handleLike 的函数，当按钮被点击时，它会将 likes 的值增加一。最后，我们使用 JSX 渲染了点赞按钮和点赞数量。

现在，让我们更详细地看一下在这个示例中虚拟 DOM 是如何工作的。当 LikeButton 组件首次被渲染时，React 创建了一个虚拟 DOM 树，它镜像了实际 DOM 树。虚拟 DOM 包含一个包含一个按钮元素和一个 p 元素的 div 元素：

```js
{
  $$typeof: Symbol.for('react.element'),
  type: 'div',
  props: { },
  children: [
    {
      $$typeof: Symbol.for('react.element'),
      type: 'button',
      props: { onClick: handleLike },
      children: ['Like']
    },
    {
      $$typeof: Symbol.for('react.element'),
      type: 'p',
      props: {},
      children: [0, ' Likes']
    }
  ]
}
```

p 元素的 children 属性包含 Likes 状态变量的值，初始设置为零。
当用户点击点赞按钮时，会调用 handleLike 函数，该函数会更新 likes 状态变量。React 然后创建一个反映更新状态的新虚拟 DOM 树：

```js
{
  type: 'div',
    props: { },
  children: [
    {
      type: 'button',
      props: { onClick: handleLike },
      children: ['Like']
    },
    {
      type: 'p',
      props: {},
      children: [1, ' Likes']
    }
  ]
}
```

请注意，虚拟 DOM 树包含与之前相同的元素，但是 p 元素的 children 属性已经更新，以反映 likes 的新值，从 0 变为 1。接下来是 React 中称为协调的过程，其中新的虚拟 DOM 与旧的虚拟 DOM 进行比较。让我们简要讨论一下这个过程。

在计算出新的虚拟 DOM 树之后，React 执行一种称为协调的过程，以了解新树与旧树之间的差异。协调是将旧的虚拟 DOM 树与新的虚拟 DOM 树进行比较，并确定实际 DOM 的哪些部分需要更新的过程。如果您对这个过程的具体实现方式感兴趣，第四章会对此进行详细的讨论。现在，让我们考虑我们的点赞按钮。

在我们的示例中，React 将旧的虚拟 DOM 树与新的虚拟 DOM 树进行比较，并发现 p 元素已经发生了变化：具体来说，它的属性或状态或两者都已经改变。这使得 React 能够将组件标记为“脏”或“应该更新”。然后，React 计算出一组最小有效的更新操作，以便在实际 DOM 上与新虚拟 DOM 的状态进行协调，并最终更新实际 DOM，以反映对虚拟 DOM 所做的更改。

React 仅更新实际 DOM 中必要的部分，以尽量减少 DOM 操作的次数。这种方法比每次更改时更新整个 DOM 树要快得多，更高效。

虚拟 DOM 对于现代网络来说是一个强大且有影响力的发明，较新的库如 Preact 和 Inferno 在 React 中证明有效后也采用了它。我们将在第四章中更详细地介绍虚拟 DOM，但现在让我们继续下一节。

### 组件模型

- React 强烈鼓励“以组件思维思考”：即将您的应用程序拆分为较小的部分，并将它们添加到一个较大的树中以组合您的应用程序。组件模型是 React 中的一个关键概念，也是使 React 如此强大的原因。让我们谈谈为什么：它鼓励在每个地方重复使用相同的内容，这样如果出现问题，您只需在一个地方修复它，问题就会得到解决。这被称为 DRY（不要重复自己）开发，是软件工程中的一个关键概念。例如，如果我们有一个 Button 组件，我们可以在应用程序的许多地方使用它，如果我们需要更改按钮的样式，我们可以在一个地方进行更改，所有地方都会相应更改。

- 如果能够反复识别特定组件并跟踪特定组件的更新，React 就更容易跟踪组件并在幕后执行性能优化，如记忆化、批处理和其他优化。这称为键。例如，如果我们有一个 Button 组件，我们可以为其提供一个 key 属性，React 将能够随着时间的推移跟踪 Button 组件并“知道”何时更新它，或者何时跳过更新它并继续对用户界面进行最小更改。大多数组件都有隐式键，但如果需要，我们也可以显式提供它们。

- 它帮助我们分离关注点，并将逻辑放置在逻辑影响的用户界面部分附近。例如，如果我们有一个 RegisterButton 组件，我们可以将当按钮被点击时发生的事件逻辑放置在与 RegisterButton 组件相同的文件中，而不是必须在不同的文件中跳来跳去查找按钮被点击时的逻辑。RegisterButton 组件将包装一个更简单的 Button 组件，并且 RegisterButton 组件将负责处理按钮被点击时的逻辑。这称为组合。

React 的组件模型是支撑该框架流行和成功的基本概念。这种开发方式具有许多优点，包括增强的模块化、更容易的调试和更高效的代码重用。

### 不可变状态

React 的设计理念强调了一种范式，其中我们应用程序的状态被描述为一组不可变的值。每次状态更新都被视为一个新的、独立的快照和内存引用。这种不可变的状态管理方式是 React 的价值主张的核心部分，对于开发健壮、高效和可预测的用户界面有几个优势。

通过强制不可变性，React 确保 UI 组件在任何给定时间点都反映了特定的状态。当状态发生变化时，而不是直接进行变异，您返回一个代表新状态的新对象。这使得跟踪变化、调试和理解应用程序的行为变得更容易。由于状态转换是离散的，彼此不干扰，因此由共享的可变状态引起的微妙错误的几率大大降低。

在接下来的章节中，我们将探讨 React 如何批处理状态更新并异步处理它们以优化性能。由于状态必须被视为不可变的，因此可以安全地聚合和应用这些“事务”，而不会出现一次更新破坏另一个更新的状态的风险。这导致了更可预测的状态管理，并且可以改善应用程序的性能，特别是在复杂的状态转换期间。

不可变状态的使用进一步强化了软件开发中的最佳实践。它鼓励开发人员在数据流方面采用函数式思维，减少副作用，并使代码更易于理解。不可变数据流的清晰性简化了理解应用程序如何工作的心智模型。

不可变性还可以实现强大的开发工具，例如使用 Replay.io 等工具进行时间旅行调试，开发人员可以向前和向后浏览应用程序状态变化，以检查任意时间点的 UI。只有将每个状态更新保留为唯一且未修改的快照，这才是可行的。

React 对不可变状态更新的承诺是一个经过深思熟虑的设计选择，带来了许多好处。它符合现代函数式编程原则，可以实现高效的 UI 更新，优化性能，降低错误的可能性，并改善整体开发人员体验。这种状态管理方式支撑了 React 的许多高级功能，并将继续是 React 发展的基石。

## 发布 React

单向数据流是对多年来构建 Web 应用程序的方式的一个激进转变，它受到了怀疑。事实上，Facebook 是一家拥有大量资源、大量用户和大量工程师观点的大公司，这使得它的上升之路非常陡峭。经过深入审查，React 在内部取得了成功。它被 Facebook 和 Instagram 采用。

然后在 2013 年开源，面向全世界发布，但遭到了巨大的反对。人们严厉批评 React 使用 JSX，指责 Facebook “将 HTML 放入 JavaScript” 并破坏了关注点的分离。Facebook 成为了一个“重新思考最佳实践”并破坏网络的公司。

最终，在 Netflix、Airbnb 和纽约时报等公司缓慢而稳定地采用之后，React 成为了在 Web 上构建用户界面的事实标准。

这个故事中有很多细节被省略了，因为它们超出了本书的范围，但在我们深入细节之前了解 React 的背景是很重要的，特别是 React 被创建来解决的技术问题的范围。如果你对 React 的故事更感兴趣，YouTube 上有一部完整的 React 历史纪录片，名为 Honeypot 制作的《React.js：纪录片》。

考虑到 Facebook 在巨大规模下面临的这些问题，React 开创了一种基于组件的方法来构建用户界面，可以解决这些问题和更多问题，其中每个组件都是可以重用和组合的代码的独立单元，用于构建更复杂的用户界面。React 发布一年后，Facebook 发布了 Flux：一种管理 React 应用程序中数据流的模式。Flux 是对管理大规模应用程序中数据流挑战的应对，它是 React 生态系统的重要组成部分。让我们来看一下 Flux 以及它如何与 React 结合。

## 总结：那么...为什么 React 如此受欢迎？

React 之所以如此受欢迎，是因为它使开发人员能够以更高的可预测性和可靠性构建用户界面，让我们以声明式的方式表达我们想要在屏幕上看到的内容，而 React 则通过以高效的方式对 DOM 进行增量更新来处理具体的实现。它还鼓励我们以组件为中心思考，这有助于我们分离关注点并更轻松地重用代码。它在 Meta 公司经过了大规模测试，并设计用于大规模应用。此外，它是开源的，并且可以免费使用。

React 还拥有庞大而活跃的生态系统，开发人员可以获得各种各样的工具、库和资源。这个生态系统包括用于测试、调试和优化 React 应用程序的工具，以及用于常见任务（如数据管理、路由和状态管理）的库。此外，React 社区非常活跃和支持，有许多在线资源、论坛和社区可供开发人员学习和成长。

React 是平台无关的，这意味着它可以用于构建广泛的平台上的 Web 应用程序，包括桌面、移动和虚拟现实。这种灵活性使得 React 成为开发人员的理想选择，因为它可以让他们使用单一的代码库构建跨多个设备运行的应用程序。

总之，React 的价值主张围绕着其基于组件的架构、声明式编程模型、虚拟 DOM、JSX、丰富的生态系统、平台无关的特性以及由 Meta 公司支持。这些特性使得 React 成为需要构建快速、可扩展和易于维护的 Web 应用程序的开发人员的理想选择。无论您是构建简单的网站还是复杂的企业应用程序，React 都可以帮助您以比许多其他技术更高效、更有效的方式实现您的目标。让我们进行回顾。

# 第2章 JSX  

## 底层实现

那个正则表达式甚至没有完全有效，因为完整版本无法放在一页上！这就是为什么不使用正则表达式，而是使用编译器来编译代码的原因。编译器是一种将用高级编程语言编写的源代码根据特定规则转换为语法树（字面上是一种树状数据结构，类似于 JavaScript 对象）的软件。编译代码的过程涉及几个步骤，包括词法分析、语法分析、语义分析、优化和代码生成。让我们更详细地探讨每个步骤，并讨论编译器在现代软件开发中的作用。

编译器使用一个三步骤的过程（至少在 JavaScript 中是这样）在这里发挥作用。这些步骤称为标记化（Tokenization）、解析（Parsing）和代码生成（Code Generation）。让我们更详细地看看每个步骤：

标记化：
基本上是将一串字符分解为有意义的标记。
当标记器具有状态，并且每个标记包含其父级和/或子级的状态时，标记器称为词法分析器（Lexer）。这是我们讨论的一个必要简化：词法分析实质上是有状态的标记化。
词法分析器具有词法规则，在某些情况下，确实使用正则表达式或类似的方法来检测文本字符串中代表编程语言的关键标记，如变量名、对象键和值等。然后，词法分析器将这些关键字映射到某种可枚举值，具体取决于其实现。例如，const 变成 0，let 变成 1，function 变成 2，等等。
一旦一个字符串被标记化或词法分析，我们就进入下一个步骤，解析。

解析（Parsing）
将标记（tokens）转换为语法树（syntax tree）的过程。
语法树是表示代码结构的数据结构。例如，我们之前看过的代码片段将被表示为一个语法树，类似于这样：

代码生成（Code generation）
这是编译器从抽象语法树（AST）生成机器代码的过程。这涉及将 AST 中的代码转换为一系列指令，这些指令可以直接由计算机的处理器执行。生成的机器代码然后由 JavaScript 引擎执行。总的来说，将 AST 转换为机器代码的过程是复杂的，并涉及许多不同的步骤。然而，现代编译器非常复杂，可以生成在各种硬件架构上高效运行的高度优化的代码。

为了高效执行 JavaScript 代码，许多现代环境，包括 Web 浏览器，在这些系统中利用了即时编译器（JIT 编译器）。在这些系统中，JavaScript 源代码可能首先被转换为中间表示形式，例如字节码。然后 JIT 编译器在程序运行时动态地将这些字节码编译为机器代码。这种即时编译允许引擎根据实时信息（例如变量类型和频繁执行的代码路径）进行优化。一些引擎采用多阶段编译，首先进行快速的、非优化的编译以快速开始执行，然后针对频繁执行的代码段进行更多的优化编译。这种动态方法使 JavaScript 引擎能够为各种应用程序实现令人印象深刻的性能。

运行时通常与引擎进行交互，为特定环境提供更多的上下文帮助器和特性。目前最流行的 JavaScript 运行时是常见的 Web 浏览器，如 Google Chrome：它提供了与引擎进行交互的 Chromium 运行时。同样，在服务器端，我们使用的是 Node.js 运行时，它仍然使用 v8 引擎。您还能在野外识别出哪些引擎和运行时呢？

运行时为 JavaScript 引擎提供了上下文，例如浏览器运行时提供的 window 对象和 document 对象。如果您之前同时使用过浏览器和 Node.js，您可能已经注意到 Node.js 没有全局的 window 对象。这是因为它是一个不同的运行时，并且因此提供了不同的上下文。Cloudflare 创建了一个类似的运行时，称为 Workers，其唯一责任是在全球分布的称为边缘服务器的计算机上执行 JavaScript，Bun 和 Deno 是更加另类的运行时，但我们在这里偏题了。这一切与 JSX 有何关系呢？

### 扩展 JavaScript 语法到 JSX

现在我们了解了如何扩展 JavaScript 语法，那么 JSX 是如何工作的呢？我们该如何做呢？要扩展 JavaScript 语法，我们需要使用一个可以理解我们新语法的不同引擎，或者在新语法到达引擎之前处理它。前者几乎不可能实现，因为引擎需要大量的思考来创建和维护，因为它们往往被广泛使用。如果我们决定选择这个选项，可能需要数年甚至数十年才能使用我们的扩展语法！然后，我们还需要确保我们的“定制特殊引擎”被广泛使用。我们如何说服浏览器厂商和其他利益相关者切换到我们不受欢迎的新东西呢？这是行不通的。
后者更快速：让我们探讨如何在新语法到达引擎之前处理我们的新语法。为了做到这一点，我们需要创建自己的词法分析器和解析器，它们可以理解我们扩展的语言：即，接受一串代码文本并理解它。然后，我们可以将这棵语法树转换成普通的传统 JavaScript，而不是生成机器代码，所有当前的引擎都可以理解。这正是 JavaScript 生态系统中 Babel 和其他工具（如 TypeScript、Traceur 和 swc）所做的事情。

# 第3章 虚拟 DOM

在本章中，我们将深入探讨虚拟 DOM（有时称为 vDOM）的概念及其在 React 中的重要性。我们还将探讨 React 如何利用虚拟 DOM 使 web 开发更加简单和高效。
随着 web 应用程序变得越来越复杂，管理“真实 DOM”变得越来越困难，这是一个复杂且容易出错的过程，我们很快就会看到，正如我们在第一章中粗略地讨论过的那样。React 的虚拟 DOM 为这个问题提供了解决方案。
在本章中，我们将探讨 React 虚拟 DOM 的工作原理，以及它相对于真实 DOM 的优势和实现方式。我们还将介绍 React 如何围绕真实 DOM 使用虚拟 DOM 优化性能，以及它们如何协同工作。
通过一系列的代码示例和详细的解释，我们将了解虚拟 DOM 在 React 中的作用，以及如何利用它的优势来创建健壮高效的 web 应用程序。让我们开始吧！

## 虚拟 DOM 介绍

虚拟 DOM（Virtual DOM）和 DOM 一样，是一个被建模为 JavaScript 对象的 HTML 文档：这实际上就是文档对象模型（DOM）的含义。DOM 本身是浏览器运行时对文档的模型。虚拟 DOM 是这个模型的一个轻量级副本，其主要区别在于，虽然真实 DOM 是由节点对象组成的，但虚拟 DOM 则是由充当描述的普通 JavaScript 对象组成的。正如我们在本章中将要发现的那样，它允许 web 开发人员以更高效和更优良的方式创建用户界面。

在 React 中，每当我们通过 setState 或其他机制告诉它对 UI 进行更改时，虚拟 DOM 首先会进行更新，然后真实 DOM 会被更新以匹配虚拟 DOM 中的更改。这个过程称为协调（reconciliation），将在第 4 章进行详细讨论。

首先更新虚拟 DOM 的原因在于，对真实 DOM 的更新可能会有些缓慢和昂贵。我们将在接下来的部分进行介绍，但其要点是，每当对真实 DOM 进行更改时，浏览器都必须重新计算页面的布局、重新绘制屏幕，并执行其他可能耗时的操作。

例如，仅仅读取一个元素的 offsetWidth 就可能触发重新排版（reflow）过程，这是浏览器重新计算文档全部或部分布局的过程，可能会影响性能，使直接的 DOM 交互变得不那么高效：

```js
const btn = document.getElementById("myButton");
const width = btn.offsetWidth; // This can trigger a reflow
```

另一方面，更新虚拟 DOM 要快得多，因为它不涉及对实际页面布局的任何更改。相反，它是一个简单的 JavaScript 对象，可以通过各种算法方法快速高效地操作，这些方法可以充分利用可用的 JavaScript 引擎，并随着时间的推移增加其效率，与浏览器和其他宿主环境解耦。

当对虚拟 DOM 进行更新时，React 使用一种差异比对算法来识别新旧版本之间的差异。然后，该算法确定更新真实 DOM 所需的最小变更集，并以批处理和优化的方式应用这些变更，以最大限度地减少性能影响。

在本章中，我们将探讨虚拟 DOM 和真实 DOM 之间的区别，真实 DOM 的缺陷，以及虚拟 DOM 如何帮助创建更好的用户界面。我们还将深入研究 React 对虚拟 DOM 的实现以及用于高效更新的算法。

## 真实 DOM

在这个例子中，我们使用 `document.querySelector()` 方法检索具有类名 "heading" 的 h1 元素。然后，我们通过将其 `innerHTML` 属性设置为 "Updated Heading!" 来修改元素的内容。这将页面上显示的文本从 "Welcome to my page!" 更改为 "Updated Heading!"。

这似乎并不太复杂，但这里有几点需要注意。首先，我们使用 `document.querySelector()` 方法从真实 DOM 中检索元素。该方法接受一个 CSS 选择器作为参数，并返回与选择器匹配的第一个元素。在这种情况下，我们传入了类选择器 `.heading`，它匹配类名为 "heading" 的 h1 元素。

这里存在一定的风险，因为虽然 `document.querySelector` 方法是一个强大的工具，可以根据 CSS 选择器选择真实 DOM 中的元素，但使用该方法的一个潜在性能问题是，在处理大型和复杂文档时可能会很慢。该方法必须从文档顶部开始向下遍历以找到所需的元素，这可能是一个耗时的过程。

当我们使用 CSS 选择器调用 `document.querySelector()` 时，浏览器必须在整个文档树中搜索匹配的元素。这意味着搜索可能会很慢，特别是如果文档很大且结构复杂的情况下。此外，浏览器还必须评估选择器本身，这可能是一个复杂的过程，取决于选择器的复杂性。

相比之下，`document.getElementById` 不需要像 CSS 选择器那样进行验证，并且具有更高的特异性，因为 id 属性预期是唯一的，所以通常更有效率。

就运行时复杂度而言，使用大 O 符号表示，`getElementById` 在现代浏览器中通常被近似为 O(1)，因为它们可能使用哈希机制（如哈希表）来实现高效的 ID→元素映射。尽管理想情况下哈希表查找的平均时间复杂度是 O(1)，但重要的是要考虑到最坏情况，例如哈希冲突可能导致较长的查找时间。考虑到浏览器并不真正强制 ID 的唯一性，这些哈希冲突很可能会发生。

然而，在现代浏览器中，借助先进的哈希函数和调整大小策略，这些情况很少见。

**注意：**

对于那些没有上过计算机学校，可能不了解大 O 表示法的人来说，它是开发人员用来衡量一段代码运行速度快慢的一种方便工具，特别是随着代码需要处理的数据量增加。基本上，大 O 表示法提供了一种高级理解算法的方式，包括时间复杂度（随着输入规模增加，执行时间如何增长）和空间复杂度（随着输入规模增加，内存使用量如何增长）。它通常用(O(1))、(O(n))、(O(n log n)) 或 (O(n²)) 等术语来表示，其中 (n) 是输入的大小。因此，当开发人员谈论代码是否“高效”或“可扩展”时，他们通常指的是这些大 O 值，旨在确保他们的软件在处理更多数据时仍然具有良好的性能，采用具有较低时间和空间复杂度的算法。

此外，由于 ID 应该是唯一的，它们并不是很适合在页面上使用多个可重用组件。这就是 querySelector 发挥作用的地方，因为它可以用来选择具有相同类名的多个元素，例如。

话虽如此，querySelector 可以接受各种 CSS 选择器，因此它的复杂性是可变的。在最坏的情况下，方法可能需要遍历整个 DOM 来确保匹配或不存在匹配项，其复杂性可能为 (O(n))，其中 (n) 是 DOM 中的元素数量。然而，对于更具体的选择器或者如果在 DOM 树的早期找到匹配项，实际运行时可能小于 (O(n))。

值得注意的是，在小型文档或者在文档树的特定区域中搜索元素时，document.getElementById 和 document.querySelector 之间的性能差异可能可以忽略不计。然而，在更大更复杂的文档中，这种差异可能变得更加明显。

有些人可能会说整个“CPU 效率”论点被夸大了，而且不值得担心。虽然这可能是真的，也可能不是，但没有人可以否认 React 的虚拟 DOM 提供的额外价值，它能够组件化逻辑，并避免在 DOM 这样一个易变的环境中管理状态。我们说 DOM 是易变的，因为它受到很多因素的影响，包括用户交互、网络请求、客户端脚本和其他可能随时导致其更改的事件。通过虚拟 DOM，React 保护我们免受这种环境的影响。

我们深入探讨这些微妙的细节，是因为要真正熟练地掌握 React，了解 DOM 的整体复杂性至关重要。明智地使用 DOM 并不是一件小事，而有了 React，我们可以选择是自己在这个雷区里航行，偶尔踩到地雷，还是使用一个能够通过虚拟 DOM 安全地浏览 DOM 的工具。

虽然我们在这里讨论了如何选择元素的一些小细节，但我们还没有机会深入探讨直接操作 DOM 的缺陷。让我们快速地做一下这个，以充分理解 React 虚拟 DOM 提供的价值。

### 真实 DOM 的缺陷

真实 DOM 存在几个缺陷，可能会使构建高性能 Web 应用程序变得困难。其中一些缺陷包括性能问题、跨浏览器兼容性和安全漏洞，直接操作 DOM 可能会导致跨站脚本（XSS）漏洞。

#### 性能

真实 DOM 的最大问题之一是性能。每当对 DOM 进行更改时，比如添加或移除元素，或更改元素的文本或属性，浏览器都必须重新计算布局并重新绘制页面的受影响部分。这可能是一个缓慢且资源密集的过程，特别是对于大型和复杂的网页而言。
正如前面提到的，读取 DOM 元素的 offsetWidth 属性可能看起来是一个简单的操作，但实际上可能会触发浏览器进行昂贵的布局重新计算。这是因为 offsetWidth 是一个计算属性，依赖于元素及其祖先的布局，这意味着浏览器需要确保布局信息是最新的，然后才能返回准确的值。
在最糟糕的情况下，使用大 O 表示法读取元素的 offsetWidth 属性可能估算为（O(n)）。这是因为访问此属性可能会触发浏览器进行重新布局，这涉及重新计算页面上多个元素的布局位置。在这种情况下，（n）表示受重新布局影响的 DOM 元素数量。即使直接属性访问很快，但相关的副作用，如重新布局，可能会使操作随着页面上元素数量的增加而扩展。

如果你想避免像 offsetWidth 这样的布局属性触发重排，我们可以采用一些技巧来提高性能。下面是一种方法，使用 getBoundingClientRect() 方法，它可以批量读取和写入布局：

```js
// Accessing layout properties in a more performant way
function getOffsetWidthWithoutTriggeringReflow(element) {
  let width;
  // Batch all reading operations
  const rect = element.getBoundingClientRect();
  width = rect.width;
  // ... any other reading operations
  // Followed by writing operations, if any
  return width;
}
const element = document.querySelector(".myElement");
const width = getOffsetWidthWithoutTriggeringReflow(element);
console.log(width);
```

通过使用 getBoundingClientRect()，我们可以在单个调用中检索多个布局属性，减少触发多次重排的机会。此外，通过分别批处理读取和写入操作，我们可以进一步最小化布局抖动，即由频繁交错读写布局属性而引起的重复和不必要的布局重新计算（见图3-1）。这种抖动会显著降低网页的性能，导致用户体验迟缓。通过战略性地访问布局属性和批处理我们的操作，我们可以保持网页交互的流畅和响应。

然而，即使使用 getBoundingClientRect()，如果存在待处理的布局更改，仍可能会触发重排。在这里，性能的关键是尽量减少强制浏览器重新计算布局的次数，并且在这样做时，尽量一次性获取尽可能多的信息。

React 使用虚拟 DOM 作为真实 DOM 操作之间的中间层，从而为我们处理了所有这些问题。

考虑以下示例，其中包含一个简单的 HTML 文档，其中有一个 div 元素：



一般来说，我们在读取类似 offsetWidth 这样依赖布局的属性时要小心，因为它们可能导致意想不到的性能问题。如果我们需要多次读取这些属性的值，我们应该考虑将值缓存到一个变量中，以避免触发不必要的布局重新计算。或者，我们可以使用 requestAnimationFrame API 将属性的读取推迟到下一个动画帧，这时浏览器已经执行了必要的布局计算。

为了更深入了解实际 DOM 中可能出现的性能问题，让我们看一些例子。考虑以下 HTML 文档：

#### 跨浏览器兼容性

另一个实际 DOM 的问题是跨浏览器兼容性。不同的浏览器以不同的方式对文档进行建模，这可能导致网页应用程序中的不一致性和 bug。当 React 发布时，这种情况更为常见，但现在已经不那么常见了。尽管如此，这仍然可能使开发人员难以创建在不同浏览器和平台上无缝运行的 web 应用程序。
跨浏览器兼容性的主要问题之一是某些 DOM 元素和属性可能不被所有浏览器支持。因此，我们不得不花费额外的时间和精力来实现解决方案和回退，以确保应用程序在所有目标平台上正确运行。
这正是 React 使用其合成事件系统解决的问题。SyntheticEvent 是对浏览器原生事件的封装，旨在确保在不同浏览器之间的一致性。它使用以下机制解决浏览器之间的不一致性：

*统一接口*

在原始的 JavaScript 中，处理浏览器事件可能会很棘手，因为存在不一致性。例如，访问事件属性可能在不同的浏览器中有所不同。有些可能使用 event.target，而其他浏览器可能使用 event.srcElement。SyntheticEvent 抽象了这些差异，提供了一种一致的方式来与事件交互，并确保开发人员不必编写特定于浏览器的代码。

通过将原生事件包装到 SyntheticEvent 系统中，React 屏蔽了许多原生浏览器事件系统的不一致性和怪异之处，使开发人员更容易处理事件。

*事件委托*
React 不直接将事件侦听器附加到元素上，而是在根级别监听事件。这种方法避开了一些事件在旧版浏览器中可能不可用的元素问题。

*跨功能增强*
原生浏览器事件在处理不同输入元素上的某些事件时存在不一致性是一个领域。一个显著的例子是 onChange 事件：

*访问原生事件*
如果开发人员需要原始的浏览器事件，可以通过 event.nativeEvent 获取，这样既保证了灵活性，又不损失抽象带来的好处。

本质上，SyntheticEvent 提供了一个稳定的事件系统，消除了原生浏览器事件的怪癖和差异。这只是 React 利用其虚拟 DOM 为 UI 开发提供便利的一种具体方式。到目前为止，我们一直在讨论直接使用 DOM 可能导致性能问题和跨浏览器兼容性问题。现在让我们探讨一种更高效的原生方法，通过使用文档片段来解决这些问题，文档片段可以被视为对理解 React 虚拟 DOM 的一种原生先导。

### Document Fragments  

正如我们所见，直接操作 DOM 可能会对性能造成影响，特别是涉及多个更改时。每次更新 DOM，浏览器都可能需要执行布局重新计算、重新绘制 UI 并更新视图，这可能会减慢应用程序的速度。这就是文档片段的用武之地。

文档片段是一个轻量级容器，用于保存 DOM 节点。它就像一个临时的暂存区，您可以在其中进行多个更改而不影响主 DOM。完成后，您可以将文档片段附加到 DOM，触发一次回流和重绘。

从这个角度看，文档片段与 React 的虚拟 DOM 非常接近。因为文档片段是轻量级容器，允许我们批量更新，所以它们具有多个性能优势：

批量更新：

将所有更改批量处理到一个文档片段中，而不是对实时 DOM 进行多个单独的更新。这意味着，无论您在片段内进行了多少元素或更改，只会发生一次回流和重绘。

内存效率：

当节点添加到文档片段时，它们会从 DOM 中的当前父节点中移除。这有助于优化内存使用，特别是在重新排序大型文档部分时。

没有冗余渲染：

由于文档片段不是活动文档树的一部分，对其进行的更改不会影响实时文档，并且样式和脚本直到片段附加到实际 DOM 之后才会应用。这避免了冗余的样式重新计算和脚本执行。

考虑这样一个场景，您需要向列表中添加多个列表项：

```js
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const li = document.createElement("li");
  li.textContent = `Item ${i + 1}`;
  fragment.appendChild(li);
}
document.getElementById("myList").appendChild(fragment);
```

在这个示例中，首先将100个列表项添加到文档片段中。只有在所有项目都添加完毕后，片段才会附加到主列表中。这样一来，实际的 DOM 只需进行一次更新，而不是 100 次单独的更新。

通过这种方式，文档片段提供了一种有效地操作 DOM 的方法，将多个更改批量处理在一起，从而减少了昂贵的回流和重绘的次数。对于追求在其 Web 应用程序中获得最佳性能的开发人员来说，利用文档片段可以实现更流畅的交互和更快的渲染时间。

React 的虚拟 DOM 可以类比为文档片段概念的高级实现。以下是简要的关联：

批量更新

类似于文档片段，React 的虚拟 DOM 将多个更改一起批处理。React 不会在每次状态或属性更改时直接修改实时 DOM，而是首先在虚拟 DOM 中编译这些更改。

高效的差异比较

然后，React 确定当前虚拟 DOM 与实际 DOM 之间的差异（或“diffs”）。这个差异比较过程确保只对实际 DOM 进行必要的更改，类似于文档片段如何减少直接 DOM 操作。

单一渲染

一旦识别出差异，React 就会以单个批次更新实际 DOM，就像附加一个完全填充的文档片段一样。这最小化了昂贵的回流和重绘。

实质上，虽然文档片段提供了一种在更新实时 DOM 之前对一组更改进行分组和优化的方法，但React的虚拟 DOM 更进一步，通过智能差异比较和批处理更新整个应用程序的用户界面，确保渲染效率最大化。

此外，React将所有这些文档片段的内容转化为一个实现细节，我们作为日常开发人员无需过多关注，从而使我们能够更专注地构建我们的产品。因此，让我们详细了解虚拟 DOM 的工作原理。