## Fluent React 

## Build Fast, Performant, and Intuitive Web Applications

## 第一章 入门知识

作为补充，我们提到了防抖 (debouncing) 和节流 (throttling) 这两个概念。为了清楚起见，**防抖会延迟函数的执行，直到距离上一次事件触发经过设定时间之后才执行**（例如，等待用户停止输入后再处理输入内容）。**节流则限制函数每隔设定时间间隔最多只运行一次**，确保其不会过于频繁地执行（例如，以设定的间隔处理滚动事件）。这两种技术通过控制函数的执行速率来优化性能。

## 进入React

### 声明式与命令式代码

React提供了对DOM的声明式抽象。我们稍后会在书中更详细地讨论它是如何做到这一点的，但基本上它为我们提供了一种编写代码的方式，表达我们想要看到的内容，同时又负责处理代码如何执行，确保我们的用户界面以安全、可预测和高效的方式创建并运行。

让我们考虑一下我们之前创建的列表应用程序。在React中，我们可以像这样重写它：

注意在返回语句中，我们实际上写的是看起来像HTML的东西：它看起来就像我们想要看到的内容。我想看到一个带有NewItemForm的框和一个列表。咔嚓。如何实现这一点？这是由React来解决的。我们是批处理列表项以一次性添加它们的一部分吗？我们是逐个添加它们，一个接一个吗？React处理了这是如何完成的，而我们仅仅描述了我们想要做的事情。在后续章节中，我们将深入探讨React，并详细探索它在编写时是如何做到这一点的。

那么我们是否依赖于类名来引用HTML元素？我们是否在JavaScript中使用getElementById？不是的。React在幕后为我们创建了唯一的“React元素”，它用于检测更改并进行增量更新，因此我们不需要从用户代码中读取类名和其他标识符，我们无法保证其存在：我们的真相来源仅仅是JavaScript与React。

我们将我们的 MyList 组件导出给 React，React 将其显示在屏幕上，以一种安全、可预测和高效的方式——无需多问。组件的任务只是返回一个描述这个 UI 部分应该是什么样子的描述。它通过使用虚拟 DOM（vDOM）来实现这一点，虚拟 DOM 是对预期 UI 结构的轻量级描述。然后，React 在更新发生后将虚拟 DOM 与更新之前的虚拟 DOM 进行比较，并将其转换为对真实 DOM 的小型、高效的更新，使其与虚拟 DOM 匹配。这就是 React 如何能够更新 DOM。

### 虚拟 DOM

虚拟 DOM 是一个编程概念，它代表了真实 DOM，但作为一个 JavaScript 对象。如果这对现在来说有点太复杂了，不用担心：第三章专门介绍了这个概念，并以更详细的方式进行了解释。目前，重要的是要知道虚拟 DOM 允许开发人员更新 UI 而不直接操作实际的 DOM。React 使用虚拟 DOM 来跟踪组件的更改，并仅在必要时重新渲染组件。这种方法比每次有更改时更新整个 DOM 树更快、更高效。

在 React 中，虚拟 DOM 是实际 DOM 树的轻量级表示。它是一个普通的 JavaScript 对象，描述了 UI 元素的结构和属性。React 创建和更新虚拟 DOM 以匹配实际 DOM 树，对虚拟 DOM 进行的任何更改都将使用一种称为协调的过程应用到实际 DOM 上。

第四章专门介绍了这个概念，但在我们当前的上下文讨论中，让我们简要总结一下，并举几个例子。为了理解虚拟 DOM 的工作原理，让我们回顾一下我们的点赞按钮的例子。我们将创建一个 React 组件，显示一个点赞按钮和点赞的数量。当用户点击按钮时，点赞的数量应该增加一。

下面是我们组件的代码：

```jsx
import React, { useState } from "react";
function LikeButton() {
  const [likes, setLikes] = useState(0);
  function handleLike() {
    setLikes(likes + 1);
  }
  return (
    <div>
      <button onClick={handleLike}>Like</button>
      <p>{likes} Likes</p>
    </div>
  );
}
export default LikeButton;

```

在这段代码中，我们使用了 useState 钩子来创建一个状态变量 likes，它保存着点赞的数量。回顾一下我们可能已经了解的关于 React 的知识，钩子是一种特殊的函数，允许我们在函数组件内部使用 React 的功能，比如状态和生命周期方法。钩子使我们能够重用有状态逻辑而不改变组件层次结构，使得从组件中提取和共享钩子变得容易，甚至可以将其作为独立的开源包与社区共享。

我们还定义了一个名为 handleLike 的函数，当按钮被点击时，它会将 likes 的值增加一。最后，我们使用 JSX 渲染了点赞按钮和点赞数量。

现在，让我们更详细地看一下在这个示例中虚拟 DOM 是如何工作的。当 LikeButton 组件首次被渲染时，React 创建了一个虚拟 DOM 树，它镜像了实际 DOM 树。虚拟 DOM 包含一个包含一个按钮元素和一个 p 元素的 div 元素：

```js
{
  $$typeof: Symbol.for('react.element'),
  type: 'div',
  props: { },
  children: [
    {
      $$typeof: Symbol.for('react.element'),
      type: 'button',
      props: { onClick: handleLike },
      children: ['Like']
    },
    {
      $$typeof: Symbol.for('react.element'),
      type: 'p',
      props: {},
      children: [0, ' Likes']
    }
  ]
}
```

p 元素的 children 属性包含 Likes 状态变量的值，初始设置为零。
当用户点击点赞按钮时，会调用 handleLike 函数，该函数会更新 likes 状态变量。React 然后创建一个反映更新状态的新虚拟 DOM 树：

```js
{
  type: 'div',
    props: { },
  children: [
    {
      type: 'button',
      props: { onClick: handleLike },
      children: ['Like']
    },
    {
      type: 'p',
      props: {},
      children: [1, ' Likes']
    }
  ]
}
```

请注意，虚拟 DOM 树包含与之前相同的元素，但是 p 元素的 children 属性已经更新，以反映 likes 的新值，从 0 变为 1。接下来是 React 中称为协调的过程，其中新的虚拟 DOM 与旧的虚拟 DOM 进行比较。让我们简要讨论一下这个过程。

在计算出新的虚拟 DOM 树之后，React 执行一种称为协调的过程，以了解新树与旧树之间的差异。协调是将旧的虚拟 DOM 树与新的虚拟 DOM 树进行比较，并确定实际 DOM 的哪些部分需要更新的过程。如果您对这个过程的具体实现方式感兴趣，第四章会对此进行详细的讨论。现在，让我们考虑我们的点赞按钮。

在我们的示例中，React 将旧的虚拟 DOM 树与新的虚拟 DOM 树进行比较，并发现 p 元素已经发生了变化：具体来说，它的属性或状态或两者都已经改变。这使得 React 能够将组件标记为“脏”或“应该更新”。然后，React 计算出一组最小有效的更新操作，以便在实际 DOM 上与新虚拟 DOM 的状态进行协调，并最终更新实际 DOM，以反映对虚拟 DOM 所做的更改。

React 仅更新实际 DOM 中必要的部分，以尽量减少 DOM 操作的次数。这种方法比每次更改时更新整个 DOM 树要快得多，更高效。

虚拟 DOM 对于现代网络来说是一个强大且有影响力的发明，较新的库如 Preact 和 Inferno 在 React 中证明有效后也采用了它。我们将在第四章中更详细地介绍虚拟 DOM，但现在让我们继续下一节。

### 组件模型

- React 强烈鼓励“以组件思维思考”：即将您的应用程序拆分为较小的部分，并将它们添加到一个较大的树中以组合您的应用程序。组件模型是 React 中的一个关键概念，也是使 React 如此强大的原因。让我们谈谈为什么：它鼓励在每个地方重复使用相同的内容，这样如果出现问题，您只需在一个地方修复它，问题就会得到解决。这被称为 DRY（不要重复自己）开发，是软件工程中的一个关键概念。例如，如果我们有一个 Button 组件，我们可以在应用程序的许多地方使用它，如果我们需要更改按钮的样式，我们可以在一个地方进行更改，所有地方都会相应更改。

- 如果能够反复识别特定组件并跟踪特定组件的更新，React 就更容易跟踪组件并在幕后执行性能优化，如记忆化、批处理和其他优化。这称为键。例如，如果我们有一个 Button 组件，我们可以为其提供一个 key 属性，React 将能够随着时间的推移跟踪 Button 组件并“知道”何时更新它，或者何时跳过更新它并继续对用户界面进行最小更改。大多数组件都有隐式键，但如果需要，我们也可以显式提供它们。

- 它帮助我们分离关注点，并将逻辑放置在逻辑影响的用户界面部分附近。例如，如果我们有一个 RegisterButton 组件，我们可以将当按钮被点击时发生的事件逻辑放置在与 RegisterButton 组件相同的文件中，而不是必须在不同的文件中跳来跳去查找按钮被点击时的逻辑。RegisterButton 组件将包装一个更简单的 Button 组件，并且 RegisterButton 组件将负责处理按钮被点击时的逻辑。这称为组合。

React 的组件模型是支撑该框架流行和成功的基本概念。这种开发方式具有许多优点，包括增强的模块化、更容易的调试和更高效的代码重用。

### 不可变状态

React 的设计理念强调了一种范式，其中我们应用程序的状态被描述为一组不可变的值。每次状态更新都被视为一个新的、独立的快照和内存引用。这种不可变的状态管理方式是 React 的价值主张的核心部分，对于开发健壮、高效和可预测的用户界面有几个优势。

通过强制不可变性，React 确保 UI 组件在任何给定时间点都反映了特定的状态。当状态发生变化时，而不是直接进行变异，您返回一个代表新状态的新对象。这使得跟踪变化、调试和理解应用程序的行为变得更容易。由于状态转换是离散的，彼此不干扰，因此由共享的可变状态引起的微妙错误的几率大大降低。

在接下来的章节中，我们将探讨 React 如何批处理状态更新并异步处理它们以优化性能。由于状态必须被视为不可变的，因此可以安全地聚合和应用这些“事务”，而不会出现一次更新破坏另一个更新的状态的风险。这导致了更可预测的状态管理，并且可以改善应用程序的性能，特别是在复杂的状态转换期间。

不可变状态的使用进一步强化了软件开发中的最佳实践。它鼓励开发人员在数据流方面采用函数式思维，减少副作用，并使代码更易于理解。不可变数据流的清晰性简化了理解应用程序如何工作的心智模型。

不可变性还可以实现强大的开发工具，例如使用 Replay.io 等工具进行时间旅行调试，开发人员可以向前和向后浏览应用程序状态变化，以检查任意时间点的 UI。只有将每个状态更新保留为唯一且未修改的快照，这才是可行的。

React 对不可变状态更新的承诺是一个经过深思熟虑的设计选择，带来了许多好处。它符合现代函数式编程原则，可以实现高效的 UI 更新，优化性能，降低错误的可能性，并改善整体开发人员体验。这种状态管理方式支撑了 React 的许多高级功能，并将继续是 React 发展的基石。

## 发布 React

单向数据流是对多年来构建 Web 应用程序的方式的一个激进转变，它受到了怀疑。事实上，Facebook 是一家拥有大量资源、大量用户和大量工程师观点的大公司，这使得它的上升之路非常陡峭。经过深入审查，React 在内部取得了成功。它被 Facebook 和 Instagram 采用。

然后在 2013 年开源，面向全世界发布，但遭到了巨大的反对。人们严厉批评 React 使用 JSX，指责 Facebook “将 HTML 放入 JavaScript” 并破坏了关注点的分离。Facebook 成为了一个“重新思考最佳实践”并破坏网络的公司。

最终，在 Netflix、Airbnb 和纽约时报等公司缓慢而稳定地采用之后，React 成为了在 Web 上构建用户界面的事实标准。

这个故事中有很多细节被省略了，因为它们超出了本书的范围，但在我们深入细节之前了解 React 的背景是很重要的，特别是 React 被创建来解决的技术问题的范围。如果你对 React 的故事更感兴趣，YouTube 上有一部完整的 React 历史纪录片，名为 Honeypot 制作的《React.js：纪录片》。

考虑到 Facebook 在巨大规模下面临的这些问题，React 开创了一种基于组件的方法来构建用户界面，可以解决这些问题和更多问题，其中每个组件都是可以重用和组合的代码的独立单元，用于构建更复杂的用户界面。React 发布一年后，Facebook 发布了 Flux：一种管理 React 应用程序中数据流的模式。Flux 是对管理大规模应用程序中数据流挑战的应对，它是 React 生态系统的重要组成部分。让我们来看一下 Flux 以及它如何与 React 结合。

## 总结：那么...为什么 React 如此受欢迎？

React 之所以如此受欢迎，是因为它使开发人员能够以更高的可预测性和可靠性构建用户界面，让我们以声明式的方式表达我们想要在屏幕上看到的内容，而 React 则通过以高效的方式对 DOM 进行增量更新来处理具体的实现。它还鼓励我们以组件为中心思考，这有助于我们分离关注点并更轻松地重用代码。它在 Meta 公司经过了大规模测试，并设计用于大规模应用。此外，它是开源的，并且可以免费使用。

React 还拥有庞大而活跃的生态系统，开发人员可以获得各种各样的工具、库和资源。这个生态系统包括用于测试、调试和优化 React 应用程序的工具，以及用于常见任务（如数据管理、路由和状态管理）的库。此外，React 社区非常活跃和支持，有许多在线资源、论坛和社区可供开发人员学习和成长。

React 是平台无关的，这意味着它可以用于构建广泛的平台上的 Web 应用程序，包括桌面、移动和虚拟现实。这种灵活性使得 React 成为开发人员的理想选择，因为它可以让他们使用单一的代码库构建跨多个设备运行的应用程序。

总之，React 的价值主张围绕着其基于组件的架构、声明式编程模型、虚拟 DOM、JSX、丰富的生态系统、平台无关的特性以及由 Meta 公司支持。这些特性使得 React 成为需要构建快速、可扩展和易于维护的 Web 应用程序的开发人员的理想选择。无论您是构建简单的网站还是复杂的企业应用程序，React 都可以帮助您以比许多其他技术更高效、更有效的方式实现您的目标。让我们进行回顾。

# 第2章 JSX  

## 底层实现

那个正则表达式甚至没有完全有效，因为完整版本无法放在一页上！这就是为什么不使用正则表达式，而是使用编译器来编译代码的原因。编译器是一种将用高级编程语言编写的源代码根据特定规则转换为语法树（字面上是一种树状数据结构，类似于 JavaScript 对象）的软件。编译代码的过程涉及几个步骤，包括词法分析、语法分析、语义分析、优化和代码生成。让我们更详细地探讨每个步骤，并讨论编译器在现代软件开发中的作用。

编译器使用一个三步骤的过程（至少在 JavaScript 中是这样）在这里发挥作用。这些步骤称为标记化（Tokenization）、解析（Parsing）和代码生成（Code Generation）。让我们更详细地看看每个步骤：

标记化：
基本上是将一串字符分解为有意义的标记。
当标记器具有状态，并且每个标记包含其父级和/或子级的状态时，标记器称为词法分析器（Lexer）。这是我们讨论的一个必要简化：词法分析实质上是有状态的标记化。
词法分析器具有词法规则，在某些情况下，确实使用正则表达式或类似的方法来检测文本字符串中代表编程语言的关键标记，如变量名、对象键和值等。然后，词法分析器将这些关键字映射到某种可枚举值，具体取决于其实现。例如，const 变成 0，let 变成 1，function 变成 2，等等。
一旦一个字符串被标记化或词法分析，我们就进入下一个步骤，解析。

解析（Parsing）
将标记（tokens）转换为语法树（syntax tree）的过程。
语法树是表示代码结构的数据结构。例如，我们之前看过的代码片段将被表示为一个语法树，类似于这样：

代码生成（Code generation）
这是编译器从抽象语法树（AST）生成机器代码的过程。这涉及将 AST 中的代码转换为一系列指令，这些指令可以直接由计算机的处理器执行。生成的机器代码然后由 JavaScript 引擎执行。总的来说，将 AST 转换为机器代码的过程是复杂的，并涉及许多不同的步骤。然而，现代编译器非常复杂，可以生成在各种硬件架构上高效运行的高度优化的代码。

为了高效执行 JavaScript 代码，许多现代环境，包括 Web 浏览器，在这些系统中利用了即时编译器（JIT 编译器）。在这些系统中，JavaScript 源代码可能首先被转换为中间表示形式，例如字节码。然后 JIT 编译器在程序运行时动态地将这些字节码编译为机器代码。这种即时编译允许引擎根据实时信息（例如变量类型和频繁执行的代码路径）进行优化。一些引擎采用多阶段编译，首先进行快速的、非优化的编译以快速开始执行，然后针对频繁执行的代码段进行更多的优化编译。这种动态方法使 JavaScript 引擎能够为各种应用程序实现令人印象深刻的性能。

运行时通常与引擎进行交互，为特定环境提供更多的上下文帮助器和特性。目前最流行的 JavaScript 运行时是常见的 Web 浏览器，如 Google Chrome：它提供了与引擎进行交互的 Chromium 运行时。同样，在服务器端，我们使用的是 Node.js 运行时，它仍然使用 v8 引擎。您还能在野外识别出哪些引擎和运行时呢？

运行时为 JavaScript 引擎提供了上下文，例如浏览器运行时提供的 window 对象和 document 对象。如果您之前同时使用过浏览器和 Node.js，您可能已经注意到 Node.js 没有全局的 window 对象。这是因为它是一个不同的运行时，并且因此提供了不同的上下文。Cloudflare 创建了一个类似的运行时，称为 Workers，其唯一责任是在全球分布的称为边缘服务器的计算机上执行 JavaScript，Bun 和 Deno 是更加另类的运行时，但我们在这里偏题了。这一切与 JSX 有何关系呢？

### 扩展 JavaScript 语法到 JSX

现在我们了解了如何扩展 JavaScript 语法，那么 JSX 是如何工作的呢？我们该如何做呢？要扩展 JavaScript 语法，我们需要使用一个可以理解我们新语法的不同引擎，或者在新语法到达引擎之前处理它。前者几乎不可能实现，因为引擎需要大量的思考来创建和维护，因为它们往往被广泛使用。如果我们决定选择这个选项，可能需要数年甚至数十年才能使用我们的扩展语法！然后，我们还需要确保我们的“定制特殊引擎”被广泛使用。我们如何说服浏览器厂商和其他利益相关者切换到我们不受欢迎的新东西呢？这是行不通的。
后者更快速：让我们探讨如何在新语法到达引擎之前处理我们的新语法。为了做到这一点，我们需要创建自己的词法分析器和解析器，它们可以理解我们扩展的语言：即，接受一串代码文本并理解它。然后，我们可以将这棵语法树转换成普通的传统 JavaScript，而不是生成机器代码，所有当前的引擎都可以理解。这正是 JavaScript 生态系统中 Babel 和其他工具（如 TypeScript、Traceur 和 swc）所做的事情。

# 第3章 虚拟 DOM

在本章中，我们将深入探讨虚拟 DOM（有时称为 vDOM）的概念及其在 React 中的重要性。我们还将探讨 React 如何利用虚拟 DOM 使 web 开发更加简单和高效。
随着 web 应用程序变得越来越复杂，管理“真实 DOM”变得越来越困难，这是一个复杂且容易出错的过程，我们很快就会看到，正如我们在第一章中粗略地讨论过的那样。React 的虚拟 DOM 为这个问题提供了解决方案。
在本章中，我们将探讨 React 虚拟 DOM 的工作原理，以及它相对于真实 DOM 的优势和实现方式。我们还将介绍 React 如何围绕真实 DOM 使用虚拟 DOM 优化性能，以及它们如何协同工作。
通过一系列的代码示例和详细的解释，我们将了解虚拟 DOM 在 React 中的作用，以及如何利用它的优势来创建健壮高效的 web 应用程序。让我们开始吧！

## 虚拟 DOM 介绍

虚拟 DOM（Virtual DOM）和 DOM 一样，是一个被建模为 JavaScript 对象的 HTML 文档：这实际上就是文档对象模型（DOM）的含义。DOM 本身是浏览器运行时对文档的模型。虚拟 DOM 是这个模型的一个轻量级副本，其主要区别在于，虽然真实 DOM 是由节点对象组成的，但虚拟 DOM 则是由充当描述的普通 JavaScript 对象组成的。正如我们在本章中将要发现的那样，它允许 web 开发人员以更高效和更优良的方式创建用户界面。

在 React 中，每当我们通过 setState 或其他机制告诉它对 UI 进行更改时，虚拟 DOM 首先会进行更新，然后真实 DOM 会被更新以匹配虚拟 DOM 中的更改。这个过程称为协调（reconciliation），将在第 4 章进行详细讨论。

首先更新虚拟 DOM 的原因在于，对真实 DOM 的更新可能会有些缓慢和昂贵。我们将在接下来的部分进行介绍，但其要点是，每当对真实 DOM 进行更改时，浏览器都必须重新计算页面的布局、重新绘制屏幕，并执行其他可能耗时的操作。

例如，仅仅读取一个元素的 offsetWidth 就可能触发重新排版（reflow）过程，这是浏览器重新计算文档全部或部分布局的过程，可能会影响性能，使直接的 DOM 交互变得不那么高效：

```js
const btn = document.getElementById("myButton");
const width = btn.offsetWidth; // This can trigger a reflow
```

另一方面，更新虚拟 DOM 要快得多，因为它不涉及对实际页面布局的任何更改。相反，它是一个简单的 JavaScript 对象，可以通过各种算法方法快速高效地操作，这些方法可以充分利用可用的 JavaScript 引擎，并随着时间的推移增加其效率，与浏览器和其他宿主环境解耦。

当对虚拟 DOM 进行更新时，React 使用一种差异比对算法来识别新旧版本之间的差异。然后，该算法确定更新真实 DOM 所需的最小变更集，并以批处理和优化的方式应用这些变更，以最大限度地减少性能影响。

在本章中，我们将探讨虚拟 DOM 和真实 DOM 之间的区别，真实 DOM 的缺陷，以及虚拟 DOM 如何帮助创建更好的用户界面。我们还将深入研究 React 对虚拟 DOM 的实现以及用于高效更新的算法。

## 真实 DOM

在这个例子中，我们使用 `document.querySelector()` 方法检索具有类名 "heading" 的 h1 元素。然后，我们通过将其 `innerHTML` 属性设置为 "Updated Heading!" 来修改元素的内容。这将页面上显示的文本从 "Welcome to my page!" 更改为 "Updated Heading!"。

这似乎并不太复杂，但这里有几点需要注意。首先，我们使用 `document.querySelector()` 方法从真实 DOM 中检索元素。该方法接受一个 CSS 选择器作为参数，并返回与选择器匹配的第一个元素。在这种情况下，我们传入了类选择器 `.heading`，它匹配类名为 "heading" 的 h1 元素。

这里存在一定的风险，因为虽然 `document.querySelector` 方法是一个强大的工具，可以根据 CSS 选择器选择真实 DOM 中的元素，但使用该方法的一个潜在性能问题是，在处理大型和复杂文档时可能会很慢。该方法必须从文档顶部开始向下遍历以找到所需的元素，这可能是一个耗时的过程。

当我们使用 CSS 选择器调用 `document.querySelector()` 时，浏览器必须在整个文档树中搜索匹配的元素。这意味着搜索可能会很慢，特别是如果文档很大且结构复杂的情况下。此外，浏览器还必须评估选择器本身，这可能是一个复杂的过程，取决于选择器的复杂性。

相比之下，`document.getElementById` 不需要像 CSS 选择器那样进行验证，并且具有更高的特异性，因为 id 属性预期是唯一的，所以通常更有效率。

就运行时复杂度而言，使用大 O 符号表示，`getElementById` 在现代浏览器中通常被近似为 O(1)，因为它们可能使用哈希机制（如哈希表）来实现高效的 ID→元素映射。尽管理想情况下哈希表查找的平均时间复杂度是 O(1)，但重要的是要考虑到最坏情况，例如哈希冲突可能导致较长的查找时间。考虑到浏览器并不真正强制 ID 的唯一性，这些哈希冲突很可能会发生。

然而，在现代浏览器中，借助先进的哈希函数和调整大小策略，这些情况很少见。

**注意：**

对于那些没有上过计算机学校，可能不了解大 O 表示法的人来说，它是开发人员用来衡量一段代码运行速度快慢的一种方便工具，特别是随着代码需要处理的数据量增加。基本上，大 O 表示法提供了一种高级理解算法的方式，包括时间复杂度（随着输入规模增加，执行时间如何增长）和空间复杂度（随着输入规模增加，内存使用量如何增长）。它通常用(O(1))、(O(n))、(O(n log n)) 或 (O(n²)) 等术语来表示，其中 (n) 是输入的大小。因此，当开发人员谈论代码是否“高效”或“可扩展”时，他们通常指的是这些大 O 值，旨在确保他们的软件在处理更多数据时仍然具有良好的性能，采用具有较低时间和空间复杂度的算法。

此外，由于 ID 应该是唯一的，它们并不是很适合在页面上使用多个可重用组件。这就是 querySelector 发挥作用的地方，因为它可以用来选择具有相同类名的多个元素，例如。

话虽如此，querySelector 可以接受各种 CSS 选择器，因此它的复杂性是可变的。在最坏的情况下，方法可能需要遍历整个 DOM 来确保匹配或不存在匹配项，其复杂性可能为 (O(n))，其中 (n) 是 DOM 中的元素数量。然而，对于更具体的选择器或者如果在 DOM 树的早期找到匹配项，实际运行时可能小于 (O(n))。

值得注意的是，在小型文档或者在文档树的特定区域中搜索元素时，document.getElementById 和 document.querySelector 之间的性能差异可能可以忽略不计。然而，在更大更复杂的文档中，这种差异可能变得更加明显。

有些人可能会说整个“CPU 效率”论点被夸大了，而且不值得担心。虽然这可能是真的，也可能不是，但没有人可以否认 React 的虚拟 DOM 提供的额外价值，它能够组件化逻辑，并避免在 DOM 这样一个易变的环境中管理状态。我们说 DOM 是易变的，因为它受到很多因素的影响，包括用户交互、网络请求、客户端脚本和其他可能随时导致其更改的事件。通过虚拟 DOM，React 保护我们免受这种环境的影响。

我们深入探讨这些微妙的细节，是因为要真正熟练地掌握 React，了解 DOM 的整体复杂性至关重要。明智地使用 DOM 并不是一件小事，而有了 React，我们可以选择是自己在这个雷区里航行，偶尔踩到地雷，还是使用一个能够通过虚拟 DOM 安全地浏览 DOM 的工具。

虽然我们在这里讨论了如何选择元素的一些小细节，但我们还没有机会深入探讨直接操作 DOM 的缺陷。让我们快速地做一下这个，以充分理解 React 虚拟 DOM 提供的价值。

### 真实 DOM 的缺陷

真实 DOM 存在几个缺陷，可能会使构建高性能 Web 应用程序变得困难。其中一些缺陷包括性能问题、跨浏览器兼容性和安全漏洞，直接操作 DOM 可能会导致跨站脚本（XSS）漏洞。

#### 性能

真实 DOM 的最大问题之一是性能。每当对 DOM 进行更改时，比如添加或移除元素，或更改元素的文本或属性，浏览器都必须重新计算布局并重新绘制页面的受影响部分。这可能是一个缓慢且资源密集的过程，特别是对于大型和复杂的网页而言。
正如前面提到的，读取 DOM 元素的 offsetWidth 属性可能看起来是一个简单的操作，但实际上可能会触发浏览器进行昂贵的布局重新计算。这是因为 offsetWidth 是一个计算属性，依赖于元素及其祖先的布局，这意味着浏览器需要确保布局信息是最新的，然后才能返回准确的值。
在最糟糕的情况下，使用大 O 表示法读取元素的 offsetWidth 属性可能估算为（O(n)）。这是因为访问此属性可能会触发浏览器进行重新布局，这涉及重新计算页面上多个元素的布局位置。在这种情况下，（n）表示受重新布局影响的 DOM 元素数量。即使直接属性访问很快，但相关的副作用，如重新布局，可能会使操作随着页面上元素数量的增加而扩展。

如果你想避免像 offsetWidth 这样的布局属性触发重排，我们可以采用一些技巧来提高性能。下面是一种方法，使用 getBoundingClientRect() 方法，它可以批量读取和写入布局：

```js
// Accessing layout properties in a more performant way
function getOffsetWidthWithoutTriggeringReflow(element) {
  let width;
  // Batch all reading operations
  const rect = element.getBoundingClientRect();
  width = rect.width;
  // ... any other reading operations
  // Followed by writing operations, if any
  return width;
}
const element = document.querySelector(".myElement");
const width = getOffsetWidthWithoutTriggeringReflow(element);
console.log(width);
```

通过使用 getBoundingClientRect()，我们可以在单个调用中检索多个布局属性，减少触发多次重排的机会。此外，通过分别批处理读取和写入操作，我们可以进一步最小化布局抖动，即由频繁交错读写布局属性而引起的重复和不必要的布局重新计算（见图3-1）。这种抖动会显著降低网页的性能，导致用户体验迟缓。通过战略性地访问布局属性和批处理我们的操作，我们可以保持网页交互的流畅和响应。

然而，即使使用 getBoundingClientRect()，如果存在待处理的布局更改，仍可能会触发重排。在这里，性能的关键是尽量减少强制浏览器重新计算布局的次数，并且在这样做时，尽量一次性获取尽可能多的信息。

React 使用虚拟 DOM 作为真实 DOM 操作之间的中间层，从而为我们处理了所有这些问题。

考虑以下示例，其中包含一个简单的 HTML 文档，其中有一个 div 元素：



一般来说，我们在读取类似 offsetWidth 这样依赖布局的属性时要小心，因为它们可能导致意想不到的性能问题。如果我们需要多次读取这些属性的值，我们应该考虑将值缓存到一个变量中，以避免触发不必要的布局重新计算。或者，我们可以使用 requestAnimationFrame API 将属性的读取推迟到下一个动画帧，这时浏览器已经执行了必要的布局计算。

为了更深入了解实际 DOM 中可能出现的性能问题，让我们看一些例子。考虑以下 HTML 文档：

#### 跨浏览器兼容性

另一个实际 DOM 的问题是跨浏览器兼容性。不同的浏览器以不同的方式对文档进行建模，这可能导致网页应用程序中的不一致性和 bug。当 React 发布时，这种情况更为常见，但现在已经不那么常见了。尽管如此，这仍然可能使开发人员难以创建在不同浏览器和平台上无缝运行的 web 应用程序。
跨浏览器兼容性的主要问题之一是某些 DOM 元素和属性可能不被所有浏览器支持。因此，我们不得不花费额外的时间和精力来实现解决方案和回退，以确保应用程序在所有目标平台上正确运行。
这正是 React 使用其合成事件系统解决的问题。SyntheticEvent 是对浏览器原生事件的封装，旨在确保在不同浏览器之间的一致性。它使用以下机制解决浏览器之间的不一致性：

*统一接口*

在原始的 JavaScript 中，处理浏览器事件可能会很棘手，因为存在不一致性。例如，访问事件属性可能在不同的浏览器中有所不同。有些可能使用 event.target，而其他浏览器可能使用 event.srcElement。SyntheticEvent 抽象了这些差异，提供了一种一致的方式来与事件交互，并确保开发人员不必编写特定于浏览器的代码。

通过将原生事件包装到 SyntheticEvent 系统中，React 屏蔽了许多原生浏览器事件系统的不一致性和怪异之处，使开发人员更容易处理事件。

*事件委托*
React 不直接将事件侦听器附加到元素上，而是在根级别监听事件。这种方法避开了一些事件在旧版浏览器中可能不可用的元素问题。

*跨功能增强*
原生浏览器事件在处理不同输入元素上的某些事件时存在不一致性是一个领域。一个显著的例子是 onChange 事件：

*访问原生事件*
如果开发人员需要原始的浏览器事件，可以通过 event.nativeEvent 获取，这样既保证了灵活性，又不损失抽象带来的好处。

本质上，SyntheticEvent 提供了一个稳定的事件系统，消除了原生浏览器事件的怪癖和差异。这只是 React 利用其虚拟 DOM 为 UI 开发提供便利的一种具体方式。到目前为止，我们一直在讨论直接使用 DOM 可能导致性能问题和跨浏览器兼容性问题。现在让我们探讨一种更高效的原生方法，通过使用文档片段来解决这些问题，文档片段可以被视为对理解 React 虚拟 DOM 的一种原生先导。

### Document Fragments  

正如我们所见，直接操作 DOM 可能会对性能造成影响，特别是涉及多个更改时。每次更新 DOM，浏览器都可能需要执行布局重新计算、重新绘制 UI 并更新视图，这可能会减慢应用程序的速度。这就是文档片段的用武之地。

文档片段是一个轻量级容器，用于保存 DOM 节点。它就像一个临时的暂存区，您可以在其中进行多个更改而不影响主 DOM。完成后，您可以将文档片段附加到 DOM，触发一次回流和重绘。

从这个角度看，文档片段与 React 的虚拟 DOM 非常接近。因为文档片段是轻量级容器，允许我们批量更新，所以它们具有多个性能优势：

批量更新：

将所有更改批量处理到一个文档片段中，而不是对实时 DOM 进行多个单独的更新。这意味着，无论您在片段内进行了多少元素或更改，只会发生一次回流和重绘。

内存效率：

当节点添加到文档片段时，它们会从 DOM 中的当前父节点中移除。这有助于优化内存使用，特别是在重新排序大型文档部分时。

没有冗余渲染：

由于文档片段不是活动文档树的一部分，对其进行的更改不会影响实时文档，并且样式和脚本直到片段附加到实际 DOM 之后才会应用。这避免了冗余的样式重新计算和脚本执行。

考虑这样一个场景，您需要向列表中添加多个列表项：

```js
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const li = document.createElement("li");
  li.textContent = `Item ${i + 1}`;
  fragment.appendChild(li);
}
document.getElementById("myList").appendChild(fragment);
```

在这个示例中，首先将100个列表项添加到文档片段中。只有在所有项目都添加完毕后，片段才会附加到主列表中。这样一来，实际的 DOM 只需进行一次更新，而不是 100 次单独的更新。

通过这种方式，文档片段提供了一种有效地操作 DOM 的方法，将多个更改批量处理在一起，从而减少了昂贵的回流和重绘的次数。对于追求在其 Web 应用程序中获得最佳性能的开发人员来说，利用文档片段可以实现更流畅的交互和更快的渲染时间。

React 的虚拟 DOM 可以类比为文档片段概念的高级实现。以下是简要的关联：

批量更新

类似于文档片段，React 的虚拟 DOM 将多个更改一起批处理。React 不会在每次状态或属性更改时直接修改实时 DOM，而是首先在虚拟 DOM 中编译这些更改。

高效的差异比较

然后，React 确定当前虚拟 DOM 与实际 DOM 之间的差异（或“diffs”）。这个差异比较过程确保只对实际 DOM 进行必要的更改，类似于文档片段如何减少直接 DOM 操作。

单一渲染

一旦识别出差异，React 就会以单个批次更新实际 DOM，就像附加一个完全填充的文档片段一样。这最小化了昂贵的回流和重绘。

实质上，虽然文档片段提供了一种在更新实时 DOM 之前对一组更改进行分组和优化的方法，但React的虚拟 DOM 更进一步，通过智能差异比较和批处理更新整个应用程序的用户界面，确保渲染效率最大化。

此外，React将所有这些文档片段的内容转化为一个实现细节，我们作为日常开发人员无需过多关注，从而使我们能够更专注地构建我们的产品。因此，让我们详细了解虚拟 DOM 的工作原理。

## 虚拟 DOM 的工作原理

虚拟 DOM 是一种技术，有助于减轻真实 DOM 的缺点。通过在内存中创建 DOM 的虚拟表示，可以对虚拟表示进行更改，而不直接修改真实 DOM，类似于文档片段。这使得框架或库可以以更高效和性能更好的方式更新真实 DOM，而无需让浏览器重新计算页面的布局并重新绘制元素。

虚拟 DOM 还通过提供一致的 API 抽象，消除了不同浏览器对真实 DOM 实现的差异，从而改善了元素及其更新的编写体验。例如，如果在另一个运行时中 `document.appendChild` 的行为有所不同，在使用 JSX 和虚拟 DOM 时就不会有影响。这使得开发人员更容易创建在不同浏览器和平台上无缝运行的 Web 应用程序。

React 使用虚拟 DOM 来构建用户界面。在本节中，我们将探讨 React 实现虚拟 DOM 的工作原理。

### React Elements  

在 React 中，用户界面被表示为一棵 React 元素树，它们是组件或 HTML 元素的轻量级表示。它们使用 React.createElement 函数创建，并可以嵌套以创建复杂的用户界面。
以下是一个 React 元素的示例：

```js
const element = React.createElement(
  "div",
  { className: "my-class" },
  "Hello, world!"
);
```

这将创建一个表示具有类名为 my-class 和文本内容为 Hello, world! 的 <div> 元素的 React 元素。
如果我们使用 console.log(element) ，我们可以看到实际创建的元素，它如下所示：

```js
{
  $$typeof: Symbol(react.element),
  type: "div",
  key: null,
  ref: null,
  props: {
    className: "my-class",
    children: "Hello, world!"
  },
  _owner: null,
  _store: { }
}
```

这是一个 React 元素的表示。React 元素是 React 应用程序的最小构建块，它们描述了屏幕上应该显示什么。每个元素都是一个简单的 JavaScript 对象，描述了它所代表的组件，以及任何相关的 props 或属性。
代码块中显示的 React 元素表示为一个具有几个属性的对象：

### Virtual DOM Versus Real DOM  

React 中的虚拟 DOM 在概念上与真实 DOM 类似，都表示元素的树状结构。当渲染 React 组件时，React 创建一个新的虚拟 DOM 树，将其与先前的虚拟 DOM 树进行比较，并计算更新旧树以匹配新树所需的最小更改数。这被称为协调过程。以下是一个演示 React 组件中这一过程可能如何工作的示例：

### Efficient Updates  

当 React 组件的状态或 props 发生变化时，React 会创建一个新的 React 元素树，表示更新后的用户界面。然后，将此新树与先前的树进行比较，以确定使用差分算法更新真实 DOM 所需的最小更改集。

这个算法比较新的 React 元素树与先前的树，并识别两者之间的差异。这是一个递归比较。如果节点已更改，React 就会更新真实 DOM 中对应的节点。如果节点已添加或删除，React 就会在真实 DOM 中添加或删除相应的节点。

差分涉及逐个比较新树和旧树的节点，以找出树的哪些部分发生了变化。

React 的差分算法经过高度优化，旨在最小化需要对真实 DOM 进行的更改数量。该算法的工作原理如下：

- 如果两个树的根级节点不同，React 将用新树替换整个树。
- 如果根级节点相同，React 将更新节点的属性（如果已更改）。
- 如果一个节点的子节点不同，React 将只更新已更改的子节点。React 不会重新创建整个子树；它只会更新已更改的节点。
- 如果一个节点的子节点相同，但它们的顺序已更改，React 将在真实 DOM 中重新排序节点，而不实际重新创建它们。
- 如果从树中移除了一个节点，React 将从真实 DOM 中移除它。
- 如果树中添加了新节点，React 将把它添加到真实 DOM 中。
- 如果节点的类型已更改（例如，从 div 变为 span），React 将删除旧节点并创建新类型的新节点。
- 如果节点具有 key 属性，React 将使用它来确定是否应替换节点。在需要重置组件状态时，这可能很有用。

React 的差异算法高效，使 React 能够快速更新真实 DOM，并进行最小程度的更改。这有助于提高 React 应用程序的性能，并使构建复杂、动态用户界面变得更加容易。

**不必要的重新渲染**
虽然 React 的差异算法确实在通过最小化所需的更改来高效地更新真实 DOM 方面发挥着关键作用，但开发者可能会遇到一个常见的挑战：不必要的重新渲染。
这是 React 的设计方式：当组件的状态发生变化时，React 重新渲染该组件及其所有后代组件。重新渲染意味着 React 递归调用每个函数组件，将每个函数组件的 props 作为参数传递。React 不会跳过那些 props 没有改变的组件，而是调用所有函数组件，这些函数组件是状态或 props 发生变化的父组件的子组件。这是因为 React 不知道哪些组件依赖于发生变化的组件的状态，因此它必须重新渲染所有组件，以确保 UI 保持一致。
这可能会带来一些重大的性能挑战，特别是当处理大型和复杂的用户界面时。例如，在下面的代码片段中，即使传递给 ChildComponent 的 props 没有变化，ChildComponent 每次 ParentComponent 的状态发生变化时都会重新渲染：

```jsx
import React, { useState } from "react";
const ChildComponent = ({ message }) => {
  return <div>{message}</div>;
};
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ChildComponent message="This is a static message" />
    </div>
  );
};
export default ParentComponent;
```

在这个例子中：

- ParentComponent 有一个名为 count 的状态变量，每次点击按钮时增加一次。
- ChildComponent 接收一个名为 message 的静态 prop。由于这个 prop 不会变化，理想情况下，我们不希望每次 ParentComponent 的状态变化时都重新渲染 ChildComponent。
- 然而，由于 React 的默认行为，ChildComponent 将会在每次 ParentComponent 重新渲染时重新渲染，而这种重新渲染会在每次状态变化时发生。
- 这是低效的，因为 ChildComponent 并不依赖于来自 ParentComponent 的 count 状态。
- 由于 ChildComponent 的 props 和状态没有变化，渲染是没有意义的：它很可能返回与上次相同的结果，因此这是一种浪费。

这个问题是我们经常需要优化的，尤其是在大型应用程序中，许多组件可能会不必要地重新渲染，从而导致潜在的性能问题。解决这个问题需要一种周全的方法来管理组件的重新渲染，确保组件层次结构中更高层级的状态或属性更改不会导致子孙组件的广泛且不必要的重新渲染。通过精心构建组件并合理使用 React 的优化功能（例如 memo 和 useMemo），开发人员可以更好地管理重新渲染并保持应用程序的高性能。

我们将在第 5 章更详细地介绍这一点。

## 本章回顾

在本章中，我们探讨了 Web 开发中真实 DOM 和虚拟 DOM 的区别，以及在 React 中使用虚拟 DOM 的优势。

我们首先讨论了真实 DOM 的局限性，例如缓慢的渲染时间和跨浏览器兼容性问题，这些问题会使开发人员难以创建在不同浏览器和平台上无缝运行的 Web 应用程序。为了说明这一点，我们研究了如何使用真实 DOM API 创建一个简单的网页，以及随着页面复杂性的增加，这些 API 如何很快变得难以控制和管理。

接下来，我们深入研究了虚拟 DOM 以及它如何解决真实 DOM 的许多局限性。 我们探讨了 React 如何利用虚拟 DOM 通过最小化对真实 DOM 所需的更新次数来提高性能，这在渲染时间方面可能代价高昂。 我们还研究了 React 如何使用元素将虚拟 DOM 与先前版本进行比较并计算更新真实 DOM 的最有效方法。

为了说明虚拟 DOM 的优势，我们研究了如何使用 React 组件创建相同的简单网页。 我们将这种方法与真实 DOM 方法进行了比较，并发现即使页面复杂性增加，React 组件也更加简洁易于管理。

我们还研究了 React.createElement 和 document.createElement 之间的区别，并且我们看到了如何使用 JSX 创建组件，JSX 提供了类似于 HTML 的语法，使推理虚拟 DOM 的结构更加容易。

最后，我们研究了 React 的差异算法如何导致不必要的重新渲染，这可能是一个重大的性能挑战，尤其是在处理大型复杂的用户界面时。我们提到了第 5 章，我们将探讨如何通过使用 React 的 memo 和 useMemo 功能来优化这一点。

总而言之，我们学习了在 Web 开发中使用虚拟 DOM 的优势，以及 React 如何利用这一概念使构建 Web 应用程序更加轻松高效。

# 第4章 深入解析Reconciliation

为了真正熟练地使用 React，我们需要理解其功能的运作方式。到目前为止，我们已经理解了 JSX 和 React.createElement，同时也对虚拟 DOM 有了一定程度的了解。本章我们将探讨虚拟 DOM 在 React 中的实际应用，并理解 ReactDOM.createRoot(element).render() 的作用。

具体而言，我们将探讨 React 如何构建其虚拟 DOM，然后通过称为协调的过程更新真实 DOM。

## 理解协调

简单回顾一下，React 的虚拟 DOM 是我们期望的 UI 状态的蓝图。React 通过称为协调的过程，将这个蓝图转化为给定宿主环境（通常是网页浏览器，但也有可能是其他环境，例如 shell、iOS 和 Android 等原生平台等）的现实。

请考虑以下代码片段：

该代码片段表示来自我们 Counter 组件的虚拟 DOM。由于这是第一次渲染，因此现在使用对命令式 DOM API 的最少调用将此树提交给浏览器。React 如何确保最少调用命令式 DOM API？它通过将虚拟 DOM 更新批量成一个真实的 DOM 更新来实现这一点，并且出于之前章节讨论的原因，尽可能少地接触 DOM。让我们更深入地研究这一点以全面理解批处理。

可以!  Here's the translation of the text in bold:

## **批处理 (Batching)**

在第三章中，我们讨论了浏览器 DOM 内置 API 的文档片段：轻量级的容器，可容纳一系列 DOM 节点，充当临时的中转站，您可以在其中进行多次更改，而不会影响主 DOM，直到您最终将文档片段附加到 DOM，从而触发单次回流和重绘。

类似地，React 在协调过程中会批量更新真实 DOM，将多个虚拟 DOM 更新合并成单个 DOM 更新。这减少了必须更新真实 DOM 的次数，因此可以提高 Web 应用程序的性能。

为了理解这一点，让我们考虑一个组件，它在短时间内多次更新其状态：

```jsx
function Example() {
  const [count, setCount] = useState(0);
  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
  };
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

在这个例子中，`handleClick` 函数连续三次调用 `setCount`。如果没有批处理，React 将会分别三次更新真实 DOM，尽管 `count` 的值只改变了一次。这将是低效且慢速的。

然而，由于 React 批处理更新，它只会一次更新真实 DOM，使得 `count` 的值为 `count + 3`，而不是每次都单独更新三次真实 DOM，使得 `count` 的值分别为 `count + 1`。

为了计算最有效的批处理更新到 DOM，React 将创建一个新的虚拟 DOM 树，作为当前虚拟 DOM 树的分支，其中 `count` 为 3。这个树需要与当前在浏览器中的内容进行协调，将 0 转换为 3。然后，React 将计算出只需一次更新到 DOM，使用新的虚拟 DOM 值 3，而不是手动三次更新 DOM。这就是批处理的作用，它是我们即将深入探讨的更广泛主题的一部分：协调，或者将下一个预期的 DOM 状态与当前 DOM 进行协调的过程。

在我们了解现代 React 在幕后执行的操作之前，让我们探讨一下 React 在 16 版本之前使用的协调过程，使用了传统的“栈”协调器。这将有助于我们理解为什么需要当今流行的 Fiber 协调器。

## 传统方法

之前，React 使用堆栈数据结构进行渲染。为了确保我们理解一致，让我们简要讨论一下堆栈数据结构。

### 堆栈协调器 (传统)

在计算机科学中，堆栈是一种遵循后进先出 (LIFO) 原则的线性数据结构。这意味着添加到堆栈的最后一个元素将是第一个被移除的元素。堆栈具有两个基本操作：push 和 pop，分别允许添加和删除堆栈顶部的元素。

堆栈可以可视化成一个垂直排列的元素集合，最顶端的元素是最近添加的元素。下面是包含三个元素的堆栈的 ASCII 图示：

```
+---+
| 3  |
+---+
| 2  |
+---+
| 1  |
+---+ (栈底)
```


React 的原始协调器是一种基于堆栈的算法，用于比较旧的和新的虚拟树并相应地更新 DOM。

虽然堆栈协调器在简单的情况下效果良好，但随着应用程序规模和复杂性的增长，它会带来许多挑战。让我们快速看一下为什么会这样。为此，我们将考虑一个示例，其中我们有一些更新要做：

1. 一个非必要的计算密集型组件会消耗 CPU 并进行渲染。
2. 用户在输入元素中键入内容。
3. 如果输入有效，按钮变为可用。
4. 包含的 Form 组件保存状态，因此它会重新渲染。

用代码表示，我们可以这样写：

在这种情况下，堆栈协调器会按顺序渲染更新，而无法暂停或延迟工作。如果计算密集型组件阻塞渲染，用户输入将在屏幕上显示明显的延迟。由于文本字段将无响应，这会导致糟糕的用户体验。相反，能够将用户输入识别为比渲染非必要的昂贵组件更高的优先级更新，并更新屏幕以反映输入，推迟渲染计算密集型组件会更加令人满意。

如果被更高优先级的渲染工作（例如用户输入）中断，则需要能够退出当前的渲染工作。为了做到这一点，React 需要对某些类型的渲染操作相对于其他操作具有优先级意识。

堆栈协调器不会对更新进行优先级排序，这意味着不太重要的更新可能会阻塞更重要的更新。例如，对工具提示的低优先级更新可能会阻塞对文本输入的高优先级更新。对虚拟树的更新按照接收顺序执行。

在 React 应用程序中，对虚拟树的更新可以具有不同的重要性级别。例如，表单输入的更新可能比显示帖子点赞数的指示器的更新更重要，因为用户直接与输入交互并期望它做出响应。

在堆栈协调器中，更新按照接收顺序执行，这意味着不太重要的更新可能会阻塞更重要的更新。例如，如果点赞计数器更新在表单输入更新之前收到，则点赞计数器更新将首先执行，并可能会阻塞表单输入更新。

如果点赞计数器更新花费很长时间才能执行（例如，因为它正在执行昂贵的计算），则可能导致用户界面出现明显的延迟或卡顿，尤其是在用户在更新期间与应用程序交互时。

堆栈协调器的另一个挑战是它不允许中断或取消更新。这意味着即使堆栈协调器能够识别更新优先级，也不能保证它可以通过在调度高优先级更新时放弃无关紧要的工作来很好地处理各种优先级。

在任何网络应用程序中，并非所有更新都生而平等：随机出现的意外通知并不像响应用户点击按钮那么重要，因为后者是需要立即反应的故意操作，而前者甚至不是预期的，甚至可能不受欢迎。

在堆栈协调器中，更新无法中断或取消，这意味着有时会以牺牲用户交互为代价进行不必要的更新，例如显示一个 toast 通知。这可能导致在虚拟树和 DOM 上执行不必要的工作，从而对应用程序的性能产生负面影响。

随着应用程序的规模和复杂性增长，堆栈协调器带来了一些挑战。主要挑战集中在用户界面卡顿和响应缓慢。为了解决这些挑战，React 团队开发了一种名为 Fiber 协调器的新型协调器，它基于一种称为 Fiber 树的不同数据结构。让我们在下一节探讨这种数据结构。

## Fiber 协调器

Fiber 协调器使用一种称为“Fiber”的不同数据结构，它表示协调器单个的工作单元。Fiber 由我们在第 3 章介绍的 React 元素创建，主要区别在于它们是有状态和长期存在的，而 React 元素是临时且无状态的。

Redux 的维护者和杰出 React 专家 Mark Erikson 将 Fiber 描述为“React 的内部数据结构，它表示某个时间点的实际组件树”。的确，这是一个思考 Fiber 的好方法，这对于 Mark 来说也恰到好处，他当时正使用 Replay 全职进行时间旅行调试 React 应用。Replay 是一个允许您倒带和重放应用程序状态进行调试的工具。如果您还没有，请查看 Replay.io了解更多信息。

类似于 vDOM 是一个元素树，React 在协调过程中使用 Fiber 树，顾名思义，它是一个直接仿照 vDOM 的 Fiber 树。

### 作为数据结构的 Fiber

React 中的 Fiber 数据结构是 Fiber 协调器的关键组件。Fiber 协调器允许对更新进行优先级排序并并发执行，从而提高 React 应用的性能和响应能力。让我们更详细地探讨 Fiber 数据结构。

本质上，Fiber 数据结构表示了 React 应用程序中的组件实例及其状态。正如讨论的那样，Fiber 数据结构被设计为一个可变实例，可以在协调过程中根据需要进行更新和重新排列。

每个 Fiber 节点的实例都包含有关其表示的组件的信息，包括其属性、状态和子组件。Fiber 节点还包含有关其在组件树中的位置的信息，以及 Fiber 协调器用于对更新进行优先级排序和执行的元数据。

下面是一个简单的 Fiber 节点的示例：

```
{
  tag: 3, // 3 = ClassComponent
  type: App,
  key: null,
  ref: null,
  props: {
    name: "Tejas",
    age: 30
  },
  stateNode: AppInstance,
  return: FiberParent,
  child: FiberChild,
  sibling: FiberSibling,
  index: 0,
  //...
}
```

这段代码返回一个从元素衍生的 Fiber。一旦创建了 Fiber 节点，Fiber 协调器就会使用工作循环来更新用户界面。工作循环从根 Fiber 节点开始，沿着组件树向下进行，如果需要更新，则将每个 Fiber 节点标记为“dirty”。一旦到达末端，它就会向上遍历，在内存中创建一个新的 DOM 树，该树与浏览器分离，并最终会提交（刷新）到屏幕上。这由两个函数表示：

- `beginWork`：向下遍历，将需要更新的组件标记为“need to update”。
- `completeWork`：向上遍历，构建一个与浏览器分离的真实 DOM 元素树。

这个离屏渲染过程可以随时被中断和丢弃，因为用户看不到它。

Fiber 架构的灵感来自游戏世界中的“双重缓冲”的概念，即在屏幕外准备下一帧，然后“刷新”到当前屏幕。为了更好地理解 Fiber 架构，在进行下一步之前，让我们先更详细地了解这个概念。

### 双缓冲

双缓冲是一种用于计算机图形和视频处理的减少闪烁并改善感知性能的技术。该技术涉及创建两个用于存储图像或帧的缓冲区（或内存空间），并在它们之间定期切换以显示最终图像或视频。

以下是双缓冲在实践中的工作方式：

1. 第一个缓冲区填充初始图像或帧。
2. 在显示第一个缓冲区的同时，第二个缓冲区会更新新数据或图像。
3. 当第二个缓冲区准备就绪时，它会与第一个缓冲区交换并显示在屏幕上。
4. 过程继续，第一个和第二个缓冲区会定期切换以显示最终图像或视频。

通过使用双缓冲，可以减少闪烁和其他视觉伪影，因为最终图像或视频的显示不会中断或延迟。

Fiber 协调类似于双缓冲，当更新发生时，当前的 Fiber 树会进行分叉并更新以反映给定用户界面的新状态。这称为渲染。然后，当备用树准备就绪并准确反映用户期望看到的状态时，它会像双缓冲中交换视频缓冲区一样与当前树交换。这称为协调的提交阶段或提交。

通过使用正在进行的工作树，Fiber 协调器提供了一些好处：

它可以避免对真实 DOM 进行不必要的更新，从而可以提高性能并减少闪烁。 它可以在屏幕外计算 UI 的新状态，并且如果需要进行更高优先级的更新，则可以丢弃它。 由于协调发生在屏幕外，它甚至可以在不影响用户当前所看到的内容的情况下暂停和恢复。

使用 Fiber 协调器，可以从用户定义的 JSX 元素树派生出两棵树：一棵树包含“当前”Fiber，另一棵树包含正在进行工作的 Fiber。让我们更详细地探索这些树。

### Fiber 协调

Fiber 协调分两个阶段进行：渲染阶段和提交阶段。如图 4-1 所示，这种两阶段方法允许 React 执行可以在任何时候丢弃的渲染工作，然后再将其提交到 DOM 并向用户显示新状态：它使渲染可中断。更详细地说，使渲染感觉可中断的原因是 React 调度程序使用的启发式方法，每 5 毫秒将执行权让回主线程，这甚至在 120 fps 的设备上也小于单个帧。

# 第5章 常见问题和强大模式

既然我们现在更了解 React 的功能以及其底层的工作原理，那么让我们更深入地探索它在编写 React 应用程序方面的实际应用。在本章中，我们将探讨常见 React 问题的答案，以提高我们围绕记忆、惰性加载和性能的流畅性。让我们从记忆化开始吧。

## 记忆化利用 React.memo

记忆化是一种计算机科学中用于优化函数性能的技术，通过缓存函数先前计算的结果来实现。简单来说，记忆化会根据函数的输入来存储其输出，这样如果再次使用相同的输入调用该函数，它将返回缓存的结果而不是重新计算输出。这可以显著减少执行函数所需的时间和资源，尤其对于计算量大或经常调用的函数。

记忆化依赖于函数的纯净性，即对于给定的输入，函数会可靠地返回相同的输出。纯函数的示例：

### 仍然会重新渲染的记忆化组件

React.memo 通过对组件的 props 进行浅比较来判断它们是否发生变化。问题在于，虽然标量类型可以在 JavaScript 中进行相当准确的比较，但非标量类型则不能。为了进行高质量的讨论，让我们简要分解一下标量类型和非标量类型是什么，以及它们在比较操作中的行为。

**标量类型 (原始类型)**

标量类型（也称为原始类型）是基础类型。这些类型表示单个的、不可分割的值。与数组和对象等更复杂的数据结构不同，标量类型没有属性或方法，并且本质上是不可变的。这意味着一旦设置标量值，就无法更改它，除非创建一个完全新的值。JavaScript 有几种标量类型，包括数字、字符串、布尔值以及其他一些类型，例如symbols、BigInt、undefined 和 null。每种类型都有其独特的作用。例如，数字不言自明，符号提供了一种创建唯一标识符的方法，undefined 和 null 允许开发人员在不同上下文中表示缺少值。比较标量值时，我们通常关心它们的内容或实际值。

**非标量类型（引用类型）**

超越标量的简单性，我们遇到了非标量类型或引用类型。这些类型不存储数据，而是存储一个引用或指针，指向数据在内存中的存储位置。这种区别至关重要，因为它会影响这些类型在代码中如何进行比较、操纵和交互。在 JavaScript 中，最常见的非标量类型是对象和数组。对象允许我们使用键值对存储结构化数据，而数组提供有序集合。函数在 JavaScript 中也属于引用类型。非标量的关键特征是多个引用可以指向相同的内存位置。这意味着通过一个引用修改数据会影响指向相同数据的其他引用。进行比较时，非标量类型是通过它们的内存引用进行比较，而不是通过它们的内容进行比较。对于不熟悉这种细微差别的人来说，这有时会导致意想不到的结果。例如，使用严格相等运算符比较时，具有相同内容但不同内存位置的两个数组将被视为不相等。

考虑以下示例：



React.memo 经常被另一种非标量类型——函数——绕过。考虑以下情况：

## Memoization with useMemo  

React.memo 和 useMemo 钩子都是用于记忆化的工具，但用途却截然不同。 React.memo 记忆化整个组件以防止其重新渲染。 useMemo 记忆化组件内部的特定计算，以避免昂贵的重新计算并保持结果的一致引用。

让我们快速看一下 useMemo。考虑一个组件：

### useMemo 被认为是有害的

虽然将组件内的所有变量声明都包装在 useMemo 中可能很诱人，但这并不总是有益的。useMemo 特别适用于对计算成本高昂的操作进行记忆化，或者维护对对象和数组的稳定引用。对于标量值，例如字符串、数字或布尔值，通常不需要使用 useMemo。这是因为这些标量值在 JavaScript 中是按照它们的实际值传递和比较的，而不是按照引用。因此，每次设置或比较标量值时，都是使用的实际值，而不是可能会更改的内存位置的引用。
在这些情况下，加载和执行 useMemo 函数可能比它试图优化的实际操作更昂贵。例如，考虑以下示例：

然而，可能会带来额外性能问题的是，由于该按钮的 onClick 处理程序每次渲染都会通过内存引用重新创建，这真的是问题吗？让我们仔细看看。

一些人建议使用 useCallback 来记忆化 onClick 处理程序：

```jsx
const MyComponent = () => {
  const [count, setCount] = useState(0);
  const doubledCount = useMemo(() => count * 2, [count]);
  const increment = useCallback(
    () => setCount((oldCount) => oldCount + 1),
    [setCount]
  );
  return (
    <div>
      <p>Count: {count}</p>
      <p>Doubled count: {doubledCount}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

我们应该这样做吗？答案是否定的。由于 `<button>` 是一个浏览器原生元素，而不是可以调用的 React 函数组件，因此让 increment 函数在这里被记忆化没有任何好处。而且，在其下面也没有 React 会继续渲染的其他组件。

此外，在 React 中，内置组件（或“主机”组件，例如 div、button、input 等）在处理属性（包括函数属性）方面与自定义组件略有不同。

以下是内置组件上的函数属性会发生什么：

**直接传递**

当您将函数属性（例如 onClick 处理程序）传递给内置组件时，React 会将它直接传递到实际的 DOM 元素。它不会创建任何包装器或对这些函数执行任何额外的工作。

然而，对于 onClick 和基于事件的属性，React 使用事件委托来处理事件，而不是将事件处理程序直接附加到 DOM 元素。这意味着当您向内置 React 元素（例如 `<button>`）提供 onClick 处理程序时，React 并不会将 onClick 处理程序直接附加到按钮的 DOM 节点上。

相反，React 使用单个事件监听器在顶层监听所有事件。该监听器附加到文档的根节点（或 React 应用程序的根节点），它依赖事件冒泡来捕获来自单个元素的事件。这种方法之所以高效，是因为它减少了内存占用和事件处理程序的初始设置时间。与其为每个元素上的每个事件实例附加和管理单独的处理程序，React 可以使用单个真正的事件监听器来处理所有特定类型的事件（例如点击）。

当事件发生时，React 会将其映射到适当的组件，并按照预期的传播路径调用您定义的处理程序。因此，即使事件在顶层被捕获，它们的行为也会像直接附加到特定元素上一样。这种事件委托系统在您编写 React 应用时几乎是透明的；您可以像直接附加它们一样定义 onClick 处理程序。然而，在底层，React 会为您优化事件处理。

**重新渲染行为**

内置组件不会因函数属性更改而重新渲染，除非它们是已经重新渲染的高层组件的一部分。例如，如果父组件重新渲染并向内置组件提供了一个新的函数作为属性，则内置组件会因为其属性已更改而重新渲染。但是，这种重新渲染通常很快，而且通常不需要优化，除非配置文件显示它是一个问题。

虚拟 DOM 不比较函数

内置组件的虚拟 DOM 比较基于函数属性的标识。如果您传递一个内联函数（例如 onClick={() => doSomething()}`），它每次组件渲染时都会是一个新函数，但 React 不会对函数进行深度比较来检测更改。新函数只是简单地替换 DOM 元素上的旧函数，因此我们通过内置组件获得了性能提升。

**事件池**

React 使用事件池来减少事件处理程序的内存开销。传递给事件处理程序的事件对象是一个合成的事件，它被池化，这意味着它可以用于不同的事件以减少垃圾回收开销。

这与自定义组件形成了鲜明对比。对于自定义组件，如果您传递一个新函数作为属性，子组件可能会重新渲染，如果它是一个纯组件或者应用了记忆化（例如使用 React.memo），因为它检测到属性的变化。但是对于主机组件，React 不提供这种内置的记忆化，因为它在大多数情况下会增加额外的开销，而这些开销并没有益处。React 输出的实际 DOM 元素没有记忆化概念；它们只是在属性更改时使用新的函数引用进行更新。

在实践中，这意味着虽然您应该谨慎地向可能需要大量重新渲染的自定义组件传递新的函数实例，但对于内置组件这样做则不用太担心。然而，经常创建新函数并四处传递它们始终是一个需要注意的问题，因为不必要的函数创建可能会导致垃圾回收 churn，这在非常高频的更新场景中可能成为性能问题。

因此，useCallback 在这里根本没有帮助，实际上比没有用还糟糕：它不仅没有任何价值，还会给我们的应用程序增加开销。这是因为 useCallback 需要被导入、调用并传递依赖项，然后它必须比较依赖项来查看是否应该重新计算函数。所有这些都具有运行时复杂性，可能会损害我们的应用程序而不是帮助它。

那么 useCallback 的一个好例子是什么呢？useCallback 在以下情况特别有用：当您有一个组件可能经常重新渲染，并且向下传递回调给子组件时，尤其是在子组件使用 React.memo 或 shouldComponentUpdate 进行优化的情况下。回调的记忆化确保子组件在父组件渲染时不会不必要地重新渲染。

下面是一个 useCallback 有益的例子：

```jsx
import React, { useState, useCallback } from "react";

const ExpensiveComponent = React.memo(({ onButtonClick }) => {
  // This component is expensive to render and we want
  // to avoid unnecessary renders
  // We're just simulating something expensive here
  const now = performance.now();
  while (performance.now() - now < 1000) {
    // Artificial delay -- block for 1000ms
  }
  return <button onClick={onButtonClick}>Click Me</button>;
});

const MyComponent = () => {
  const [count, setCount] = useState(0);
  const [otherState, setOtherState] = useState(0);
  // This callback is memoized and will only change if count changes
  const incrementCount = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []); // Dependency array// This state update will cause MyComponent to rerender
  const doSomethingElse = () => {
    setOtherState((s) => s + 1);
  };
  return (
    <div>
      <p>Count: {count}</p>
      <ExpensiveComponent onButtonClick={incrementCount} />
      <button onClick={doSomethingElse}>Do Something Else</button>
    </div>
  );
};
```

在这个例子中：

- `ExpensiveComponent` 是一个子组件，被包裹在 `React.memo` 中，这意味着它只有在其属性改变时才会重新渲染。这是一种你想避免在每次渲染的时候传递一个新的函数实例的情况。
- `MyComponent` 有两部分状态：`count` 和 `otherState`。
- `incrementCount` 是一个更新 `count` 的回调函数。它被 `useCallback` 记忆化，这意味着当 `MyComponent` 由于 `otherState` 的变化而重新渲染时，`ExpensiveComponent` 不会重新渲染。
- `doSomethingElse` 函数改变了 `otherState`，但不需要用 `useCallback` 记忆化，因为它没有被传递给 `ExpensiveComponent` 或其他子组件。

通过使用 `useCallback`，我们确保了 `ExpensiveComponent` 在 `MyComponent` 因为与 `count` 无关的原因重新渲染时，不会不必要地重新渲染。在子组件的渲染是一个耗时的操作，你想通过减少渲染次数来优化性能的情况下，这是很有益的。

这是一个如何使用 `useCallback` 来避免不必要的重新渲染的好例子，它确保传递给高成本组件的函数只被创建一次，并且在重新渲染中保留相同的引用。这可以防止高成本组件不必要的重新渲染。

`useCallback` 本质上就是用于函数的 `useMemo`。

让我们看另一个例子：



在这种情况下，我们不应该使用 useMemo，因为它比加速应用程序运行速度更可能会使其变慢，原因在于 useMemo 本身的开销，包括导入它、调用它、传递依赖项，然后比较依赖项以查看是否应该重新计算值。所有这些都具有运行时复杂性，可能会损害我们的应用程序而不是帮助它。

取而代之，我们分配并信任 React 在必要时使用其自己的优化智能地重新渲染我们的组件。

即使面对繁重的计算，我们的应用程序现在也享受着更快重新渲染的性能优势 - 但我们还能做更多吗？在下一节中，让我们来看看我们到目前为止涵盖的所有内容，根据 React 团队正在为我们自动考虑记忆化的一些令人兴奋的功能，这些内容在几年内可能都无关紧要，使我们能够忘记细节，而是专注于我们的应用程序。

## 懒加载

幸运地，React 提供了一种解决方案让这变得更加简单：使用 React.lazy 和 Suspense 进行懒加载。让我们来看看如何使用它们来提高应用程序的性能。

懒加载是一种仅在需要时才加载组件的技巧，就像之前示例中的动态导入一样。这对于拥有许多组件的大型应用程序非常有用，这些组件在初始渲染时并不是必需的。例如，如果我们有一个带有可折叠侧边栏的大型应用程序，该侧边栏包含指向其他页面的链接列表，那么我们可能不希望在首次加载时加载完整的侧边栏。相反，我们可以在用户切换侧边栏时才加载它。

让我们来看看下面的代码示例：

```jsx
import Sidebar from "./Sidebar"; // 22MB to import
const MyComponent = ({ initialSidebarState }) => {
  const [showSidebar, setShowSidebar] = useState(initialSidebarState);
  return (
    <div>
      <button onClick={() => setShowSidebar(!showSidebar)}>
        Toggle sidebar
      </button>
      {showSidebar && <Sidebar />}
    </div>
  );
};
```

在这个例子中，<Sidebar /> 有 22MB 的 JavaScript 代码。这需要下载、解析和执行大量的 JavaScript 代码，而且如果侧边栏在初始渲染时是折叠的，那么这部分代码就不是必需的。我们可以使用 React.lazy 来懒加载组件，只有在 showSidebar 为 true 的情况下才加载它。换句话说，只有在需要它的时候才加载。

```jsx
import { lazy, Suspense } from "react";
import FakeSidebarShell from "./FakeSidebarShell"; // 1kB to import

const Sidebar = lazy(() => import("./Sidebar"));

const MyComponent = ({ initialSidebarState }) => {
  const [showSidebar, setShowSidebar] = useState(initialSidebarState);
  return (
    <div>
      <button onClick={() => setShowSidebar(!showSidebar)}>
        Toggle sidebar
      </button>
      <Suspense fallback={<FakeSidebarShell />}>
        {showSidebar && <Sidebar />}
      </Suspense>
    </div>
  );
};
```

### 更大的 UI 控件 - 使用 Suspense

React Suspense 的工作方式类似于 try/catch 块。正如您可以在代码中的任何地方抛出异常，然后在其他地方（甚至不同的模块）使用 catch 块捕获它一样，Suspense 的工作方式也类似（但并不完全相同）。您可以将懒加载和异步原语放置在组件树中的任何位置，然后在树中任何高于它的位置使用 Suspense 组件来捕获它们，即使您的 Suspense 边界位于完全不同的文件中。

了解了这一点，我们就可以选择在何处显示 22MB 侧边栏的加载状态。例如，我们可以隐藏整个应用程序，同时加载侧边栏 - 这并不是一个好主意，因为仅仅为了加载侧边栏就阻止了用户查看整个应用程序的信息。或者，我们只显示侧边栏的加载状态。让我们看一下如何做到前者（尽管我们不应该这样做），只是为了理解 Suspense 的功能：



Suspense boundary  是一个非常强大的原语，可以修复布局错位并使用户界面更具响应性和直观性。它是你编程工具箱中的一个好帮手。此外，如果在回退中使用高质量的骨架 UI，我们可以进一步引导用户理解正在发生什么以及在我们的懒加载组件加载时会看到什么，从而在界面准备就绪之前引导他们熟悉即将交互的界面。充分利用所有这些都是改善应用程序性能并流畅地充分利用 React 的绝佳方式。

接下来，我们将探讨另一个许多 React 开发人员会问的有趣问题：我们应该何时使用 useState 和 useReducer？

## useState Versus useReducer  

有趣的事实：useState 内部使用了 useReducer。你可以将 useState视为 useReducer 的一个更高级的抽象。事实上，如果你愿意，你可以使用 useReducer 来重新实现 useState！

说真的，你只要做以下这些事：

```jsx
import { useReducer } from "react";

function useState(initialState) {
  const [state, dispatch] = useReducer(
    (state, newValue) => newValue,
    initialState
  );
  return [state, dispatch];
}
```

现在，有些人可能会说 useReducer 比 useState 更冗长，许多人会同意这一点。但是这种现象是可以预期的，因为当人们在抽象层级上更低一层时就会发生这种情况：越低层的抽象，代码就越冗长。毕竟，在大多数情况下，抽象是为了用语法糖替代复杂逻辑。既然我们可以使用 useState 做到和 useReducer 一样的事情，为什么不用更简单的 useState 呢？

为了回答这个问题，使用 useReducer 有三个巨大的好处：

1. 它将更新 state 的逻辑与组件分离。 它附带的 reducer 函数可以单独测试，并且可以在其他组件中重用。 这是一种保持组件清洁简单并遵循单一职责原则的好方法。
我们可以这样测试 reducer 函数：



使用 useReducer，我们的状态及其变化方式始终是显式的，有些人会争辩说 useState 可以通过 JSX 树的层层嵌套使组件的整体状态更新流程变得模糊不清 (obfuscate)。



虽然 useReducer 是一个非常棒的工具，但它并不是总是必要的。事实上，对于大多数用例来说，它都有些过犹不及 (overkill)。那么我们应该什么时候使用 useState 和 useReducer 呢？答案取决于你的状态复杂性。但希望通过所有这些信息，你可以对你应该在应用程序中使用哪一个做出更明智的决定。

### Immer and Ergonomics  

在你的应用中处理复杂的状态管理时，Immer 这个流行的 React 库会特别有用。当你的状态结构嵌套或复杂时，传统的 state 更新方法可能会变得冗长且容易出错。Immer 通过允许你使用可变的临时状态来管理这些复杂性，同时确保生成的最终 state 是不可变的，从而帮助简化管理过程。

在 React 应用中，状态管理通常使用 useState 或 useReducer 钩子来处理。useState 适用于简单状态，而 useReducer 更适合复杂状态管理，这也是 Immer 最能发挥作用的地方。

使用 useReducer 时，你提供的 reducer 函数应该是一个纯函数，并且总是返回一个新的 state 对象。这在处理嵌套的 state 对象时可能会导致代码冗长。然而，通过 use-immer 库提供的 useImmerReducer 将 Immer 与 useReducer 集成在一起，你可以编写看起来直接修改 state 的 reducer，而实际上它操作的是 Immer 提供的临时 state。通过这种方式，你可以编写更简洁、更直观的 reducer 函数：

```jsx
import { useImmerReducer } from "use-immer";
const initialState = {
  user: {
    name: "John Doe",
    age: 28,
    address: {
      city: "New York",
      country: "USA",
    },
  },
};
const reducer = (draft, action) => {
  switch (action.type) {
    case "updateName":
      draft.user.name = action.payload;
      break;
    case "updateCity":
      draft.user.address.city = action.payload;
      break;
    // other cases...
    default:
      break;
  }
};
const MyComponent = () => {
  const [state, dispatch] = useImmerReducer(reducer, initialState);
  // ...
};
```

在这个例子中，useImmerReducer 大大简化了 reducer 函数，允许直接赋值来更新嵌套的 state 属性，这在传统的 reducer 中需要使用展开运算符 (...) 或 Object.assign 操作来实现。

此外，Immer 不仅仅局限于 useReducer。只要遇到复杂的状态对象并且想要在更新 state 的时候确保其不可变性，你也可以将它与 useState 搭配使用。Immer 提供了一个 produce 函数，你可以用它基于当前状态和一系列指令来创建新的 state：

```jsx
import produce from "immer";
import { useState } from "react";

const MyComponent = () => {
  const [state, setState] = useState(initialState);
  const updateName = (newName) => {
    setState(
      produce((draft) => {
        draft.user.name = newName;
      })
    );
  };
  // ...
};
```

## Powerful Patterns  

好吧，让我们按照这些模式出现的大致时间顺序，深入研究一些流行的 React 模式。

### Presentational/Container Components  

由于这种解耦合的方式，我们拥有了更多选择。因此，容器/展示组件模式获得了相当高的流行度，并且至今仍在使用。然而，Hooks 的引入使将状态添加到组件中变得更加方便，而无需容器组件来提供该状态。

如今，在许多情况下，容器/展示模式可以用 Hooks 取代。虽然我们仍然可以使用这种模式，即使使用 React Hooks，在较小的应用程序中也可以很容易地将其视为过度工程 ( overengineering)。

### 高阶组件

**Composing HOCs**  

由于 React 组件是可重用的，我们可以通过将它们组合成更高级的组件来构建复杂的 UI. 这种模式称为 高阶组件 (Higher-Order Component (HOC))。HOC 本质上是一个函数，它接受一个组件作为参数，并返回一个新的组件。新组件将增强原始组件的功能。

在 React 中组合多个 HOC 是一个常见的模式，它允许开发人员混合和匹配组件的功能和行为。下面是如何组合多个 HOC 的示例：

假设你有两个 HOC，withLogging 和 withUser：



呃！一种更好的方法是创建一个实用函数，将多个 HOC 组合成一个单独的 HOC。这样的实用函数可能如下所示：

```jsx
// compose.js
const compose =
  (...hocs) =>
    (WrappedComponent) =>
      hocs.reduceRight((acc, hoc) => hoc(acc), WrappedComponent);
// Usage:
const EnhancedComponent = compose(withLogging, withUser)(MyComponent);
```

在这个 compose 函数中，reduceRight 用于从右向左地将每个 HOC 应用于 WrappedComponent。这样，你就可以将你的 HOC 列在一个扁平的列表中，这样更易于阅读和维护。compose 函数是函数式编程中常见的实用工具，Redux 等库也提供了用于此目的的 compose 实用函数。

为了用我们新的 compose 实用工具来回顾我们之前糟糕的例子，它看起来会更像这样：

```jsx
const EnhancedComponent = compose(
  withErrorHandler,
  withLoadingSpinner,
  withAuthentication,
  withAuthorization,
  withPagination,
  withDataFetching,
  withLogging,
  withUser,
  withTheme,
  withIntl,
  withRouting
)(MyComponent);
```

这样不是更好吗？ 更少的缩进，更高的可读性和更简单的维护。

链中的每个 HOC 都包装由先前 HOC 生成的组件，将自己的行为添加到混合体中。通过这种方式，您可以使用更简单的组件和 HOC 构建复杂组件，每个组件都专注于单个问题。这使您的代码更模块化、更易于理解和测试。

**HOCs versus hooks**  

自从 Hooks 引入以来，HOC（高阶组件）变得不那么流行了。Hooks 提供了一种更方便的方式向组件添加功能，并且还可以解决 HOC 的一些问题。例如，HOC 在使用 ref 转发时可能会导致问题，并且在使用不当的情况下还会导致不必要的重新渲染。表 5-1 对两者进行了详细的对比。



表格 5-1 并排比较了 HOC 和 hooks，展示了它们各自的优势和用例。虽然 HOC 仍然是一种有用的模式，但由于其简单易用性，hooks 通常在大多数用例中更受欢迎。

从该表我们可以看出，HOC 和 hooks 在 React 中对于跨组件共享逻辑至关重要，但它们适用于略微不同的用例。HOC 擅长跨多个组件共享逻辑，尤其擅长控制包装组件的渲染和操作 props，为组件提供额外的数据或函数。它们可以在包装组件之外管理状态并封装与包装组件相关的生命周期逻辑。然而，如果管理不善，尤其是在许多 HOC 嵌套在一起时，它们可能会导致“包装地狱”。这种嵌套也使测试变得更加复杂，并且使用 TypeScript 的类型安全性可能会变得棘手，尤其是在深度嵌套的 HOC 中。

另一方面，hooks 理想地适用于在组件内或类似组件之间提取和共享逻辑，而无需添加额外的组件层，从而避免了“包装地狱”的场景。与 HOC 不同，hooks 不直接影响渲染，也不能直接注入或操纵 props。它们旨在使用 useEffect Hook 等来管理功能组件中的局部状态并处理生命周期事件。Hooks 促进易于组合，并且通常比 HOC 更容易测试，因为它们可以比 HOC 更容易地单独测试。此外，与 TypeScript 一起使用时，hooks 提供更好的类型推断并且更容易输入，从而有可能减少与类型错误相关的错误。

虽然 HOC 和 hooks 都提供了重用逻辑的机制，但 hooks 提供了一种更直接、更简单的用于管理功能组件中的状态、生命周期事件和其他 React 特性的方法。另一方面，HOC 提供了一种更结构化的方式将行为注入组件，这在大型代码库或尚未采用 hooks 的代码库中可能是有益的。每种方法都有一套自己的优势，在项目中使用 HOC 还是 hooks 在很大程度上取决于项目的具体需求和团队对这些模式的熟悉程度。

我们能想到一些我们经常使用的 React HOC 吗？ 是的，我们可以！React.memo 是本章中刚刚介绍过的一个，它确实是一个 HOC！让我们再看另一个：React.forwardRef。这是一个将 ref 转发给子组件的 HOC。让我们看一个例子：

```jsx
const FancyInput = React.forwardRef((props, ref) => (
  <input type="text" ref={ref} {...props} />
));

const App = () => {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return (
    <div>
      <FancyInput ref={inputRef} />
    </div>
  );
};
```

在这个例子中，我们使用 React.forwardRef 将 ref 转发到 FancyInput 组件。这允许我们在父组件中访问输入元素的 focus 方法。这在 React 中是一种常见模式，它很好地展示了 HOC 如何用于解决常规组件难以解决的问题。

### Render Props  

### Children as a function  

由于 children 本身就是一个 prop，因此有些人更喜欢完全省略 render prop 这个名称，而只使用 children。这会改变 WindowSize 的用法，使其看起来像这样：

```jsx
<WindowSize>
  {({ width, height }) => (
    <div>
      Your window is {width}x{height}px
    </div>
  )}
</WindowSize>
```

一些 React 代码作者更喜欢这种写法，因为更符合代码的意图：在这种情况下，WindowSize 看起来有点像 React Context，我们显示的任何内容都感觉像是消耗这个 context 的子组件 (child component)。然而，React Hooks 完全消除了这种模式的必要性，所以也许要谨慎使用。

### Control Props

  React 的控制属性模式是一种状态管理的策略方法，它扩展了受控组件的概念。它提供了一种灵活的机制来确定组件内部如何管理状态。为了理解这一点，让我们首先了解受控组件。

受控组件是不维护自身内部状态的组件。相反，它们从父组件作为 prop 接收其当前值，父组件是它们状态的唯一来源。当状态应该改变时，受控组件会使用回调函数（通常是 onChange）通知父组件。因此，父组件负责管理状态并更新受控组件的值。

例如，一个受控的 <input> 元素如下所示：

```jsx
function Form() {
  const [inputValue, setInputValue] = React.useState("");
    
  function handleChange(event) {
    setInputValue(event.target.value);
  }
    
  return <input type="text" value={inputValue} onChange={handleChange} />;
}
```

控制属性模式进一步采用了受控组件的原则，允许组件通过 props 外部控制，或内部管理自己的状态，从而提供可选的外部控制。遵循控制属性模式的组件既接受状态值，也接受更新状态的函数作为 props。这种双重功能使父组件能够在选择时控制子组件的状态，同时还允许子组件在不受控制的情况下独立运行。

遵循控制属性模式的例子之一就是一个按钮，它可以由父组件控制，也可以管理自己的状态：

```jsx
function Toggle({ on, onToggle }) {
  const [isOn, setIsOn] = React.useState(false);

  const handleToggle = () => {
    const nextState = on === undefined ? !isOn : on;
    if (on === undefined) {
      setIsOn(nextState);
    }
    if (onToggle) {
      onToggle(nextState);
    }
  };

  return (
    <button onClick={handleToggle}>
      {on !== undefined ? on : isOn ? "On" : "Off"}
    </button>
  );
}
```

在 Toggle 组件中，isOn 代表内部状态，而 on 是外部控制属性。如果父组件提供了 on 属性，则组件可以以受控模式运行。如果没有，它将回退到其内部状态 isOn。onToggle 属性是一个回调，允许父组件响应状态变化，为父组件提供同步其自身状态与 Toggle 状态的机会。

这种模式增强了组件的灵活性，既提供受控模式又提供非受控模式的操作。它允许父组件在必要时负责，同时允许组件在未显式控制时保持对其自身状态的自主权。

### Prop Collections  

### Compound Components  

# 第6章 服务端 React

React 从一开始就经历了巨大的发展。虽然它最初是一个客户端库，但随着时间的推移，出于本章稍后我们将理解的原因，对服务器端渲染 (SSR) 的需求越来越多。我们将一起探索服务器端 React，了解它与仅限客户端的 React 有何不同，以及如何将其用于提升我们的 React 应用程序。

正如我们在之前章节中讨论过的，React 最初是由 Meta 开发的，目的是满足对高效可扩展 UI 的需求。在第 3 章中，我们研究了它如何通过虚拟 DOM 来做到这一点，虚拟 DOM 使开发人员能够轻松创建和管理 UI 组件。React 的客户端方法解锁了整个网络上快速、响应的用户体验。

然而，随着网络的不断发展，客户端渲染的局限性变得越来越明显。

## 客户端渲染的局限性

自从 2013 年作为开源软件发布以来，React 一直被用来构建用户界面。但最终，这种方法出现了一些限制。这些限制最终导致我们越来越多地将关注点转移到服务器端。

### SEO（搜索引擎优化）

客户端渲染的一个重大限制是搜索引擎爬虫可能无法正确索引内容，因为其中一些爬虫不执行 JavaScript，或者执行 JavaScript 的方式与我们期望的并不相同。

由于搜索引擎爬虫的实现种类繁多，再加上其中许多都是专有的并且公众无法知晓的，因此仅客户端渲染在给定网站或应用程序的覆盖范围方面会存在一些问题。

由于搜索引擎爬虫的实现种类繁多，绝大多数还是专有技术，我们并不知晓其具体细节，因此仅客户端渲染在给定网站或应用程序的覆盖范围方面会存在一些隐患。

话虽如此，2015 年来自 Search Engine Land 的一篇文章描述了一些测试搜索引擎如何处理仅客户端应用程序的实验，他们提到：

我们运行了一系列测试，验证了谷歌能够执行和索引各种实现的 JavaScript 代码。我们还确认谷歌能够渲染整个页面并读取 DOM，从而索引动态生成的内容。

这篇文章发现，在撰写本文时，谷歌和必应已经足以索引仅客户端的网站，但最终这仅仅是浩瀚专有技术海洋中的一个研究项目。

因此，虽然仅客户端的应用程序在现代搜索引擎上可能运行良好，但没有服务器端对应部分仍然存在固有的风险。在传统的网络应用程序中，当用户或搜索引擎爬虫请求一个页面时，服务器会渲染该页面的 HTML 并将其发送回客户端。HTML 包含所有内容、链接和数据，使搜索引擎爬虫易于阅读和索引搜索引擎结果的内容，因为页面上的所有内容都只不过是文本，即标记语言。

然而，在使用 React 等库或框架构建的客户端渲染应用程序中，服务器经常会返回一个近乎空白的 HTML 文件，该文件的唯一作用是从同一服务器或备用服务器上的单独 JavaScript 文件加载 JavaScript 代码。然后，JavaScript 文件会在浏览器中下载并执行，动态地渲染页面内容。这种方法提供了流畅的用户体验，类似于原生应用程序，但在搜索引擎优化 (SEO) 和性能方面存在缺点：第一次请求我们不会下载任何对人类读者有用的内容，而是必须在页面加载后立即进行另一个请求来获取支持整个网站的 JavaScript 代码。这被称为网络瀑布 (network waterfall)。

因此，仅客户端渲染的另一个缺点是性能。让我们来讨论一下这个问题。

### 性能

仅客户端渲染的应用程序可能会遇到性能问题，尤其是在网络速度慢或设备性能较弱的情况下。在呈现内容之前下载、解析和执行 JavaScript 代码可能会导致内容渲染出现重大延迟。这种“交互时间”是一个至关重要的指标，因为它直接影响用户参与度和跳出率（跳出率是指用户离开页面的比率）。如果页面加载时间过长，用户可能会离开，这种行为会进一步对页面的 SEO 排名产生负面影响。

此外，如果设备功耗低、CPU 可用性不足，仅客户端渲染也会造成糟糕的用户体验。这是因为设备可能没有足够的处理能力来快速执行 JavaScript 代码，从而导致应用程序运行缓慢且无响应。这可能会导致用户沮丧并带来糟糕的用户体验。如果我们在服务器上执行此 JavaScript 代码并向客户端发送少量数据或标记，那么低功耗客户端无需执行太多操作，从而提供更好的用户体验。

从更广泛的层面来看，仅客户端渲染应用程序在 SEO 和性能方面的问题凸显了遵守网络标准和最佳实践的重要性。它们还强调了服务器端渲染或静态站点生成作为更可靠的替代方案的重要性，可以高效且可访问地交付内容，尤其适用于内容繁重或功能丰富的网站或应用程序。

渐进增强原则与此类替代方案非常吻合，该原则首先向所有浏览器提供基本内容和功能，然后将高级功能视为增强功能。通过在服务器端渲染核心内容，您可以确保所有用户和搜索引擎都可以访问基本内容和功能，而不管 JavaScript 是否执行。然后，客户端 JavaScript 可以通过添加交互性、更丰富的动画和其他高级功能来增强用户体验，前提是浏览器和设备支持这些功能。仅依赖客户端 JavaScript 提供所有体验是没有意义的，因为这并不是网络的初衷设计。JavaScript 的作用是增强网页，而不是成为网页本身。

请考虑以下示例：



在撰写本文时，截至 React 18 版本，React 和 React DOM 的包大小分别为 6.4 kB 和 130.2 kB。 这些数字会根据您使用的 React 版本和配置而有所不同。 这意味着即使在生产环境中，我们的用户在下载、解析和执行应用程序其余代码之前，仅为 React（即 React + React DOM）就需要下载大约 136 kB 的 JavaScript 代码。 这可能会导致初始页面加载速度变慢，尤其是在速度较慢的设备和网络上，并可能让用户感到沮丧。 此外，由于 React 本质上拥有 DOM，在仅客户端渲染的应用程序中如果没有 React，我们就无法拥有用户界面，因此用户别无选择，只能等待 React 和 React DOM 先加载，然后再等待应用程序的其他部分加载。

相比之下，服务器端渲染的应用程序会在任何 JavaScript 下载之前向客户端流式传输渲染后的 HTML，使用户能够立即获取有意义的内容。 然后它会在初始页面渲染之后加载相关 JavaScript，这可能会发生在用户通过称为“hydration（水化）”的过程熟悉用户界面的同时进行。 我们将在后面的章节中详细介绍这一点。

首先流式传输渲染后的 HTML，然后使用 JavaScript 对 DOM 进行 hydration，可以让用户更早地与应用程序进行交互，从而带来更好的用户体验：它可以立即提供给用户，而无需他们等待任何额外的（他们可能甚至不需要的）内容加载。

### 安全

仅客户端渲染也可能存在安全问题，尤其是在处理敏感数据时。这是因为应用程序的所有代码都会下载到客户端浏览器，使其容易受到跨站点请求伪造 (CSRF) 等攻击。

虽然我们不会深入探讨 CSRF 的细节，但缓解此类攻击的一种常见方法是对服务网站或网络应用程序的服务器进行控制。如果我们控制了这个服务器，我们可以将适当的防 CSRF 令牌从服务器作为可信来源发送到客户端，然后客户端通过表单或类似方式将令牌提交回服务器，服务器可以验证请求是否来自正确的客户端。这是缓解 CSRF 的一种常见方法。

虽然从我们控制的静态站点服务器提供仅客户端应用程序并在技术上是可行的，并且可以用这种方式缓解 CSRF，但这仍然不是一般提供网站的最佳方式，因为我们之前已经讨论过其他权衡取舍。如果我们控制着服务器，为什么不从中添加 SSR 呢？

归根结底，我们想说的是：

- 如果我们没有服务器端访问权限，但是在一个团队中工作，只需将仅客户端代码推送到 git，然后神奇地部署到某个地方，那么这里存在固有的 CSRF 风险。
- 如果我们有服务器端访问权限，并且我们的网站或网络应用程序仍然是仅客户端的，那么我们已经可以很好地缓解 CSRF，并且相关的安全风险会消失。
- 如果我们有服务器端访问权限，并且我们的网站或网络应用程序仍然是仅客户端的，那么强烈建议添加服务器端渲染，因为我们可以访问服务器，从而实现我们之前已经涵盖的 SEO 和性能等其他好处。

让我们稍微实际一点，考虑以下示例：



在您提供的这段代码中，handleWithdrawal 会向一个假设的服务器端 endpoint /withdraw 发送一个 POST 请求来处理提款操作。如果这个端点没有正确验证请求的来源，并且不要求任何形式的防 CSRF 令牌，就可能发生 CSRF 风险。

攻击者可以创建一个恶意网页，诱骗用户点击一个按钮，这个按钮会代表用户向 /withdraw 端点发送 POST 请求，可能导致从用户账户进行未经授权的提款。这是因为浏览器会自动在请求中包含 cookie，服务器会使用这些 cookie 来对用户进行身份验证。如果服务器不验证请求的来源，它可能被诱骗处理请求并将资金发送到攻击者的账户。

如果这个组件是在客户端渲染的，它可能会受到 CSRF 攻击，因为服务器和客户端之间没有共享的共同秘密或契约。用一种诗意的方式来讲，客户端和服务器是互不相识的。这可能允许攻击者窃取资金或操纵应用程序的数据。

如果我们使用服务器端渲染，我们可以通过使用服务器生成的特殊秘密令牌在服务器上渲染组件，然后将包含秘密令牌的 HTML 发送到客户端，来缓解这些安全问题。客户端会将这个令牌发送回颁发它的服务器，建立一个安全的双向契约。这将允许服务器验证请求来自它已经预先授权的正确客户端，而不是未知的客户端，这可能是恶意攻击者。

## 服务器端渲染的兴起

由于这些原因，服务器端渲染已经成为一种arguably superior technique（arguably superior technique 可翻译为“可以说是一种更优的技术”）  ，用于提高网络应用程序的性能和用户体验。通过服务器端渲染，可以优化应用程序的速度和可访问性，从而带来更快的加载时间、更好的 SEO 和改进的用户参与度。

然而，服务器端渲染的 HTML 是静态的，并且缺乏交互性，因为它最初并没有加载任何 JavaScript 代码。它不包含任何事件监听器或其他附加的动态功能。为了启用用户交互和其他动态特性，静态 HTML 必须使用必要的 JavaScript 代码进行“hydration（水化）”。让我们更深入地了解一下 hydration 的概念。

## Hydration（水化）

Hydration（水化）用于描述将事件监听器和其他 JavaScript 功能附加到服务器生成并发送给客户端的静态 HTML 的过程。Hydration 的目标是使服务器端渲染的应用程序在浏览器中加载后能够完全交互，为用户提供快速流畅的体验。

在 React 应用中，Hydration 发生在客户端下载服务器端渲染的 React 应用之后。然后会依次发生以下步骤：

**1. 加载客户端包**

当浏览器渲染静态 HTML 时，它还会下载并解析包含应用程序代码的 JavaScript 包。此包包含 React 组件以及应用程序功能所必需的任何其他代码。

**2. 附加事件监听器**

JavaScript 包加载完成后，React 通过将事件监听器和其他动态功能附加到 DOM 元素来“hydrate”（水化）静态 HTML。这通常使用来自 react-dom 的 hydrateRoot 函数完成，该函数接受根 React 组件和 DOM 容器作为参数。Hydration 基本上将静态 HTML 转换为一个完全交互的 React 应用程序。



Hydration 过程完成后，应用程序将完全交互，并可以根据需要响应用户输入、获取数据和更新 DOM。

在 Hydration 过程中，React 将静态 HTML 中的 DOM 元素结构与通过 JSX 定义的 React 组件结构进行匹配。由 React 组件生成的结构必须与静态 HTML 的结构匹配，这一点至关重要。如果不匹配，React 将无法正确附加事件监听器，并且不知道哪个 React 元素直接映射到哪个 DOM 元素，这会导致应用程序无法按预期运行。

通过结合服务器端渲染和 Hydration，开发人员可以创建快速加载并提供流畅、交互式用户体验的网络应用程序。

### Hydration 的争议

Hydration 虽然是一种使服务器端渲染的 HTML 具有交互性的好方法，但一些人批评 Hydration 的速度比必要的慢，他们经常认为可恢复性 (resumability) 是一种更好的替代方案（见图 6-2）。让我们来探讨一下这一点。

## 创建服务器端渲染

一种方法是使用服务器渲染框架，例如 Next.js 或 Remix。虽然这些框架确实是服务器端渲染 React 应用的最佳方式，但是对于那些好奇的人来说，像这样的抽象可能会让他们渴望理解实现这一功能的底层机制。

如果您对如何手动将服务器端渲染添加到仅客户端的 React 应用感兴趣，或者如果您对框架如何做到这一点感兴趣，请继续阅读。 再次强调，这可能是您在生产环境中不会使用的东西，但更适合好奇人士的学习目的。

### 手动将服务器端渲染添加到仅客户端的 React 应用中

完成这些步骤后，我们现在就拥有了一个服务器端渲染的 React 应用。通过这种「揭开神秘面纱」的方式来学习服务器端渲染，可以使我们更深入地理解服务器端渲染的工作原理以及它如何使我们的 React 应用受益。

### Hydrating  

服务器端渲染的输出送达用户后，当我们在文件结尾处使用 `<script>` 标签加载客户端包时，就会发生 hydration（水化）。正如我们讨论过的，hydration 是将事件监听器和其他 JavaScript 功能附加到服务器生成并发送给客户端的静态 HTML 的过程。Hydration 的目标是使服务器端渲染的应用程序在浏览器中加载后能够完全交互。

如果我们想要探索应用程序的客户端包的 hydration 步骤，它看起来会是这样：

### React 中的服务器端渲染 API

#### renderToString  

`renderToString` 作为一个 API 是同步阻塞的，这意味着它在执行过程中不能被中断或暂停。如果来自根组件的组件树非常深层，则可能需要相当多的处理时间。由于服务器通常需要为多个客户端提供服务，因此除非存在某种类型的缓存机制来防止这种情况，否则 `renderToString`可能會被为每个客户端调用，并迅速阻塞事件循环并使系统过载。

#### renderToPipeableStream  

# 第7章：并发 React

## 同步渲染的问题

并发渲染使 React 可以根据更新的重要性紧迫性来优先级排序，从而确保关键更新不会被不那么重要的更新阻塞。这允许 React 在高负载下仍能保持响应式的 UI，从而带来更佳的用户体验。例如，当用户悬停在按钮上或单击按钮时，期望它立即显示该操作的反馈。如果 React 正在重新渲染一个长列表项，那么悬停或激活状态的反馈将被延迟，直到整个列表都被渲染。使用并发渲染，那些占用 CPU 资源的渲染任务可以被降级优先级，而更重要的任务（例如用户交互和动画）则可以优先执行。

此外，借助并发渲染功能，React 能够进行时间切片：即可以将渲染过程分解成更小的块并增量处理它们。这允许 React 在多个帧上执行工作，并且如果需要中断工作，也可以做到。

让我们从现在开始一起深入研究所有这些内容。

## 重温Fiber  

正如第4章所述，Fiber reconciliation 机制是 React 中实现并发渲染的核心机制。它在 React 16 中引入，相比于之前的栈式 reconciler，它代表了架构上的重大转变。Fiber reconciliation 机制的主要目标是改善 React 应用的响应速度和性能，尤其适用于大型复杂的 UI.

Fiber reconciliation 机制通过将渲染过程分解成更小的、更易管理的工作单元（称为 Fiber）来实现这一点。这使 React 可以暂停、恢复和优先执行渲染任务，从而可以根据更新的重要性来延迟或安排更新。这改善了应用程序的响应性，并确保关键更新不会被不那么重要的任务阻塞。

## 调度和延迟更新

## 调度和延迟更新

React 调度和延迟更新的能力对于保持应用程序的响应性至关重要。Fiber reconciliation 机制通过依赖调度程序和一些高效的 API 来实现此功能。这些 API 允许 React 在空闲期间执行工作并在最合适的时间安排更新。

我们将在后续章节中更详细地介绍调度程序，但现在，可以简单地认为它是一个接收更新并根据浏览器提供的 setTimeout、MessageChannel 等 API 指示“你现在做这个”、“你稍后做那个”等操作的系统。

考虑一个用户可以发送和接收消息的实时聊天应用程序。我们将有一个聊天组件来显示消息列表，以及一个消息输入组件供用户键入和提交消息。此外，聊天应用程序会实时从服务器接收新消息。在这种情况下，我们希望优先考虑用户交互（例如输入和提交消息）以保持响应迅速的体验，同时确保传入消息高效渲染而不阻塞 UI。

为了使这个例子更具体一些，让我们创建一些组件。首先，显示消息列表的组件：

```jsx
const ChatApp = () => {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // Connect to the server and subscribe to incoming messages
    const socket = new WebSocket("wss://your-websocket-server.com");
    socket.onmessage = (event) => {
      setMessages((prevMessages) => [...prevMessages, event.data]);
    };
    return () => {
      socket.close();
    };
  }, []);

  const sendMessage = (message) => {
    // Send the message to the server
  };

  return (
    <div>
      <MessageList messages={messages} />
      <MessageInput onSubmit={sendMessage} />
    </div>
  );
};
```

在这个例子中，React 的并发渲染功能通过高效地管理消息列表和用户与消息输入的交互更新来发挥作用。当用户键入或提交消息时，React 会优先考虑文本输入更新，以确保流畅的用户体验。

当新消息从服务器到达并需要渲染时，它们将以默认/未知的渲染通道渲染，该通道会同步且立即以阻塞方式更新 DOM：这会延迟任何用户输入。如果我们想要降低新消息列表的渲染优先级，我们可以像这样将对应的状态更新包装在来自 useTransition 钩子的 startTransition 函数中：

```jsx
const ChatApp = () => {
  const [messages, setMessages] = useState([]);
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    // Connect to the server and subscribe to incoming messages
    const socket = new WebSocket("wss://your-websocket-server.com");
    socket.onmessage = (event) => {
      startTransition(() => {
        setMessages((prevMessages) => [...prevMessages, event.data]);
      });
    };
    return () => {
      socket.close();
    };
  }, []);

  const sendMessage = (message) => {
    // Send the message to the server
  };

  return (
    <div>
      <MessageList messages={messages} />
      <MessageInput onSubmit={sendMessage} />
    </div>
  );
};
```

采用这种方式，我们向 React 发出信号，要求以较低优先级调度消息列表更新，并允许它们在不阻塞 UI 的情况下进行渲染，从而使聊天应用程序即使在高负载下也能高效运行。因此，用户输入永远不会被中断，并且传入消息的渲染优先级低于用户交互，因为它们对用户体验的影响较小。

这个例子展示了 React 的并发渲染功能如何用于构建响应迅速的应用程序，这些应用程序可以处理复杂的交互和频繁的更新，同时不会影响性能或用户体验。我们将在本章后面更深入地探讨 useTransition。现在，让我们更深入地研究 React  schedules是如何调度更新的。

## 更加深入

在 React 中，调度、优先级划分和延迟更新的过程对于维护响应式用户界面至关重要。此过程可确保高优先级任务被及时处理，而低优先级任务可以延迟执行，从而即使在高负载下也能让 UI 保持流畅。为了更深入地探讨这个话题，我们将研究几个核心概念：调度程序（scheduler）、任务的优先级以及延迟更新的机制。

### 调度程序

调度程序是 React 架构的核心部分，它是一个独立的包，提供与 Fiber reconciler 独立的计时相关实用程序。React 在 reconciler 中使用此调度程序。调度程序和 reconciler 通过使用渲染通道（render lanes）使任务能够通过根据紧迫性进行优先级划分和组织来协作。我们稍后将深入探讨渲染通道。调度程序在 React 中的主要作用是管理主线程的让步，主要是通过调度微任务来确保流畅执行。

为了更详细地理解这一点，让我们来看一下 React 在撰写本文时的一段源代码



微任务是 JavaScript 事件循环管理中的一个概念，代表由微任务队列管理的一类任务。为了理解微任务，首先需要对 JavaScript 事件循环和与其相关的任务队列有一个基本的认识：

## 渲染通道

渲染通道是React调度系统的重要组成部分，它确保了任务的高效渲染和优先级排列。通道是一个工作单元，代表了一个优先级水平，并且可以在React的渲染周期中被处理。渲染通道的概念是在React 18中引入的，取代了先前使用到期时间的调度机制。让我们深入了解渲染通道的细节，它们的工作原理以及作为位掩码的基础表示。

首先，渲染通道是React用来组织和优先处理在渲染过程中需要进行的更新的轻量级抽象。例如，当您调用setState时，该更新会放入一个通道中。我们可以根据更新的上下文理解不同的优先级，如下所示：

- 如果在点击处理程序内部调用setState，则放入同步通道（最高优先级）并在微任务中进行调度。
- 如果在startTransition的过渡内部调用setState，则放入过渡通道（较低优先级）并在微任务中进行调度。

每个通道对应于一个特定的优先级水平，高优先级通道在低优先级通道之前处理。React中一些通道的示例包括：

- SyncHydrationLane：在水合过程中用户点击React应用时，点击事件被放入此通道。
- SyncLane：当用户点击React应用时，点击事件被放入此通道。
- InputContinuousHydrationLane：在水合期间，鼠标悬停事件、滚动事件和其他连续事件被放入此通道。
- InputContinuousLane：与前述相同，但适用于React应用被水合后的情况。
- DefaultLane：来自网络的任何更新、像setTimeout这样的计时器以及没有推断出优先级的初始渲染都被放入此通道。
- TransitionHydrationLane：在水合过程中，来自startTransition的任何过渡都被放入此通道。
- TransitionLanes（1-15）：在水合后，来自startTransition的任何过渡都被放入这些通道。
- RetryLanes（1-4）：任何Suspense重试都被放入这些通道。

值得注意的是，这些通道反映了写作时React内部的实现，并可能会发生变化。重申一下，本书的重点是理解React的工作机制，而不是过于执着于具体的实现细节，因此通道的名称可能并不是特别重要。更为重要的是我们对机制的理解——也就是React如何使用这个概念以及我们如何将其应用到我们的工作中。

## useTransition  

useTransition是一个强大的React Hook，允许你在组件中管理状态更新的优先级，并防止由于高优先级更新导致UI不响应。当处理可能视觉上具有破坏性的更新时特别有用，例如加载新数据或在页面之间导航。

它基本上将你包装在其返回的startTransition函数中的任何更新放入过渡通道，这比我们之前看到的Sync通道的优先级低，允许你控制更新的时机，并保持流畅的用户体验，即使其他高优先级的更新正在竞争主线程。

useTransition是一个Hook，这意味着你只能在函数组件内部使用它。它返回一个包含两个元素的数组：

- isPending：一个布尔值，指示是否正在进行过渡。关于useTransition工作方式的一个有趣部分是，当你调用startTransition时，它首先会在这个属性上安排一个同步的setState({ isPending: false })，这意味着依赖于isPending的更新需要快速完成，否则就违背了useTransition的目的。

- startTransition：一个函数，你可以用它来包装应该被延迟或赋予较低优先级的更新。

值得一提的是，在这里可能还有一种startTransition API可用，它不是作为Hook，而是作为一个常规函数。启动非紧急过渡的第二种方法是直接从React导入startTransition函数。这种方法不提供对isPending标志的访问，但是当你不能使用像useTransition这样的Hook时，仍然希望向React发出低优先级更新的信号时，它是可用的。

## useDeferredValue  

useDeferredValue是一个React Hook，允许将某些UI更新推迟到以后的时间点，特别适用于应用程序处理大量负载或计算密集型任务的场景，从而有助于管理更新优先级并促进更平滑的过渡和改善用户体验。

在初始渲染期间，返回的延迟值与提供的值相同。在后续更新中，useDeferredValue通过在更新到新值之前保留旧值更长时间来帮助保持流畅的用户体验，特别是在具有计算密集型操作的情况下。这并不涉及使用旧值和新值进行多次重新渲染，而是对新值进行控制性更新。

这种机制类似于一种“陈旧但可重新验证”的策略，即保留陈旧值以保持UI的响应性，同时等待新值的到来。

通过查看React的提交历史，我们可以看到useDeferredValue的第一个实现大致如下：



让我们稍微聊一下这段代码在做什么。首先，它使用传递给它的初始值设置了一个状态（newValue）。然后，函数利用useEffect钩子来观察这个值的变化。当检测到变化时，会调用startTransition函数，这对于推迟更新至关重要。

在startTransition中，使用setNewValue将状态更新为新值。使用startTransition表示给React一个信号，表明这个更新不是紧急的，允许React首先处理其他更关键的更新。这几乎正是useDeferredValue今天的工作方式，对我们对它的心理模型应该有所帮助。

useDeferredValue是React并发特性的一部分，它通过允许推迟某些状态更新来实现可中断性。当带有延迟值的组件重新渲染时，React会在一定时间内保持显示旧值，允许高优先级的更新在低优先级的更新之前被处理。这将渲染工作分成了较小的块，可以随着时间的推移分散进行，提高了响应性，并确保高优先级的更新（如用户交互）不会被低优先级的更新延迟，从而提升了积极的用户体验。

### useDeferredValue 的目的

useDeferredValue的主要目的是允许你推迟对不太关键的更新的渲染。当你想要优先处理更重要的更新，例如用户交互，而不是较不关键的更新，例如显示来自服务器的更新数据时，这特别有用。

通过使用useDeferredValue，你可以提供更流畅的用户体验，并确保你的应用程序在处理重负载或复杂操作时保持响应性。

要使用useDeferredValue，你需要从React包中导入它，并将一个值作为参数传递给它。然后，该钩子将返回该值的延迟版本，可以在你的组件中使用。

这里是如何在一个简单应用程序中使用useDeferredValue的示例：

```jsx
import React, { memo, useState, useDeferredValue } from "react";

function App() {
  const [searchValue, setSearchValue] = useState("");
  const deferredSearchValue = useDeferredValue(searchValue);
  return (
    <div>
      <input
        type="text"
        value={searchValue}
        onChange={(event) => setSearchValue(event.target.value)}
      />
      <SearchResults searchValue={deferredSearchValue} />
    </div>
  );
}

const SearchResults = memo(({ searchValue }) => {
  // Perform the search and render the results
})
```

### 什么时候使用useDeferredValue  

在需要将某些更新优先于其他更新的情况下，useDeferredValue非常有用。一些常见的情景包括：

- 搜索或筛选大型数据集
- 渲染复杂的可视化或动画
- 在后台更新来自服务器的数据
- 处理可能影响用户交互的计算密集型操作

让我们来看一个使用useDeferredValue特别有用的示例。假设我们有一个大型的项目列表，我们希望根据用户输入进行筛选。筛选大型列表可能会耗费大量计算资源，因此使用useDeferredValue可以帮助保持应用程序的响应性：

### 什么时候不要使用useDeferredValue  

虽然在某些情况下useDeferredValue可能会有益，但重要的是要认识到其中的权衡。主要是，通过推迟更新，有可能显示给用户的数据略微过时。虽然这通常对于较不关键的更新是可以接受的，但重要的是要考虑将过时数据显示给用户的影响。

在决定是否使用useDeferredValue时，一个好问题是：“这个更新是用户输入吗？”React之所以称为React，是有原因的：它使我们的网络应用能够对事物做出反应。任何会导致用户期望得到反应的东西都不应该被推迟。其他一切都应该被推迟。

虽然使用useDeferredValue可以极大地提升应用程序在负载下的响应性，但它不应被视为解决所有问题的灵丹妙药。永远记住，提高性能的最佳方法是编写高效的代码，避免不必要的计算。

## 并发渲染存在的问题

并发渲染虽然允许实现高性能和响应式用户交互，但也给开发者带来了新的问题需要考虑。主要问题在于很难确定更新的处理顺序，这可能导致意外行为和错误。其中一个问题是称为"tearing"的bug，其中UI由于更新的处理顺序不一致而变得不一致。当组件依赖于在其仍在渲染时更新的某些值时，就会出现这种情况，导致应用程序以不一致的数据进行渲染。让我们稍微深入了解一下这个问题。

### 撕裂（Tearing）

撕裂是一种bug，当组件依赖于在应用程序仍在渲染时更新的某些状态时会发生。为了理解这一点，让我们将同步渲染与并发渲染进行对比。

在同步世界中，React会沿着组件树向下遍历，并依次从顶部到底部渲染它们。这确保了应用程序在整个渲染过程中的状态是一致的，因为每个组件都是使用最新的状态进行渲染的。

考虑以下示例：



**useSyncExternalStore**  

## 面试问题

1、What is the Fiber reconciler in React, and how does it contribute to the handling of complex, high-performance applications?

React Fiber是React的一个内部实现细节，旨在提高React应用程序的性能和渲染能力。它是React核心算法的重新实现，用于将渲染过程中的工作分解为较小的块，并允许React根据需要对工作进行优先级、暂停或中止。

以下是Fiber如何有助于处理复杂、高性能应用程序的方式：

1. **增量渲染**：Fiber允许React将渲染工作分割为称为fiber的较小单元。这使得React可以在仍能够响应用户输入或其他高优先级任务的情况下工作于UI的渲染部分。增量渲染意味着React可以更频繁地更新UI，并提供更流畅的用户体验。

2. **优先级**：Fiber引入了渲染过程的优先级级别的概念。React可以根据其重要性对不同类型的工作进行优先级排序。例如，React可以将UI更新的渲染优先级高于处理网络请求或处理用户输入等不太关键的任务。这确保了用户界面在负载较重时仍保持响应性。

3. **并发**：Fiber实现了并发渲染，允许React同时处理多个任务。这种并发模型允许React根据需要暂停和恢复工作，从而更有效地处理具有动态内容或频繁更新的复杂UI。

4. **错误边界和悬挂**：通过Fiber，React引入了错误边界和悬挂，这些机制可更声明式和高效地处理错误和加载状态。错误边界允许开发人员捕获渲染过程中发生的错误，并提供回退UI，防止整个UI崩溃。悬挂允许开发人员在等待数据加载时暂停渲染，改善应用程序的感知性能。

总的来说，React Fiber通过引入增量渲染、优先级、并发、错误边界和悬挂等特性，显著提高了React处理复杂、高性能应用程序的能力。这些特性帮助React应用程序在要求苛刻的环境中保持响应、可扩展和可靠。

2、解释React中调度和延迟更新的概念。它如何帮助在负载较重的情况下保持流畅的用户体验？

在React中，调度（scheduling）是指决定何时执行更新的过程，而延迟更新则是将更新推迟到稍后执行的方法。这两个概念结合起来，帮助React在处理大量更新时保持用户界面的响应性和流畅性。

当应用程序受到大量更新的影响时，React可以使用调度算法来决定何时以及如何处理这些更新。通过调度，React可以根据优先级、重要性或其他标准对更新进行排序，并在适当的时候执行它们。这样可以确保对用户最重要的更新优先处理，从而提高用户体验。

延迟更新是一种策略，通过将更新推迟到稍后的时间执行，可以优化应用程序的性能。例如，React可以将一些低优先级或不紧急的更新推迟到用户当前不活跃的时间段执行，以避免影响用户正在进行的操作。这样可以保持用户界面的响应性，并确保用户体验始终保持流畅。

综上所述，通过调度和延迟更新，React可以在处理大量更新时保持用户界面的响应性和流畅性。调度确保更新按照优先级进行处理，而延迟更新则可以优化性能，避免影响用户操作，从而提供更好的用户体验。

**3、What are render lanes in React, and how do they manage the execution of updates? Can you describe how render lanes use bitmasking to handle multiple priorities?**

在React中，渲染通道（render lanes）是一种机制，用于管理更新的执行。它们用于确定哪些更新应该在何时执行，并根据其优先级进行排序。

渲染通道通过位掩码（bitmasking）来处理多个优先级。位掩码是一种二进制位的操作，它们允许将多个布尔标志组合在一起，并以一种高效的方式进行操作。

React中的渲染通道使用位掩码来表示不同的优先级。每个渲染通道都有一个对应的位掩码，其中每个位表示一个特定的优先级。例如，一个渲染通道可能具有以下位掩码：

- 第1位表示高优先级
- 第2位表示中优先级
- 第3位表示低优先级

当React需要执行更新时，它会根据更新的优先级选择相应的渲染通道。然后，React会将该更新与渲染通道的位掩码进行与运算（bitwise AND），以确定更新是否应该在该通道上执行。如果更新的优先级与通道的位掩码相匹配，则更新将在该通道上执行。

这种使用位掩码的方法使得React能够高效地管理多个优先级，并确保每个更新都能够按照其相应的优先级得到及时处理。

## 接下来

现在你对React的并发特性和内部工作原理有了深入的理解，你已经具备了在构建高性能应用程序中充分利用其潜力的能力。在第8章中，我们将探索构建在React之上的各种流行框架，如Next.js和Remix，它们通过提供最佳实践、约定和附加功能进一步简化了开发流程。

这些框架旨在帮助您轻松构建复杂的应用程序，处理许多常见问题，例如服务器渲染、路由和代码拆分。通过利用这些框架的力量，您可以专注于构建应用程序的功能和功能，同时确保最佳的性能和用户体验。

敬请关注对这些强大框架的深入探索，学习如何利用React及其生态系统构建可扩展、高性能和功能丰富的应用程序。