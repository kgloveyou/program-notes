---
AIGC:
  Label: "1"
  ContentProducer: "001191330110MADHPQQY7L10000"
  ProduceID: "ExportRequest(files=[ExportFile(docType=2, fileType=3)])"
  ReservedCode1: "3187855ddc34ef804f979779c108199d57c3dcfa49d5a33e15e249ee509b1757"
  ContentPropagator: "001191330110MADHPQQY7L10000"
  PropagateID: "ExportRequest(files=[ExportFile(docType=2, fileType=3)])"
  ReservedCode2: ""
---
创建和加载高级网格与几何体
 
在本章中，我们将探讨几种不同的方法，帮助您创建和加载高级且复杂的几何体与网格。在第5章“学习处理几何体”和第6章“探索高级几何体”中，我们向您展示了如何利用Three.js内置对象创建一些高级几何体。在本章中，我们将采用以下两种方法来创建高级几何体和网格：
 
• 几何体分组与合并
 
### • 从外部资源加载几何体
 
### 我们从“分组与合并”方法入手。借助这种方法，我们使用标准的Three.js分组（THREE.Group）和BufferGeometryUtils.mergeBufferGeometries()函数来创建新对象。
 
### 几何分组与合并
 
在本节中，我们将介绍Three.js的两个基本功能：将对象分组以及将多个几何体合并为一个几何体。我们先从分组对象开始。
 
将对象分组在一起
 
在前面的一些章节中，你已经了解了在处理多种材质时如何对对象进行分组。当你使用多种材质从几何体创建网格时，Three.js 会创建一个组。你的几何体的多个副本会被添加到这个组中，每个副本都拥有自己的特定材质。这个组会被返回，因此看起来像是一个使用了多种材质的网格。但实际上，它只是一个包含多个网格的组。 
创建组非常简单。您创建的每个网格都可以包含子元素，这些子元素可通过“添加”功能进行添加。将子对象添加到组中的效果是：您可以移动、缩放、旋转和平移父对象，所有子对象也会随之受到影响。在使用组时，您仍可单独引用、修改和定位各个几何体。唯一需要记住的是，所有位置、旋转和平移操作都是相对于父对象进行的。
 
让我们来看一下以下截图中的一个示例（grouping.html）：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.1_10_.png)
 
在本示例中，您会看到大量立方体，它们被作为一个整体组添加到场景中。在我们了解控件以及使用组的效果之前，让我们先快速了解一下我们是如何创建这个网格的：
 
在这个代码片段中，你可以看到我们创建了一个THREE.Group实例。这个对象与THREE.Object3D几乎完全相同——THREE.Mesh和THREE.Scene的基类也是THREE.Object3D——但单独来看，它本身并不包含任何内容，也不会触发任何渲染操作。在本示例中，我们使用add函数向场景中添加了大量立方体。为了便于演示，我们还添加了用于调整网格位置的控件。每当通过此菜单更改某个属性时，THREE.Group对象的相关属性也会随之更新。例如，在下一个示例中，你可以看到当我们缩放这个THREE.Group对象时，所有嵌套的立方体也会同步被缩放：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.2_11_.png)
 
如果你想对 THREE.Group 对象进行更多一些的实验，一个不错的练习是修改示例，使 THREE.Group 实例本身绕 x 轴旋转，而各个立方体则绕其 y 轴旋转。
 
使用THREE.Group带来的性能影响
 
在进入下一节探讨合并之前，先简单提一下性能问题。当你使用THREE.Group时，该组内的所有单独网格都会被视为独立对象，而这些对象都需要Three.js进行管理和渲染。如果你的场景中包含大量对象，就会明显感受到性能下降。如果你查看图8.2的左上角，会发现当屏幕上同时显示5,000个立方体时，帧率大约为每秒56帧（FPS）。这个表现还算不错，但通常我们的运行帧率应该能达到约120 FPS。
 
Three.js 提供了一种额外的方式，我们仍可控制各个网格，同时获得更出色的性能。这是通过 THREE.InstancedMesh 实现的。如果你……，这个对象将表现出色。 
希望渲染大量具有相同几何形状但应用了不同变换的对象（例如，旋转、缩放、颜色或任何其他矩阵变换）。
 
我们创建了一个名为instanced-mesh.html的示例，展示了这一功能的实现方式。在该示例中，我们渲染了25万个立方体，但依然保持了出色的性能：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.3_16_.png)
 
要使用 THREE.InstancedMesh 对象，我们创建它的方式与创建 THREE.Group 实例类似：
 
与THREE.Group相比，创建THREE.InstancedMesh对象的主要区别在于，我们需要事先定义好所使用的材质和几何体，以及希望创建该几何体的实例数量。要对其中一个实例进行定位或旋转，我们需要使用THREE.Matrix4实例来提供变换信息。幸运的是，我们无需深入研究矩阵背后的数学原理，因为Three.js在THREE.Matrix4实例上提供了一些辅助函数，可方便地用于定义旋转、平移以及其他几种变换。在本示例中，我们只是简单地将每个实例随机放置在不同位置上。 
因此，如果您处理的是少量网格（或使用不同几何体的网格），希望将它们分组在一起时，应使用THREE.Group对象。如果您处理的是大量共享同一几何体和材质的网格，则可以使用THREE.InstancedMesh对象或THREE.InstancedBufferGeometry对象，以显著提升性能。
 
在下一节中，我们将介绍合并操作，您将把多个独立的几何体合并，最终得到一个单一的THREE.Geometry对象。
 
合并几何体
 
在大多数情况下，使用组能够让您轻松地操作和管理大量网格。然而，当您处理的对象数量非常庞大时，性能便会成为一个问题，因为Three.js必须单独处理组的所有子对象。借助BufferGeometryUtils.mergeBufferGeometries，您可以将多个几何体合并为一个统一的几何体，这样Three.js只需管理这一单一的几何体即可。在图8.4中，您可以看到这一方法的具体实现及其对性能的影响。如果您打开merging.html示例，会再次看到一个场景，其中包含一组随机分布的半透明立方体，我们已将其合并为一个单一的THREE.BufferGeometry对象：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.4_7_.png)
 
如你所见，我们能够轻松地渲染5万个立方体，且性能丝毫未受影响。为此，我们使用了以下几行代码：
 
通过构造性实体几何创建新几何体
 
除了本章中介绍的几何体合并方法之外，我们还可以使用构造实体几何（CSG）来创建几何体。借助CSG，您可以对两个几何体执行各种操作（通常包括加法、减法、差集和交集），从而将它们组合起来。这些库会根据所选操作生成一个新的几何体。例如，利用CSG，很容易创建一个实心立方体，并在其中一侧挖出一个类似球体的凹陷。在Three.js中，您可以使用的两个相关库是three-bvh-csg（https://github.com/gkjohnson/three-bvh-csg）和Three.csg（https://github.com/looeee/threejs-csg）。
 
借助分组与合并方法，您可以利用Three.js提供的基本几何体创建大型且复杂的几何体。如果您想创建更高级的几何体，那么使用Three.js提供的编程方式并不总是最佳和最简便的选择。幸运的是，Three.js还提供了其他几种创建几何体的选项。在下一节中，我们将探讨如何从外部资源加载几何体和网格。 
从外部资源加载几何体
 
Three.js 可以读取大量3D文件格式，并导入这些文件中定义的几何体和网格。需要注意的是，并非所有这些格式的功能都能得到完全支持。因此，有时可能会出现纹理问题，或者材质设置不正确的情况。目前，glTF已成为模型和纹理交换的事实标准。所以，如果您想加载外部创建的模型，通常将这些模型导出为glTF格式，能在Three.js中获得最佳效果。
 
在本节中，我们将更深入地探讨Three.js支持的一些格式，但不会向您展示所有加载器。以下列表展示了Three.js支持的格式概览：
 
• AMF：AMF是另一种3D打印标准，但目前已不再积极开发。有关此标准的更多信息，请参阅以下维基百科页面：https://www.sculpteo.com/en/glossary/amf-definition/。
 
• 3DM：3DM 是 Rhinoceros 使用的格式，Rhinoceros 是一款用于创建三维模型的工具。有关 Rhinoceros 的更多信息，请访问：https://www.rhino3d.com/。
 
• 3MF：3MF是3D打印所采用的标准之一。有关此格式的更多信息，请访问3MF联盟主页：https://3mf.io。
 
• 协作设计活动（COLLADA）：COLLADA 是一种以 XML 为基础的数字资产定义格式。这是一种应用广泛的格式，几乎所有的 3D 应用程序和渲染引擎都支持。
 
• Draco：Draco 是一种文件格式，可极为高效地存储几何体和点云数据。它规定了这些元素的最佳压缩与解压缩方式。有关 Draco 工作原理的详细信息，请访问其 GitHub 页面：https://github.com/google/draco。
 
• G代码：G代码是与3D打印机或CNC机床通信的一种标准方式。在打印模型时，控制3D打印机的一种方法就是向其发送G代码指令。该标准的详细内容请参阅以下论文：https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374。
 
• glTF：这是一种规范，定义了3D场景和模型如何被不同应用和工具交换与加载，并正逐渐成为网络上模型交换的行业标准格式。它们以二进制格式（扩展名为.glb）和基于文本的格式（扩展名为.gltf）提供。有关此标准的更多信息，请访问：https://www.khronos.org/gltf/。
 
• 工业基础类（IFC）：这是一种由建筑信息模型（BIM）工具使用的开放文件格式。它包含建筑物的模型以及大量有关所用材料的附加信息。有关此标准的更多信息，请访问：https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/。
 
• JSON：Three.js 有自己的 JSON 格式，可用于以声明方式定义几何体或场景。尽管这并非官方格式，但它使用起来非常简便，在您希望复用复杂几何体或场景时尤为方便。
 
• KMZ：这是Google Earth中用于3D资产的格式。更多信息请访问：https://developers.google.com/kml/documentation/kmzarchives。
 
• LDraw：LDraw 是一种开放标准，可用于创建虚拟乐高模型和场景。更多信息请访问 LDraw 主页：https://ldraw.org。
 
• LWO：这是LightWave 3D所使用的文件格式。有关LightWave 3D的更多信息，请访问：https://www.lightwave3d.com/。
 
• NRRD：NRRD 是一种用于可视化体数据的文件格式。例如，它可用于渲染 CT 扫描图像。您可在此处找到大量相关信息和示例：http://teem.sourceforge.net/nrrd/。
 
• OBJ 和 MTL：OBJ 是一种由 Wavefront Technologies 首次开发的简单 3D 格式。它是应用最广泛的 3D 文件格式之一，用于定义物体的几何形状。MTL 是 OBJ 的配套格式。在 MTL 文件中，会指定 OBJ 文件中各个物体的材质。如果您希望从 Three.js 将模型导出为 OBJ 格式，Three.js 还提供了一个自定义的 OBJ 导出器，称为 OBJExporter。
 
• PCD：这是一种用于描述点云的开放格式。更多信息请访问：https://pointclouds.org/documentation/tutorials/pcd_file_format.html。
 
• PDB：这是一种非常专业的格式，由蛋白质数据银行（PDB）创建，用于描述蛋白质的结构。Three.js 可以加载并可视化采用这种格式描述的蛋白质。
 
• 多边形文件格式（PLY）：此格式最常用于存储来自3D扫描仪的信息。
 
• 打包的原始WebGL模型（PRWM）：这是一种专注于高效存储和解析3D几何体的另一种格式。有关此标准的更多信息以及如何使用它，请参阅：https://github.com/kchapelier/PRWM。
 
• 立体光刻（STL）：这是一种广泛用于快速原型制作的技术。例如，3D打印机的模型通常以STL文件形式定义。如果你希望从Three.js中将模型导出为STL格式，Three.js还提供了一个自定义的STL导出器，名为STLExporter.js。
 
• SVG：SVG 是一种定义矢量图形的标准方式。此加载器可让您加载 SVG 文件，并返回一组 THREE.Path 元素，您可使用这些元素进行拉伸或在 2D 中渲染。
 
• 3DS：Autodesk 3DS 格式。更多信息请访问 https://www.autodesk.com/。
 
• TILT：TILT 是 Tilt Brush 所采用的格式，这是一款可在 VR 中进行绘画的工具。更多信息请访问：https://www.tiltbrush.com/。
 
• VOX：MagicaVoxel所使用的格式，这是一款免费工具，可用于创作体素艺术。更多信息请访问MagicaVoxel主页：https://ephtracy.github.io/。
 
• 虚拟现实建模语言（VRML）：这是一种基于文本的格式，可用于指定3D对象和世界。它已被X3D文件格式所取代。Three.js不支持加载X3D模型，但这些模型可轻松转换为其他格式。更多信息请访问http://www.x3dom.org/?page_id=532#。
 
• 可视化工具包（VTK）：这是由VTK定义并用于指定顶点和面的文件格式。该格式有两种形式：二进制格式和基于文本的ASCII格式。Three.js仅支持基于ASCII的格式。
 
• XYZ：这是一种用于描述三维空间中点的非常简单的文件格式。更多信息请访问：https://people.math.sc.edu/Burkardt/data/xyz/xyz.html。
 
在第9章“动画与摄像机移动”中，当我们探讨动画时，将再次回顾其中一些格式（并了解若干新增格式）。
 
正如您从这份列表中所看到的，Three.js 支持数量庞大的3D文件格式。我们不会逐一介绍所有这些格式，而只重点介绍其中最有趣的几个。我们将从JSON加载器开始，因为它提供了一种便捷的方式，用于存储和检索您自己创建的场景。
 
使用Three.js的JSON格式进行保存和加载
 
您可以在Three.js中针对两种不同场景使用Three.js JSON格式。您可以利用它来保存和加载单个THREE.Object3D对象（这意味着您也可以用它来导出THREE.Scene对象）。
 
为了演示保存与加载功能，我们基于THREE.TorusKnotGeometry创建了一个简单示例。通过这个示例，你可以像我们在第5章中那样创建一个环面纽结，并借助“保存/加载”菜单中的“保存”按钮，将当前的几何体保存下来。在本示例中，我们采用HTML5本地存储API进行保存。该API能够让我们轻松地在客户端浏览器中存储持久化信息，并在稍后随时调用（即使浏览器已关闭并重新启动）：
 
创建和加载高级网格与几何体
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.5_12_.png)
 
在上一张截图中，您可以看到两个网格——红色的是我们加载的网格，黄色的是原始网格。如果您自己打开此示例并点击保存按钮，当前网格的状态将被保存下来。现在，您可以刷新浏览器并点击“加载”，保存的状态将以红色显示。
 
从Three.js导出JSON格式非常简单，无需引入任何额外的库。你只需将THREE.Mesh导出为JSON，并将其存储在浏览器的localStorage中，如下所示：
 
const asJson = mesh.toJSON() 
localStorage.setItem('json', JSON.stringify(asJson))
 
在保存之前，我们首先使用JSON.stringify函数将toJSON函数返回的结果（一个JavaScript对象）转换为字符串。然后，利用HTML5本地存储来保存这些信息。
 
API，我们只需调用localStorage.setItem函数即可。第一个参数是键值（JSON），我们稍后可利用它来检索作为第二个参数传入的信息。 
这个JSON字符串看起来像这样：
 
“类型”:“网格”,“投射阴影”: true,“图层”: 1,“矩阵”:[0.5,...1],“几何体”:“15a98944-91a8-45e0-b974-0d505fcd12a8”,“材质”:“38e11bca-36f1-4b91-b3a5-0b2104c58029”}
 
如你所见，Three.js 会保存关于 THREE.Mesh 对象的所有信息。将 THREE.Mesh 加载回 Three.js 也只需几行代码，如下所示：
 
const fromStorage = localStorage.getItem('json')
 
如果(fromStorage){
 
const 结构 = JSON.parse(从存储中获取)
 
const loader = new THREE.ObjectLoader()
 
const mesh = loader.parse(结构)
 
mesh.material.color = new THREE.Color(0xff0000)
 
场景.add(网格)
 
}
 
首先，我们通过之前保存的名称（本例中为json）从本地存储中获取JSON数据。为此，我们使用了HTML5本地存储API提供的localStorage.getItem函数。接下来，我们需要将该字符串重新转换为JavaScript对象（使用JSON.parse），然后再将JSON对象转换回THREE.Mesh。Three.js提供了一个名为THREE.ObjectLoader的辅助对象，可用于将JSON转换为THREE.Mesh。在本示例中，我们直接调用了加载器的parse方法来解析JSON字符串。此外，加载器还提供了load函数，您可以在其中传入包含JSON定义的文件的URL。
 
正如你在这里看到的，我们只保存了一个 THREE.Mesh 对象，因此其他所有内容都会丢失。如果你想保存整个场景，包括灯光和摄像机，可以采用相同的方法来导出场景：
 
const asJson = scene.toJSON() 
localStorage.setItem('scene', JSON.stringify(asJson))
 
其结果是生成了一个完整的JSON场景描述：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.6_5_.png)
 
这可以按照我们之前为THREE.Mesh对象所展示的方式进行加载。虽然在仅使用Three.js进行开发时，将当前场景和对象存储为JSON格式非常方便，但这种格式并不便于与其他工具或程序进行交换或创建。在下一节中，我们将更深入地探讨Three.js支持的一些3D格式。
 
从3D文件格式导入
 
在本章开头，我们列出了Three.js支持的多种格式。在这一节中，我们将快速浏览其中几个格式的示例。
 
OBJ和MTL格式
 
OBJ和MTL是配套格式，通常一起使用。OBJ文件定义几何形状，而MTL文件则定义所使用的材质。OBJ和MTL都是基于文本的格式。OBJ文件的一部分看起来像这样：
 
v-0.032442 0.010796    0.025935
 
v-0.028519 0.013697    0.026201
 
v-0.029086 0.014533    0.021409
 
使用材质
 
s   1
 
MTL文件定义材质，如下所示：
 
OBJ 和 MTL 格式都得到了 Three.js 的良好支持，因此如果您希望交换 3D 模型，这是一个不错的选择。Three.js 提供了两种不同的加载器可供使用。如果您只想加载几何体，可以使用 OBJLoader。我们在示例（load-obj.html）中就使用了这个加载器。以下截图展示了该示例：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.7_15_.png)
 
从外部文件加载OBJ模型的方法如下：
 
在该代码中，我们使用OBJLoader从URL异步加载模型。这会返回一个JavaScript Promise，当Promise被解析时，其中将包含网格。模型加载完成后，我们会进行一些微调，并确保模型既能投射阴影，也能接收阴影。此外，
 
loadAsync，每个加载器还提供一个load函数，该函数不使用Promise，而是使用回调。同样的代码看起来会是这样：
 
在本章中，我们将采用基于Promise的loadAsync方法，因为这种方法可以避免嵌套回调，并使这类调用的链式处理变得更加简便。下一个示例（load-obj-mtl.html）使用了OBJLoader与MTLLoader，以加载一个模型并直接为其分配材质。以下截图展示了该示例：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.8_14_.png)
 
在查看代码之前，首先要说明的是：如果你收到一个OBJ文件、一个MTL文件以及所需的纹理文件，你需要检查MTL文件是如何引用这些纹理的。这些纹理引用应相对于MTL文件进行，而不能采用绝对路径。实际上，这段代码与我们之前看到的THREE.ObjLoader代码并没有太大区别。我们首先用一个THREE.MTLLoader对象加载MTL文件，然后通过setMaterials函数将加载的材质设置到THREE.ObjLoader中。
 
我们在此案例中所使用的模型较为复杂。因此，我们在回调中设置了一些特定属性，以解决若干渲染问题，具体如下：
 
• 我们需要合并模型中的顶点，以便将其渲染为平滑的模型。为此，我们首先需要从加载的模型中移除已定义的法线向量，以便能够使用BufferGeometryUtils.mergeVertices和computeVertexNormals函数，向Three.js提供正确渲染该模型所需的信息。
 
• 源文件中的不透明度设置有误，导致翅膀无法显示。因此，我们手动设置了不透明度和透明度属性以修复这一问题。
 
• 默认情况下，Three.js 只渲染对象的一侧。由于我们从两个方向观察翅膀，因此我们需要将 side 属性设置为 THREE.DoubleSide 值。
 
• 当需要将机翼叠加渲染时，它们会产生一些不需要的伪影。我们通过设置alphaTest属性解决了这个问题。 
但正如你所见，你可以轻松地将复杂模型直接加载到Three.js中，并在浏览器中实时渲染。不过，你可能需要对各种材质属性进行微调。
 
加载gLTF模型
 
我们之前已经提到，glTF 是在 Three.js 中导入数据时非常棒的格式。为了向您展示导入并呈现甚至复杂场景是多么简单，我们添加了一个示例：我们直接从 https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d 获取了一个模型：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.9_13_.png)
 
正如您从之前的截图中看到的，这并非一个简单的场景，而是一个复杂的场景，包含大量模型、纹理、阴影及其他元素。要在Three.js中实现这一点，我们只需执行以下操作：
 
你已经熟悉了异步加载器，我们唯一需要修复的地方就是确保材质的depthWrite属性设置正确（这似乎是某些glTF模型中常见的问题）。就这么简单——一切顺利运行。此外，glTF还允许我们定义动画，这一点我们将在下一章中更深入地探讨。
 
显示完整的乐高模型
 
除了定义顶点、材质、灯光等要素的3D模型之外，还有多种文件格式并不显式地定义几何体，而是具有更具体的用途。本节我们将要介绍的LDrawLoader加载器，就是为渲染乐高模型而开发的3D加载器。使用该加载器的方式与我们此前已多次见到的类似：
 
而且结果看起来真的很棒：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.10_8_.png)
 
如你所见，它展示了乐高套装的完整结构。市面上有许多不同的模型可供你选用：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.11_2_.png)
 
如果您想探索更多模型，可以从LDraw仓库下载：https://omr.ldraw.org/。 
加载基于体素的模型
 
另一种有趣的3D模型创建方法是使用体素。这种方法允许你用小立方体构建模型，并通过Three.js进行渲染。例如，你可以利用这种工具在Minecraft之外创建Minecraft风格的建筑结构，然后在稍后将其导入Minecraft中。一款可用于尝试体素的免费工具是MagicaVoxel（https://ephtracy.github.io/）。这款工具能让你创建像这样的体素模型：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.12_9_.png)
 
有趣的是，你可以使用 VOXLoader 加载器轻松地在 Three.js 中导入这些模型，方法如下：
 
在models文件夹中，你可以找到几个vox模型。以下截图展示了使用Three.js加载后的效果：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.13_3_.png)
 
下一个加载器是另一个非常具体的加载器。我们将探讨如何从PDB格式中渲染蛋白质。
 
显示来自PDB的蛋白质
 
PDB网站（www.rcsb.org）包含有关多种不同分子和蛋白质的详细信息。除了对这些蛋白质的说明外，该网站还提供了一种以PDB格式下载这些分子结构的方法。Three.js为PDB格式指定的文件提供了一个加载器。在本节中，我们将举例说明如何解析PDB文件并使用Three.js对其进行可视化。
 
借助此加载器，我们将根据提供的分子描述创建以下3D模型（请参阅load-pdb.html示例）：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.14_0_.png)
 
加载PDB文件的方式与之前格式相同，如下所示：
 
正如您从这段示例代码中看到的，我们实例化了一个THREE.PDBLoader对象，并将想要加载的模型文件作为参数传入。模型加载完成后，我们会对其进行处理。在本例中，该模型包含两个属性：geometryAtoms和geometryBonds。geometryAtoms中的位置属性存储了各个原子的位置，而颜色属性则可用于为各个原子着色。对于原子之间的连接，则使用geometryBonds。
 
根据位置和颜色，我们创建一个 THREE.Mesh 对象并将其添加到一个组中：
 
let sphere = new THREE.SphereGeometry(0.2)
 
let mesh = new THREE.Mesh(sphere, material) 
网格位置复制到起始位置
 
组.add(网格)
 
关于原子之间的连接，我们采用相同的方法。我们获取连接的起始和结束位置，并以此来绘制连接：
 
对于连接，我们首先使用THREE.CatmullRomCurve3创建一条三维路径。这条路径用作THREE.TubeGeometry的输入，用于在原子之间建立连接。所有连接和原子都被添加到一个组中，然后将该组添加到场景中。您可以从PDB下载许多模型。例如，以下截图显示了钻石的结构：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.15_6_.png)
 
在下一节中，我们将探讨Three.js对PLY模型的支持，该模型可用于加载点云数据。
 
从PLY模型加载点云
 
使用PLY格式与使用其他格式并没有太大区别。你只需包含加载器，并处理已加载的模型即可。不过，在这个最后一个示例中，我们将尝试一种不同的方法：我们不会将模型渲染为网格，而是利用该模型中的信息来创建一个粒子系统（请参阅以下截图中的load-ply.html示例）：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.16_4_.png)
 
用于呈现上述截图的 JavaScript 代码其实非常简单；它看起来像这样：
 
const texture = new THREE.TextureLoader().load('/assets/textures/particles/glow.png');  
const material = new THREE.PointsMaterial({  
  size: 0.15,  
  vertexColors: false,  
  color: 0xffffff,  
  map: texture,  
  depthWrite: false,  
  opacity: 0.1,  
  transparent: true,  
  blending: THREE.AdditiveBlending  
});  
return new PLYLoader().loadAsync('/assets/models/carcloud/carcloud.ply').then((model) => {  
  const points = new THREE.Points(model, material);  
}); 
264 创建和加载高级网格与几何体
 
点的缩放比例设置为0.7，0.7，0.7
 
场景.add(点)
 
})
 
如你所见，我们使用 THREE.PLYLoader 加载模型，并将该几何体用作 THREE.Points 的输入。我们所使用的材质与第7章“点和精灵”最后一个示例中采用的材质完全相同。正如你所见，借助Three.js，只需寥寥几行代码，就能轻松地整合来自不同来源的模型，并以多种方式对其进行渲染。 
其他装载机
 
在本章开头的“从外部资源加载几何体”部分，我们向您展示了Three.js提供的所有不同加载器列表。我们在第8章的源文件中提供了所有这些加载器的示例：
 

![image](https://damo-moshicloud-test.oss-cn-hangzhou.aliyuncs.com/document/testcase/dingding/zhiwen_cases/1449372840566210560/1449372840566210560_cut_Figure_8.17_1_.png)
 
所有这些加载器的源代码都遵循与本章中我们所讲解的加载器相同的模式。只需加载模型，确定要显示加载模型的哪一部分，确保缩放和位置正确，然后将其添加到场景中即可。
 
摘要
 
在Three.js中使用来自外部来源的模型并不难，尤其是对于简单模型——你只需执行几个简单的步骤即可。
 
在使用外部模型或通过分组与合并来创建模型时，有几点需要注意。首先，你需要记住：当你对对象进行分组时，这些对象仍可作为独立对象单独使用。应用于父级的变换也会影响子级，但你依然可以单独对子级进行变换。除了分组之外，你还可以将几何体合并在一起。采用这种方法后，你会失去各个独立的几何体，而得到一个全新的单一几何体。这在处理成千上万需要渲染的几何体并遇到性能问题时尤其有用。如果你希望控制大量具有相同几何形状的网格，最后一种方法是使用THREE.InstancedMesh对象或THREE.InstancedBufferGeometry对象。这两种对象允许你分别定位和变换每个网格，同时还能保持出色的性能。 
Three.js 支持大量外部格式。在使用这些格式加载器时，最好仔细查看源代码，并添加 console.log 语句，以确定所加载数据的真实面貌。这将有助于你了解为获得正确的网格并将其置于正确的位置和缩放比例所需采取的步骤。通常，当模型显示不正常时，问题往往出在材质设置上。可能是使用了不兼容的纹理格式、不透明度定义有误，或者格式中包含了指向纹理图像的错误链接。一般而言，建议先使用测试材质来确认模型本身是否已正确加载，并将加载的材质记录到 JavaScript 控制台，以便检查是否存在意外值。
 
如果您想重复使用自己的场景或模型，只需调用asJson函数将其导出，然后通过ObjectLoader重新加载即可。
 
你在本章以及前几章所使用的模型，大多是静态模型。它们没有动画效果，不会移动，也不会改变形状。在第9章中，你将学习如何为模型添加动画，让它们栩栩如生。除了动画之外，下一章还将介绍Three.js提供的各种相机控制功能。借助相机控制，你可以围绕场景移动、平移和旋转相机。
 
