# 作品学习

## dragonir

掘金主页

https://juejin.cn/user/2295436008498765/posts

github主页

https://github.com/dragonir/3d

作品页面

https://dragonir.github.io/3d/



## 其他文章

- 教你用three.js写一个炫酷的3D登陆页面

https://juejin.cn/post/7020571868314730532#heading-14

https://github.com/Yanzengyong/threejs-login-view

例子中有科技感十足的发光边框效果。实现方式，将图片作为div的背景图。

```scss
background-image: url('~@/assets/images/login_border.png');
background-repeat: no-repeat;
```



# 云图三维大前端团队

https://juejin.cn/user/3413341368236903

### 1、Three.js 基础入门介绍

https://juejin.cn/post/6972434946359033870

### 2、Three.js 之光源详解

https://juejin.cn/post/6975420252540633118

Three.js中光源有很多种，但是下面四种是最常用到的几种，分别是：

- 环境光（AmbientLight）
- 点光源（PointLight）
- 平行光 (DirectinalLight)
- 聚光灯 (SpotLight)

#### 环境光（AmbientLight）

```js
    // TOOD:添加光源
    var ambiColor = "#ff0000";
    var ambientLight = new THREE.AmbientLight(ambiColor);
    scene.add(ambientLight);
```

其中，hex是十六进制的RGB颜色信息，如红色表示为0xff0000。 环境光并不在乎物体材质的color属性，而是ambient属性。ambient属性的默认值是0xffffff，若将两个长方体设置为：

```js
    // TOOD：添加物体
    var greenCube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2),
      new THREE.MeshLambertMaterial({ color: 0x00ff00 }));
    greenCube.position.x = 3;
    scene.add(greenCube); //将实体添加到场景中

    var whiteCube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2),
      new THREE.MeshLambertMaterial({ color: 0xffffff }));
    whiteCube.position.x = -3;
    scene.add(whiteCube); //将实体添加到场景中
```

也就意味着ambient为`0x00ff00`的右边的长方体被渲染成了黑色。这是因为不透明物体的颜色其实是其反射光的颜色，而ambient属性表示的是**物体反射环境光的能力**。 对于`0x00ff00`的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于`0xffffff`的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。

当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，**作为整体光照的基础**。

#### 平行光（DirectinalLight）

```js
var light = new THREE.DirectionalLight();
light.position.set(2, 5, 3);
scene.add(light);
```

注意，这里设置光源位置并不意味着所有光从(2, 5, 3)点射出（如果是的话，就成了点光源），而是意味着，平行光将以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。只要平面是平行的，那么得到的光照也一定是相同的。



#### 聚光灯(SpotLight)

从官网上的定义： A point light that can cast shadow in one direction. 可以看出，[聚光灯](https://link.juejin.cn?target=http%3A%2F%2Fwww.yanhuangxueyuan.com%2Fthreejs%2Fdocs%2Findex.html%23api%2Fzh%2Flights%2FSpotLight)是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。 其构造函数为：

#### 阴影

### 3、Three.js 材质介绍

https://juejin.cn/post/6977667236576591908

#### 材质效果

在实际工作应用场景中，可以根据不同的场景需求选用不同的材质，这也是为什么Three.js提供了这几种基本材质的原因。因为是更复杂的材质会**消耗更多**的GPU功耗。在一个较慢的GPU上，比如说手机，一般使用一个不太复杂的材质来减少绘制场景所需的GPU功耗。同样，如果不需要额外的功能，那就使用最简单的材质，已达到最佳的性能。如果你不需要**照明和镜面高光**，那么就使用 MeshBasicMaterial 。

##### MeshStandardMaterial

接下来介绍一下图形学上经常提到的PBR，其全称是Physically Based Rendering，俗称物理渲染。Three.js提供了两种材质用于物理渲染，分别是`MeshStandardMaterial`与`MeshPhysicalMaterial`。

##### MeshPhysicalMaterial



各种标准材质的创建速度从最快到最慢顺序如下： **MeshBasicMaterial -> MeshLambertMaterial-> MeshPhongMaterial-> MeshStandardMaterial-> MeshPhysicalMaterial** 创建速度越慢的材质，做出的场景越逼真，但在低功率或移动设备上可能会有性能问题，所以在实际应用中需要根据具体场景进行优化。



#### 特殊材质

### 4、Three.js 相机介绍

https://juejin.cn/post/6980581966957674504

Three.js中相机有很多种，但是最长用到的有以下两种：

| 名称                           | 可视体 | 区别                                                         |
| ------------------------------ | ------ | ------------------------------------------------------------ |
| 正交相机（OrthographicCamera） | 长方体 | 无论物体距离相机距离远或者近，大小都保持不变。常用于制图、建模 |
| 透视相机（PerspectiveCamera）  | 四锥体 | 模拟人眼所看到的景象，它是3D场景的渲染中使用得最普遍的投影模式 |

### 5、 Three.js Sprite精灵

Three.js的精灵模型对象Sprite是一个**永远面向相机的平面**，没有z轴的概念，通常用来加载纹理、用作标签使用，注意Sprite没有背面，**它永远会正对着你**。所以我们可以用它来显示一些标签，当改变观看角度，标签也会随之改变角度。并且，sprite不接受阴影，计算机图形学中，精灵指包含于场景中的二维图像或动画，基类都是[Object3D](https://link.juejin.cn?target=http%3A%2F%2Fwww.yanhuangxueyuan.com%2Fthreejs%2Fdocs%2Findex.html%23api%2Fzh%2Fcore%2FObject3D),关于精灵模型对象Sprite的方法和属性除了可以查看文档[Sprite](https://link.juejin.cn?target=http%3A%2F%2Fwww.yanhuangxueyuan.com%2Fthreejs%2Fdocs%2Findex.html%23api%2Fzh%2Fobjects%2FSprite)，也可以查看基类Object3D。



### 6. 世界坐标与屏幕坐标

https://juejin.cn/post/6988082406964068360

#### 屏幕坐标系和标准设备坐标



在 ThreeJS 中，一个物体可看作一个 Mesh，Mesh 的坐标是用一个 Vector3 来表示的，Vector3 中包含了 x、y、z 坐标。**空间坐标系是三维的，其原点默认在屏幕中心**，且 x y z 的范围是 [-1,1]

### 7. Threejs缓冲区几何体

Three.js内置非常多的几何体，比如立方体(BoxGeometry)、圆（CircleGeometry）、圆锥(ConeGeometry)、圆柱(CylinderGeometry)和一些复杂高级的几何体。同时也提供了**自定义缓冲几何体(BufferGeometry)**，通过传入顶点数据，给使用者提供极大的灵活性。本文主要介绍自定义缓冲几何体（BufferGeometry）。

从原理上来讲，所有的几何体其本质在底层都是通过`BufferGeometry`与`BufferAttribute`进行表示。其对应的是webgl中的顶点缓冲对象。在`BufferGeometry`中包含了需要渲染用到的顶点相关属性，如位置、法线、颜色、uv等属性。

### 8、Three.js 纹理贴图



### 9、Three.js 层级模型

https://juejin.cn/post/6996173271309926437

### 10、Three.js 雾化

https://juejin.cn/post/6998441586388369445

### 11、Three.js 截屏等知识点

https://juejin.cn/post/7008810931467583502

在浏览器中，有两个有效的功能可以截取屏幕。旧的 [`canvas.toDataURL`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHTMLCanvasElement%2FtoDataURL) 和新的的 [`canvas.toBlob`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHTMLCanvasElement%2FtoBlob)

### 12、Three.js  按需加载

https://juejin.cn/post/7019258580356300836

### 13、Three.js 后期处理

后置处理通常是指应用到`2D`图像上的某种特效或者是滤镜。在`ThreeJs`的场景中，我们有由很多网格`(mesh)`构成的场景`(scene)`渲染成的`2D`图像。一般来说，图像被直接渲染成`canvas`，然后在浏览器中展示，然而在结果被输出到canvas之前，我们也可以通过另外的一个`render target`并应用一些后置效果。这被称为`Post Processing`，因为它发生在主场景渲染过程之后。



### 14、Three.js 一张画布渲染多个场景

https://juejin.cn/post/7032585465995722759

### 15、初探 THREE.JS 中的着色器材质并实现一个圆形的点效果



### 16、THREE.JS中的矩阵变换原理

https://juejin.cn/post/7057072772589027365

当两个变换矩阵A和B的积为P=AB时，则变换矩阵P相当于A和B所代表的变换。举一个例子，若A为旋转矩阵，B为平移矩阵，则矩阵P就能够实现旋转和平移变换。不过需要注意的是，矩阵乘法不符合交换律，因此AB和BA并不相等。

#### 为什么要用4×4矩阵？

为了解决三维矢量和4×4矩阵相乘的问题，我们机智的为三维矢量添加了第四个分量，这样之前的三维矢量(x,y,z)就变成了四维的(x,y,z,w)，这样由4个分量组成的矢量便被称为**齐次坐标**。需要说明的是，齐次坐标(x,y,z,w)等价于三维坐标(x/w,y/w,z/w)，因此只要w分量的值是1，那么这个齐次坐标就可以被当作三维坐标来使用，而且所表示的坐标就是以x，y，z这3个值为坐标值的点。 因此，为了和4×4矩阵相乘，我们的P1点坐标就变成了(x1,y1,z1,1)。而矩阵等式也变成了下面这个样子：

#### 总结

最后我们把目光放回Three.JS，总结一下。

> - 矩阵是一串数据的集合。
> - 在ThreeJS当中，矩阵主要被用于记录物体的变换过程（平移、旋转、缩放）。
> - 4×4矩阵是为了解决三维坐标系中平移变换和其他变换矩阵数据格式的一致性。



### 17、THREE.JS中的向量

https://juejin.cn/post/7065988218499366949

##### 1）知道两个点的位置，求两点组成的线段的方向向量

```js
const A = Vector3(0, 0, 0)
const B = Vector3(1, 2, 0)
const C = Vector3(-2, 1, 2)
const bc = C.clone().sub(B) // Vector3(-3, -1, 2) *注.sub方法会改变执行它的向量的值，使用之前需先克隆该向量
```

以上向量bc便是B点到C点的方向向量，同理可得C点到B点的方向即为bc的反向量，即bc.negate()

##### 2）知道线段的方向、长度以及其中一个端点，求另一个端点

##### 3）通过点积（dot）判断向量之间的夹角

向量B与向量C夹角的余弦值为B.clone().normalize().dot(C.normalize())。

##### 4）叉乘（cross）两个向量的叉乘所得向量与这两个向量同时垂直



点乘，也叫数量积。结果是一个向量在另一个向量方向上投影的长度，是一个标量。（向量的点积是向量a在向量b上的投影长度 乘以 向量b的长度）

叉乘，也叫向量积。结果是一个和已有两个向量都垂直的向量。

以我比较熟悉的图形学而言，一般点乘用来判断两个向量是否垂直，因为比较好算。也可以用来计算一个向量在某个方向上的投影长度，就像定义一样。

叉乘更多的是判断某个平面的方向。从这个平面上选两个不共线的向量，叉乘的结果就是这个平面的法向量。

两种不同的运算而已。

意义：**叉乘结果是一个向量，向量模长是向量A，B组成平行四边形的面积；向量方向是垂直于向量A,B组成的平面；**



作者：匿名用户
链接：https://www.zhihu.com/question/21080171/answer/17112284
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 18、Three.js简单动画

在一个成为**动画循环**的无限循环中，设置这个循环很简单，因为threejs通过`renderer.setAnimationLoop`方法为我们完成了所有的工作。

我们还将介绍一下`Clock`，一个简单的秒表类，我们可以使用它来保持动画同步，使用毫秒(`ms`)作为单位。

#### 2.创建循环`.setAnimationLoop`

使用threejs中的[`WebGLRenderer.setAnimationLoop`](https://link.juejin.cn/?target=https%3A%2F%2Fthreejs.org%2Fdocs%2F%23api%2Fen%2Frenderers%2FWebGLRenderer.setAnimationLoop)

```js
import { WebGLRenderer } from 'three';
const renderer = new WebGLRenderer();
// start the loop
renderer.setAnimationLoop(() => {
  renderer.render(scene, camera);
});
```

这时renderer.render一遍一遍的调用生成帧流，可以通过null作为回调来取消正在运行的循环

```js
// stop the loop
renderer.setAnimationLoop(null);
```

在内部，循环是使用[`.requestAnimationFrame`](https://link.juejin.cn?target=https%3A%2F%2Fdiscoverthreejs.com%2Fbook%2Fappendix%2Fdom-api-reference%2F%23drawing-animation-frames)这个内置的浏览器方法，可以智能地安排帧与显示器的刷新率同步，如果您的硬件跟不上，它会平滑地降低帧率。由于`.setAnimationLoop`是最近添加的，较旧的 three.js 示例和教程通常`.requestAnimationFrame`直接用于设置循环，这样做非常简单。

