<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BufferGeometry</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
    }

    div {
      width: 100%;
      height: 100%;
    }
  </style>  
</head>

<body>
  <div>
    <canvas id="yuntu"></canvas>
  </div>
</body>
<script type="module">
  import * as THREE from './three.module.js';

  function main() {
    const canvas = document.querySelector('#yuntu');
    const renderer = new THREE.WebGLRenderer({ canvas });

    const fov = 75;
    const aspect = 2;  // 默认值
    const near = 0.1;
    const far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 5;

    const scene = new THREE.Scene();

    {
      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(-1, 2, 4);
      scene.add(light);
    }

    //顶点数据
    const vertices = [
      // front
      { pos: [-1, -1, 1], norm: [0, 0, 1], uv: [0, 0], },
      { pos: [1, -1, 1], norm: [0, 0, 1], uv: [1, 0], },
      { pos: [-1, 1, 1], norm: [0, 0, 1], uv: [0, 1], },

      { pos: [-1, 1, 1], norm: [0, 0, 1], uv: [0, 1], },
      { pos: [1, -1, 1], norm: [0, 0, 1], uv: [1, 0], },
      { pos: [1, 1, 1], norm: [0, 0, 1], uv: [1, 1], },
      // right
      { pos: [1, -1, 1], norm: [1, 0, 0], uv: [0, 0], },
      { pos: [1, -1, -1], norm: [1, 0, 0], uv: [1, 0], },
      { pos: [1, 1, 1], norm: [1, 0, 0], uv: [0, 1], },

      { pos: [1, 1, 1], norm: [1, 0, 0], uv: [0, 1], },
      { pos: [1, -1, -1], norm: [1, 0, 0], uv: [1, 0], },
      { pos: [1, 1, -1], norm: [1, 0, 0], uv: [1, 1], },
      // back
      { pos: [1, -1, -1], norm: [0, 0, -1], uv: [0, 0], },
      { pos: [-1, -1, -1], norm: [0, 0, -1], uv: [1, 0], },
      { pos: [1, 1, -1], norm: [0, 0, -1], uv: [0, 1], },

      { pos: [1, 1, -1], norm: [0, 0, -1], uv: [0, 1], },
      { pos: [-1, -1, -1], norm: [0, 0, -1], uv: [1, 0], },
      { pos: [-1, 1, -1], norm: [0, 0, -1], uv: [1, 1], },
      // left
      { pos: [-1, -1, -1], norm: [-1, 0, 0], uv: [0, 0], },
      { pos: [-1, -1, 1], norm: [-1, 0, 0], uv: [1, 0], },
      { pos: [-1, 1, -1], norm: [-1, 0, 0], uv: [0, 1], },

      { pos: [-1, 1, -1], norm: [-1, 0, 0], uv: [0, 1], },
      { pos: [-1, -1, 1], norm: [-1, 0, 0], uv: [1, 0], },
      { pos: [-1, 1, 1], norm: [-1, 0, 0], uv: [1, 1], },
      // top
      { pos: [1, 1, -1], norm: [0, 1, 0], uv: [0, 0], },
      { pos: [-1, 1, -1], norm: [0, 1, 0], uv: [1, 0], },
      { pos: [1, 1, 1], norm: [0, 1, 0], uv: [0, 1], },

      { pos: [1, 1, 1], norm: [0, 1, 0], uv: [0, 1], },
      { pos: [-1, 1, -1], norm: [0, 1, 0], uv: [1, 0], },
      { pos: [-1, 1, 1], norm: [0, 1, 0], uv: [1, 1], },
      // bottom
      { pos: [1, -1, 1], norm: [0, -1, 0], uv: [0, 0], },
      { pos: [-1, -1, 1], norm: [0, -1, 0], uv: [1, 0], },
      { pos: [1, -1, -1], norm: [0, -1, 0], uv: [0, 1], },

      { pos: [1, -1, -1], norm: [0, -1, 0], uv: [0, 1], },
      { pos: [-1, -1, 1], norm: [0, -1, 0], uv: [1, 0], },
      { pos: [-1, -1, -1], norm: [0, -1, 0], uv: [1, 1], },
    ];
    const positions = [];
    const normals = [];
    const uvs = [];
    for (const vertex of vertices) {
      positions.push(...vertex.pos);
      normals.push(...vertex.norm);
      uvs.push(...vertex.uv);
    }

    const geometry = new THREE.BufferGeometry();
    const positionNumComponents = 3;
    const normalNumComponents = 3;
    const uvNumComponents = 2;
    geometry.setAttribute(
      'position',
      new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
    geometry.setAttribute(
      'normal',
      new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
    geometry.setAttribute(
      'uv',
      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));

    const loader = new THREE.TextureLoader();
    const texture = loader.load('xxxxxxx/images/xxxx.png');

    function makeInstance(geometry, color, x) {
      const material = new THREE.MeshPhongMaterial({ color, map: texture });

      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.x = x;
      return cube;
    }

    const cubes = [
      makeInstance(geometry, 0x88FF88, 0),
      makeInstance(geometry, 0x8888FF, -4),
      makeInstance(geometry, 0xFF8888, 4),
    ];

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      cubes.forEach((cube, ndx) => {
        const speed = 1 + ndx * .1;
        const rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();

</script>

</html>