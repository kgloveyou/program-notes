# 前端开发必知必会（从工程核心到前沿实战）

个人网站（http://www.houyuewei.cn）

GitHub（https://github.com/houyaowei）

微信公众号：开发365

代码地址（https://github.com/houyaowei/front-end-complete-book）

# 第1 章 前端开发核心及Deno Web 实战 

npm 查询模块命令

```sh
npm view vue
```

如果模块不存在，则返回404.

查看npm包的版本信息。

```sh
# 查看最新版本
npm view vue version	

# 查看所有版本
npm view vue versions
```



# 第2章 前端工程化核心与构建工具实战

## 2.7 构建工具实战

### 2.7.2 “新秀”Vite构建实战

 `yarn create vite-app vite-project` 命令相当于下面两条命令：（https://yarn.bootcss.com/docs/cli/create/）

```shell
$ yarn global add create-vite-app
$ create-vite-app vite-project
```

书中的实例是生成React项目。但是，最新版本的create-vite-app默认是生成vue项目。

可以指定目标模板：

```sh
$ npm init vite-app my-react-project --template react
```



# 第3章 前端核心模块的设计与实现

## 3.6 状态原理解析

代码位置：

```
chapter04\code\4.6Practise\state-mvp
```

http-server访问url：

http://127.0.0.1:8000/chapter04/code/4.6Practise/state-mvp/src/



# 第4章 性能优化指南

实际上，开发者可以用多种方式告知浏览器应如何应对某个资源，比如在<script>标签上添加async或 defer等属性，浏览器会异步加载和执行JavaScript代码，而不会阻塞渲染。

> `defer`和`async`的区别是：`defer`是在整个页面正常渲染结束后（DOM 结构完全生成，其他脚本也执行完）才会执行；而async是只要脚本下载完，渲染引擎就中断渲染，先执行这个脚本，再回到渲染流程。
>
> 需要注意的是，如果有多个defer脚本，则会按照它们在页面中定义的顺序进行加载；如果有多个async脚本，则不能保证加载顺序。



DOM事件的三个阶段：

- **捕获阶段**：事件从最顶层元素 window 一直传递到目标元素的父元素。
- **目标阶段**：事件到达目标元素，如果事件指定不冒泡，那就会在这里中止。
- **冒泡阶段**：事件从目标元素父元素向上逐级传递直到最顶层元素 window。

![https://segmentfault.com/img/bVDStC](https://segmentfault.com/img/bVDStC)

## 4.2 浏览器的缓存机制

**什么时候使用实体标签和最近修改日期呢？**

​    如果服务器回送一个ETag，则客户端必须使用实体标签验证器。如果服务器回送了一个Last-Modified值，则客户端可以使用 If-Modified-Since验证。如果都提供，那么客户端就可以随意选择。

## 4.4 前端优化策略

### 4.4.1 图片优化和DOM优化建议

1、减少图片

2、结果可以通过css结果完成

css3完成角、半透明、边框、阴影、动画等。

3、使用合适的图片格式



### 4.4.2 JavaScript代码优化建议

**1、JavaScript文件加载**

总结一下：defer是“渲染完再执行”，async是“下载完就执行”。

**2. JavaScript文件缓存**

Service Worker方式，它是PWA的核心。

**3、JavaScript代码细节优化**

（1）减少回流（重排）和重绘。

当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、可见性（这里的可见性特指visibility: hidden,，即不改变元素位置，在真实的DOM结构中元素依然存在，只是对可见性进行操作。而display:none对元素隐藏后，元素在DOM结构中就不存在了）等发生改变而需要重新构建时，浏览器需要重新计算元素的几何属性（很显然文档流中的其他属性也会跟着受影响），这就称为**回流**。在页面第一次加载时每个页面至少需要一次回流。

当渲染中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响元素的几何属性，比如color、background-color。这个操作称为**重绘**。从描述可以发现，回流必将引起重绘，而重绘不一定会引起回流。因为回流比重绘做的事情更多，带来的开销更大。



避免可能会引发回流和重绘的DOM操作。

- 避免操作DOM的几何属性。

- 避免改变DOM树结构。

- 避免获取一些特殊的值，client*(top，left，width，height)、offset、scoll等属性。



(2）对元素进行离线处理

  前面提过，如果元素设置为display:none ，那么该元素将从当前的文档流中“抽离”，从这个角度出发，我们可以把这个方法作为优化的一个手段。

（3）节流和防抖  

**节流**：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

```js
function throttle (func,time) {
	if(typeof func !== 'function') {
     throw new TypeError('need a function');
  }
	//记录上次执行的时间
	let precious = 0;
	return function(){
		let _this = this;
		let now = Date.now();
		if (now - precious > time ) {
			func.apply(_this, arguments);
			precious = now;
		}
	}
}
```



**防抖**：在持续触发事件时，如果一定时间段内没有触发事件，那么事件处理函数会再执行一次。如果在设定的时间到来之前，又一次触发了事件，就重新开始延时。

```js
function debounce (func,time) {
  if(typeof func !== 'function') {
    throw new TypeError('need a function');
  }
	let timeId = null;
	return function(){
		let _this = this;
		clearTimeout(timeId);
		timeId = setTimeout(() => {
			func.apply(_this, arguments)
		}, time);
	}
}
```

更多解释：

https://www.zoo.team/article/anti-shake-throttle

4）webworker介入数据密集型



### 4.4.3 Webpack优化

1、**基本优化方式**

减少文件的匹配范围

缓存babel-loader的结果

优化模块配置

增加external配置

借用dllPlugin提高打包速度

推荐使用ES Module。webpack会自动启用Tree Shaking.



### 4.4.4  使用HTTP/2

### 4.4.5 WebSocket



https://blog.csdn.net/u012343977/article/details/110943679



# 第5章  实战：从0开发微前端和WebAssembly

## 5.1 以天气为例实战PWA

PWA（Progressive Web App），为Web应用开发提供了一种完全离线的能力，提供瞬间加载的体验。

## 5.4 用WebAssembly提高前端性能

