# 前端面试题

# React

- React 的 diff 算法工作过程

- React 中的 setState 是同步还是异步

- React、Vue /Angular 的区别?（会根据你简历中写的技术栈来）

  https://vue3js.cn/interview/vue/vue.html#%E4%BA%94%E3%80%81vue%E5%92%8Creact%E5%AF%B9%E6%AF%94

  这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同

  ### [#](https://vue3js.cn/interview/vue/vue.html#相同点)相同点

  - 都有组件化思想
  - 都支持服务器端渲染
  - 都有Virtual DOM（虚拟dom）
  - 数据驱动视图
  - 都有支持native的方案：`Vue`的`weex`、`React`的`React native`
  - 都有自己的构建工具：`Vue`的`vue-cli`、`React`的`Create React App`

  ### [#](https://vue3js.cn/interview/vue/vue.html#区别)区别

  - 数据流向的不同。`react`从诞生开始就推崇单向数据流，而`Vue`是双向数据流
  - 数据变化的实现原理不同。`react`使用的是不可变数据，而`Vue`使用的是可变的数据
  - 组件化通信的不同。`react`中我们通过使用回调函数来进行通信的，而`Vue`中子组件向父组件传递消息有两种方式：事件和回调函数
  - diff算法不同。`react`主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。`Vue` 使用双向指针，边对比，边更新DOM

  

- React 中各种组件复用的优劣势（mixin、render props、hoc、hook）

- React 的 Fiber 架构

- React 性能优化

- React hooks 相关问题

- React新的生命周期，为什么 getDrivedStatefromProps 是静态的？

## react时间切片

react时间切片思想，最好吧计算机单处理器调度策略讲一下，然后说下react具体用了哪几种策略？说下为什么不用requestIdleCallback实现调度器？（币安二面）

## useContext,useMemo,useCallback

useContext,useMemo,useCallback作用和实现原理，它们为什么能提升渲染性能？（币安二面）

## react的副作用

聊一下react的副作用（币安二面）



# vue

vue $nextTick的具体实现，要具体到vue2和vue3用了哪些微任务和宏任务来实现异步更新，这些微/宏任务单特点。（币安二面）

# JS

## 函数柯里化

[「前端进阶」彻底弄懂函数柯里化](https://juejin.cn/post/6844903882208837645)

在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。

而对于Javascript语言来说，我们通常说的柯里化函数的概念，与数学和计算机科学中的柯里化的概念并不完全一样。

在数学和计算机科学中的柯里化函数，一次只能传递一个参数；

而我们Javascript实际应用中的柯里化函数，可以传递一个或多个参数。

### 如何封装柯里化工具函数

柯里化的定义，接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。

我们常用的工具库 lodash 也提供了 curry 方法，并且增加了非常好玩的 placeholder 功能，通过占位符的方式来改变传入参数的顺序。

## 闭包

函数嵌套函数，内部函数就是闭包。

正常情况下，函数执行完成，内部变量会被销毁。

闭包，内部函数没执行完成，外部函数变量不会被销毁。

https://www.bilibili.com/video/BV1E44y1z7XL?spm_id_from=333.999.0.0

闭包的应用：封装一段代码，实现模块化。

https://www.bilibili.com/video/BV1HK4y1g7fA/?spm_id_from=trigger_reload



作用域链：变量会在当前作用域内找，如果没有就继续往上找。

## 什么是防抖和节流？有什么区别？如何实现？

**1、防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间**

举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。

**节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率**

举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。

**2、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。**



防抖：用户触发事件过于频繁，只要取最后一次事件的操作；（只执行最后一次）

https://www.bilibili.com/video/BV1SU4y1G7Hw/?spm_id_from=trigger_reload

```js
function debounce(fn, delay) {
  let t = null;
  return function () {
    if (t != null) {
      clearTimeout(t);
    }
    t = setTimeout(() => {
      fn.call(this);
    }, delay);
  }
}
```

节流：控制高频事件执行次数

https://www.bilibili.com/video/BV1Qo4y1Q7AN/?spm_id_from=trigger_reload

```js
function throttle(fn, delay) {
    let flag = true;
    return function () {
        if (flag) {
            t = setTimeout(() => {
                fn.call(this);
                flag = true;
            }, delay);
        }
        flag = false;
    }
}
```

apulis nlp-frontend实现：

```ts
// 防抖
export const debounce = (fn, time = 1000) => {
  let timeout = null;
  return function d () {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, time)
  }
}

// 节流
export const throttle = (fn, time = 1000) => {
  let canRun = true;
  return function t () {
    if (!canRun) return;
    canRun = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      canRun = true;
    }, time)
  }
}

```



https://www.jianshu.com/p/9cdfff9edce1

## 手写 Promise

【前端面试】手写 Promise

https://zhuanlan.zhihu.com/p/272231637



大厂面试题手写Promise源码

https://www.cnblogs.com/lyt0207/p/12387564.html



## **重绘和重排**

https://www.cnblogs.com/yadongliang/p/10677589.html

一、重绘不一定需要重排，重排必然会导致重绘

1、重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

1）添加、删除可见的dom

2）元素的位置改变

3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）

4）页面渲染初始化

5）浏览器窗口尺寸改变

2、重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等

二、减少reflow、repaint

1、不要一条一条的修改DOM的样式，可以先定义好css的class，然后修改DOM的className。

2、不要把DOM结点的属性值放在一个循环里当成循环里的变量。

3、为动画的HTML元件使用fixed或absolute的position，那么修改他们的css是不会reflow

## 手写async pool

（币安二面）

# css

## 什么是 BFC

块级格式化上下文，`Block Formatting Context`

https://juejin.cn/post/6950082193632788493

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用`BFC`呢，`BFC`可以看做是一个`CSS`元素属性

**BFC触发方式**

1. 根元素，即HTML标签
2. 浮动元素：float值为 `left`、 `right`
3. overflow值不为 visible，为 `auto`、 `scroll`、 `hidden`
4. display值为 `inline-block`、 `table-cell`、 `table-caption`、 `table`、 `inline-table`、 `flex`、 `inline-flex`、 `grid`、 `inline-grid`
5. 定位元素：position值为 `absolute`、 `fixed`

**注意** display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。

https://mp.weixin.qq.com/s/J1Y3MkFNyJrY1M03gaDdhA#at

**BFC的规则**

`BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列

`BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签

垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠

计算`BFC`的高度时，浮动元素也参与计算

**BFC解决了什么问题**

1.使用Float脱离文档流，高度塌陷

2.Margin边距重叠

3.两栏布局



10 分钟理解 BFC 原理（※）

https://zhuanlan.zhihu.com/p/25321647



## 你所不知道的scroll事件：为什么scroll事件会失效？

JavaScript事件有两个阶段——（1）**捕获阶段(Capture Phase)**（2）**冒泡阶段(Bubble Phase)**。捕获阶段是事件从`document`到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到`document`的过程。

https://ayase.moe/2018/11/20/scroll-event/

# HTTP

## 强缓存和协商缓存

[你知道304吗？图解强缓存和协商缓存](https://juejin.cn/post/6974529351270268958#heading-26)

# 后端

## 控制反转和依赖注入

什么事控制反转和依赖注入，具体使用场景（币安二面）

# html



# 安全







# 艰难环境下，面腾讯、美团、商汤科技等七家大厂前端有感

https://mp.weixin.qq.com/s/Jw98JPgFjHwCzNIjtu9W7g

## **1. 美团**

**一面**

1. 曾经做过的最有挑战的一个项目

2. DOM 的事件机制，怎么阻止事件捕获

   JavaScript事件有两个阶段——（1）**捕获阶段(Capture Phase)**（2）**冒泡阶段(Bubble Phase)**。捕获阶段是事件从`document`到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到`document`的过程。

   https://ayase.moe/2018/11/20/scroll-event/

   DOM2 Events 为事件处理程序的赋值和移除定义了两个方法： addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值， true 表示在捕获阶段调用事件处理程序， false（默认值）表示在冒泡阶段调用事件处理程序。  

   ```js
   e.stopPropagation()  
   ```

   用于取消所有后续事件捕获或事件冒泡。只有 bubbles为 true 才可以调用这个方法  

   ```js
   e.stopImmediatePropagation()  
   ```

   用于取消所有后续事件捕获或事件冒泡，并阻止调用何后续事件处理程序（ DOM3 Events 中新增）  

   

   那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？

　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生

​		示例：https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation

1. 常用的 ES6 语法有哪些，var 怎么实现let

   https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133

2. React Hooks vs Component

   

3. React中的 useCallback 和 useMemo 有什么区别，什么情况下需要用 useCallback

   [React.memo、useMemo和useCallback](./react/index.md)

   [React的memo和useMemo的作用](https://juejin.cn/post/6897038904914870286)

4. 浏览器的 Event Loop 机制

   

5. setState 是同步还是异步的

6. Set 的用法，用 Set 实现数组去重

7. Graphql 的使用

8. 移动端适配方案, rem 和 em 的区别

   https://zhuanlan.zhihu.com/p/94369298

   对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素。**

   **em**

   - 子元素字体大小的em是相对于父元素字体大小
   - 元素的width/height/padding/margin用em的话是相对于该元素的font-size

   em/rem：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。

9. React 解决了什么问题

   https://segmentfault.com/a/1190000019042501

10. 前端跨域怎么做

    前端常见跨域解决方案（全）

    https://segmentfault.com/a/1190000011145364

    - 通过jsonp跨域

    - document.domain + iframe跨域、location.hash + iframe跨域、window.name + iframe跨域

    - postMessage跨域

    - 跨域资源共享（CORS）

      ```js
      // 前端设置是否带cookie
      xhr.withCredentials = true;
      ```

      

    - nginx代理跨域

    - Nodejs中间件代理跨域

    - WebSocket协议跨域

11. 编程题：用 setTimeout 实现 setInterval

https://www.jianshu.com/p/32479bdfd851

```js
function mySetInterval(fn, millisec){
  function interval(){
    setTimeout(interval, millisec);
    fn();
  }
  setTimeout(interval, millisec)
}
```

**二面**

1. Vue 的双向绑定机制

2. 字节小程序和微信小程序区别

3. React Fiber 机制

   https://juejin.cn/post/7020220688719937573

   其实 Fiber 这一概念并非由 React 定义。Fiber 本义为纤维，在计算机科学中含义为**纤程**，是一种**轻量级**的执行线程。

   遵从上述原则，从上我们可以了解到，线程控制离不开**保持帧的渲染**，所以在实现方案上很自然的就想到 `requestAnimationFrame` 这个API，与之相关的还有 `requestIdleCallback`。

`requestIdleCallback`方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件。

看起相当完美，`requestIdleCallback`仿佛是因此而生一般，Fiber 的早期版本确实却是使用了这样的方案，不过这已经是**过去式**了。在19年的一次更新中，React 团队推翻之前的设计，使用了 `MessageChannel` 来实现了对于线程控制。

React 将上述的集中兼容处理做一封装，最终得到一个与 `requestIdleCallback` 类似的函数 `requestHostCallback`

这种数据结构之所以被叫做fiber，因为fiber的翻译是纤程，它被认为是协程的一种实现形式。协程是比线程更小的调度单位：它的开启、暂停可以被程序员所控制。具体来说，react fiber是通过`requestIdleCallback`这个api去控制的组件渲染的“进度条”。

现在，可以总结一下了：React Fiber是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件更新的流程可以被中断恢复；它把组件渲染的工作分片，到时会主动让出渲染主线程。



4. React Hooks 的原理

5. Node 遇到过哪些性能问题

6. Node 做耗时的计算时候，如何避免阻塞

7. 低代码平台运行时的生成逻辑

8. 低代码平台性能优化

9. 低代码平台组件发布流程

10. 上家公司做了哪些事情以及做事的流程

11. 未来职业规划

12. 感兴趣的工作方向

13. 编程题：输入两个数组 [1,2,3,2,1], [3,2,1,4,7]  返回公共的并且长度最长子数组的长度

**三面**

1. 大文件的分片上传和断点续传怎么做的
2. 抖音APP 与 H5 如何通信
3. 现在需要用新技术，需要从哪些方面思考
4. 如何针对性能指标做优化，有没有了解过业界的性能指标统计方式
5. Express 和 Koa 的区别
6. 项目经历
7. 推动过什么事情
8. 对下一份工作的期望

## **2. 商汤科技**

**一面**

1. less-loader 的 less 转成 css 的底层原理

   https://juejin.cn/post/6944668149849522213

   less-loader的原理很简单，就是调用less库提供的方法，转译less语法后输出，如下：

   ```js
   // less-loader实现（经简化）
   const less = require('less');
   module.exports = function (content) {
     const callback = this.async(); // 转译比较耗时，采用异步方式  
     const options = this.getOptions(); // 获取配置文件中less-loader的options    
     less.render(content, createOptions(options), // less转译的配置    
       (err, output) => {
         callback(err, output.css);
         // 将生成的css代码传递给下一个loader    
       });
   };
   ```

   

2. webpack的 loader 和 plugin 区别

   https://juejin.cn/post/6944349196539396133

   `Loader`是一个模块转换器，将非JS模块转换成JS模块，供webpack进行打包处理。

   非js模块即样式文件（.css、.less、.scss等），非标准JS文件（.ts、.jsx、.vue），以及其他类型的文件（svg、png | jpg | jpeg等）。

   `Plugin`是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。

   常用的loader:

   - babel-loader

     此 package 允许你使用 [Babel](https://github.com/babel/babel) 和 [webpack](https://github.com/webpack/webpack) 转译 `JavaScript` 文件。

   - less-loader-->postcss-loader-->css-loader-->style-loader

     ```js
     {
         test: /\.less$/i,
             include: [
                 /[\\/]node_modules[\\/].*antd/,
                 /[\\/]node_modules[\\/].*ant-design/,
                 path.resolve(__dirname, './node_modules/@apulis/aistudio-layout'),
                 path.resolve(__dirname, './node_modules/@apulis/table'),
                 path.resolve(__dirname, './node_modules/@apulis/select-lang'),
                 path.resolve(__dirname, './node_modules/@apulis/group-selector')
             ],
                 use: [
                     'style-loader',
                     {
                         loader: 'css-loader',
                         options: {
                             importLoaders: 2,
                         },
                     },
                     'postcss-loader',
                     {
                         loader: 'less-loader',
                         options: {
                             lessOptions: {
                                 modifyVars: {
                                     'primary-color': '#4168AA',
                                     'link-color': '#4168AA',
                                     'border-radius-base': '2px',
                                 },
                                 javascriptEnabled: true,
                             },
                         }
                     },
                 ],
     },
     ```

     

   - sass-loader

     ```js
     {
         test: /\.(css|scss)$/,
             use: [
                 'style-loader',
                 {
                     loader: 'css-loader',
                     options: {
                         importLoaders: 2,
                     },
                 },
                 'postcss-loader',
                 'sass-loader',
             ],
     },
     ```

     

   - file-loader

     ```js
                 {
                     test: /\.(png|jpe?g|gif)$/i,
                     use: [
                         {
                             loader: 'file-loader',
                         },
                     ],
                 },
     ```

     

   - react-svg-loader

     ```js
                 {
                     test: /src[\s\S]*\.svg$/,
                     exclude: /node_modules/,
                     use: [
                         'babel-loader',
                         {
                             loader: 'react-svg-loader',
                             query: {
                                 svgo: {
                                     plugins: [{ pretty: true }, { cleanupIDs: false }],
                                 },
                             },
                         },
                     ],
                 },
     ```

     

   - worker-loader

     ```js
                 {
                     test: /\.worker\.js$/,
                     exclude: /3rdparty/,
                     use: {
                         loader: 'worker-loader',
                         options: {
                             publicPath: '/AIStudio/admagic/',
                             name: '[name].[contenthash].js',
                         },
                     },
                 },
     ```

     

   - 

3. webpack 常用插件

   

4. webpack 如何做代码拆分

   https://juejin.cn/post/6844904175235514375

5. webpack tree shaking 原理

   https://juejin.cn/post/7019104818568364069

   

   https://juejin.cn/post/7004297344300777502

   首先，要明确一点：**Tree Shaking 只支持 ESM 的引入方式，不支持 Common JS 的引入方式。**

   

6. webpack 动态导入原理

7. webpack 热更新原理

8. webpack5 新特性

9. esm 和 commonjs 的区别

10. TS 的 type 和 interface 的区别

    https://juejin.cn/post/6844903749501059085

11. TS 怎么做枚举

12. TS 泛型

13. canvas 绘制流程，canvas 里的图片跨域怎么处理

    https://juejin.cn/post/6856555980415582216

    https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/

14. 项目经历：babel 插件的实现

15. 编程题：实现一个深拷贝

    [实现一个深拷贝](https://juejin.cn/post/6979746364603236389#heading-8)

    > 我们在开发中经常会遇到需要使用深拷贝的场景，简单些的可能就直接用 JSON.parse(JSON.stringify(target)) 来实现，复杂点的可能会使用 lodash 的 cloneDeep，很少会自己去实现一个深拷贝。虽然知道使用递归去实现，但试过之后发现还是有许多需要注意的地方的。

    **借助 JSON 实现**

    ```js
    JSON.parse(JSON.stringify(target))
    ```

    缺点也很明显，会忽略掉 function 和 undefined，正则表达式，Map，Set 等会变成空对象: `{}`，而且对象存在循环引用的时候会报错。但是如果确定要拷贝的目标对象不存在这些类型时用起来还是很方便的。

    **递归实现简单版本**

    

**二面**

1. 链表和线性表 crud 比较

2. 了解哪些设计模式，实现其中一个设计模式

3. canvas 绘制流程，遇到了哪些问题

   [使用canvas绘制流程步骤是怎么样的](https://m.yisu.com/zixun/285520.html)

   1.定义canvas画布
   2.获取画布实例
   3.使用画布实例方法绘制

   

4. 从输入URL到浏览器显示页面过程中都发生了什么？

5. 移动端布局方案

6. 浏览器 Event Loop

7. 对图形绘制了解多少

8. ES6 为什么要转成 ES5

   简单答案就是：为了浏览器兼容，以及为了在 node.js 环境可以顺畅运行应用程序。

   老的浏览器不支持 ES6 语法，因此需要转成兼容性更好的 ES5。

   在 node.js 环境中，node 对 ES6 的支持一直被诟病，到了 13 版本之后，才出了模块模式（在 package.json 中增加一句：“type”: “module”），但有些库仍然不支持 ES6 语法。因此，如果你的 node.js 程序遇到不认识 ES6 语法的时候，请使用 Babel 转码一下也许就能解决问题。

   https://blog.csdn.net/henryhu712/article/details/115312311

9. H5 开发时遇到了哪些问题，怎么定位的

10. DOM 事件流

    

11. 平时怎么做性能优化

    

12. 最有亮点的两个项目

**三面**

1. HTTPS 加解密过程

2. 哈希表原理，哈希碰撞时怎么处理

   - 开放寻址法

     又分为线性探测、二次探测、双重散列等多种。

   - 链表法

   https://juejin.cn/post/7057701091865001992

3. 内存回收机制

   [浏览器内存回收机制](./browser/garbage.md)
https://zxpsuper.github.io/Demo/advanced_front_end/browser/garbage.html#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95


4. 栈内存和堆内存的概念

   https://juejin.cn/post/6844903873992196110

5. 线上错误监控怎么做

6. CI/CD 流程，有哪些改进点

7. 进程间如何通信

   https://cloud.tencent.com/developer/article/1690556

8. 低代码平台的实现

9. 对下一份工作的期望

## **3. 神策**

**一面**

1. CSS 预处理器对比

2. CSS 定位有哪些取值

3. 原型与原型链，函数怎么实现继承

   理解Javascript的原型和原型链

   https://segmentfault.com/a/1190000021787756

   Javascript对象都有一个叫做**原型**的公共属性，属性名是**_\*proto_\***。这个**原型**属性是对另一个对象的引用，通过这个**原型**属性我们就可以访问另一个对象所有的属性和方法。

   在Javascript中如果访问一个对象本身不存在的属性或是方法，就首先在它的原型对象上去寻找，如果原型对象上也不存在，就继续在原型对象的原型对象上去寻找，直到找到为止。那么原型对象有尽头么？所有对象的原型尽头是**Object.prototype**,那么**Object.prototype**这个对象的**_\*proto_\***指向啥呢？答案是`null`。我们日常开发中用到的绝大多数对象的**_\*proto_\***基本不会直接指向**Object.prototype**,基本都是指向另一个对象。比如所有的函数的**_\*proto_\***都会指向**Function.prototype**,所有数组的**_\*proto_\***都会指向**Array.prototype**。

4. this的指向，call、apply的区别

5. Vue 3.0 和 2.0 区别

   [Vue 3.0 和 Vue 2.0的对比以及Vue 2.0精讲以及Vue全家桶精讲](https://juejin.cn/post/6844903900999319560)

   [Vue3.0 新特性以及使用经验总结](https://juejin.cn/post/6940454764421316644)

6. Vue.$nextTick 作用

   [Vue中$nextTick源码解析](https://juejin.cn/post/6844904147804749832)

   也就是说我们在设置`this.msg = 'some thing'`的时候，Vue并没有马上去更新DOM数据，而是将这个操作放进一个队列中；如果我们重复执行的话，队列还会进行去重操作；等待**同一事件循环中**的所有数据变化完成之后，会将队列中的事件拿出来处理。

     这样做主要是为了提升性能，因为如果在主线程中更新DOM，循环100次就要更新100次DOM；但是如果等事件循环完成之后更新DOM，只需要更新1次。还不了解事件循环的童鞋，可以看我的另一篇文章[从一道面试题来理解JS事件循环](https://link.juejin.cn?target=http%3A%2F%2Fxieyufei.com%2F2019%2F12%2F30%2FQuiz-Eventloop.html)

     为了在数据更新操作之后操作DOM，我们可以在数据变化之后立即使用`Vue.nextTick(callback)`；这样回调函数会在DOM更新完成后被调用，就可以拿到最新的DOM元素了。

   

7. Vue 和 React 的 diff 有什么区别

   https://juejin.cn/post/6978370715573714952#heading-4

   ### 相同点

   - 都是两组虚拟dom的对比(react16.8之后是fiber与虚拟dom的对比)
   - 只对同级节点进行对比，简化了算法复杂度
   - 都用key做为唯一标识，进行查找，只有key和标签类型相同时才会复用老节点
   - 遍历前都会根据老的节点构建一个map，方便根据key快速查找

   ### 不同点

   - react在diff遍历的时候，只对需要修改的节点进行了记录，形成effect list，最后才会根据effect list 进行真实dom的修改，修改时先删除，然后更新与移动，最后插入
   - vue 在遍历的时候就用真实dom`insertBefore`方法，修改了真实dom，最后做的删除操作
   - react 采用单指针从左向右进行遍历
   - vue采用双指针，从两头向中间进行遍历
   - react的虚拟diff比较简单，vue中做了一些优化处理，相对复杂，但效率更高

   

8. proxy 拦截器的用法

   [Proxy](https://es6.ruanyifeng.com/#docs/proxy)

9. DNS 解析流程

   https://segmentfault.com/a/1190000023694985

   **DNS查询步骤**

   假设一台主机想知道y.abc.com这个域名的IP地址，那么整个的查询过程如下：

   1. 主机先向其本地域名服务器进行递归查询
   2. 本地域名服务器采用迭代的查询，它先向根域名服务器查询
   3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址。
   4. 本地域名服务器向顶级域名服务器发起查询。
   5. 顶级域名服务器告诉本地域名服务器，下一次应查询的权限域名服务器IP地址
   6. 本地域名服务器向权限域名服务器发起查询。
   7. 权限域名服务器告诉本地域名服务器所查询的IP地址。
   8. 本地域名服务器把查询结果告诉主机

   给这个过程做个图示，就是这样的

   ![](https://image-static.segmentfault.com/427/450/4274508305-5f3dd97e6b8ba_fix732)

10. 事件循环

11. 闭包和内存泄漏

12. 最有亮点的一个项目 

**二面**

1. HTTP 幂等性定义和常用方法的幂等性

   一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。

   HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。

   HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。

   HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。

   HTTP PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性。

   

2. redux 单向数据流有哪些优势，redux 中间件实现原理

3. React HOC vs renderProps

4. 浏览器里的线程与进程

5. requestAnimationFrame 与 requestIdleCallback 的区别

   [深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）](https://juejin.cn/post/6844904165462769678)

   通过本文的学习过程，我自己也打破了很多对于 Event Loop 以及 rAF、rIC 函数的固有错误认知，通过本文我们可以整理出以下的几个关键点。

   1. 事件循环**不一定**每轮都伴随着重渲染，但是如果有微任务，一定会伴随着**微任务执行**。
   2. 决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。
   3. `requestAnimationFrame`在重新渲染屏幕**之前**执行，非常适合用来做动画。
   4. `requestIdleCallback`在渲染屏幕**之后**执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 `timeout`参数。
   5. `resize`和`scroll`事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 `EventTarget` 上。

   

   

   ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/21/172362067212340f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

   我们都知道 `requestIdleCallback` 是浏览器提供给我们的空闲调度算法，关于它的简介可以看 [MDN 文档](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestIdleCallback)，意图是让我们把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等等。

   React 的时间分片渲染就想要用到这个 API，不过目前浏览器支持的不给力，他们是自己去用 `postMessage` 实现了一套。

   

6. npm管理痛点，如何解决

   

7. git flow流程、分支管理

8. websocket建立连接过程

   [WebSocket 的连接建立过程](https://www.jianshu.com/p/bae7ea3e9adb)

   > 1、 客户端发送GET 请求， upgrade
   > 2、服务器给客户端 switching protocol
   > 3、就进行了webSocket的通信了

具体内容：

> 1、发送一个GET请求
> 关键:
> Upgrade: websocket
> Connection: Upgrade

> 这两个就告诉服务器，我要发起websocket协议，我不是HTTP。

> 2、服务器收到了协议，返回一个 Switching Protocol， 这样就连接成功了

> 3、接下来的通信都是websocket， 这样就很好的连接了



[WebSocket 通信过程与实现](https://segmentfault.com/a/1190000014643900)



WebSocket 是一种基于 `ws(非加密) / wss(加密)` 协议的技术，使用这种技术可以建立客户端和服务器端双向且持续的通信连接，并且这**不受同源策略限制**。

与 HTTP 一样，WebSockets 也基于传输控制协议 (TCP)。建立 WebSocket 连接的初始请求是标准 HTTP 请求。然后，服务器应以 **101** 状态代码响应。它告诉浏览器它同意将协议从 HTTP 更改为 WebSockets。如果连接成功，服务器可以通过此连接向客户端发送更新。这些更新也称为消息或帧。客户端不需要进一步的请求来让服务器与浏览器对话，这与 HTTP 不同，在 HTTP 中，您总是首先需要一个请求，以便服务器可以响应它。



9. 组件/工具库打包时的格式输出，如:CommonJS、ESM、UMD等，他们之间有什么区别

   [什么是amd、commonjs、umd、esm](https://juejin.cn/post/6844903978333896718#heading-4)

   ### amd

   总结如下：

   - 异步加载
   - 其被提出，主要用于客户端browser
   - 其语法不直观，没有commonjs便于书写

   ### commonjs

   总结如下：

   - 语法类似于node，因为node使用commonjs规范
   - commonjs导入模块是同步导入
   - 主要用于后端，客户端用的话需要通过[Browserify](https://link.juejin.cn/?target=http%3A%2F%2Fbrowserify.org%2F)
   - 书写直观

   ### umd

   其是amd和commonjs的统一规范，支持两种规范，即写一套代码，可用于多种场景。其用法如下：

   - 前后端均通用
   - 与CJS或AMD不同，UMD更像是一种配置多个模块系统的模式。
   - UMD在使用诸如Rollup/ Webpack之类的bundler时通常用作备用模块

   ### ESM

   ESM是ES6提出的标准模块系统，相信大家都用过

   - 很多浏览器开始支持
   - 拥有类似commonjs的写法和同、异步加载机制
   - 能通过设置type=module，用于html中
   - node也开始支持

   相信未来esm是趋势。

   

10. Http 301、302 状态码的区别

    301是永久重定向，302是临时重定向。

    https://zhuanlan.zhihu.com/p/110941264

    https://www.cnblogs.com/zhuzhenwei918/p/7582620.html

11. H5 性能优化 

12. 编程题：设计一个flat函数将如下数组arr=[1,2,['3',4,'5',[6,[7,8],9]]]输出为1,2,'3',4,'5',6,7,8,9。至少写出两种方法,要求不能改变数组中的原始数据类型

**三面**

1. BI 可视化系统介绍
2. 在字节之后的提升有哪些
3. 目前前端可以做的优化有哪些
4. 新旧系统重构的时候，怎么过渡上线
5. Vue React 的区别
6. 字节小程序介绍一下
7. 自己未来的规划。自己的优缺点、周围人人对自己的评价
8. 如何学习一门新技术
9. 对神策数据的了解
10. 对大数据的了解

## **4. 王者荣耀**

**一面**

1. 进程通信的几种方式
2. TCP/IP 如何保证传输稳定性
3. 对称加密和非对称加密的使用场景
4. 浏览器帧卡顿检测
5. Vue 和 React的设计理念
6. 性能指标FP、FCP和FMP分别跟哪些因素有关
7. 低代码平台的技术原理
8. 业界其他低代码平台实现方式，对比差异
9. nginx怎么做反向代理与负载均衡
10. 编程题：设计和实现一个 LRU (最近最少使用) 缓存机制，满足：1.获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。2.写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。

##  **5. 天眼查**

**一面**

1. JS 有哪些数据类型

2. JS 数据类型识别的方式，有什么缺点

3. 原型和原型链，函数怎么实现继承

4. new 发生了什么

5. symbol 类型的用法

6. script 标签里分别设置 defer 和 async， 它们的执行顺序是怎么样的

   

7. React router 的两种模式，怎么动态获取路由上的 id

   [说说React Router有几种模式？实现原理？](https://vue3js.cn/interview/React/React%20Router%20model.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

   - hash 模式：在url后面加上#，如http://127.0.0.1:5500/home/#/page1
   - history 模式：允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录

   ```tsx
   const id = +own.match.params.id;
   ```

   其中：`own: Props`

   

8. redux 中间件的实现原理

9. React 的 purecomponent 和 component 的区别

   [React PureComponent 学习及浅比较详解](https://www.jianshu.com/p/eaf64bd66fd4)

   [react如何通过shouldComponentUpdate来减少重复渲染](https://segmentfault.com/a/1190000016494335)

10. generator 函数的用法

11. React diff 节点对比的过程

    [解析React Diff 算法](https://juejin.cn/post/6844903944796258317)

12. Vite 打包工具的使用

13. 箭头函数和普通函数区别

14. 什么是执行上下文

15. 堆内存和栈内存，数组存储在堆内存还是栈内存

16. HTTP2.0 相较于 HTTP1.0 的改进

    [一文总结http1.0，http1.1，http2，http3，面试强心剂](https://juejin.cn/post/7001510315514937375)

    - htpp2头部压缩

    - http2多路复用

17. isNaN和number.isNaN区别

18. 闭包和内存泄漏

19. setState 是同步还是异步的

20. HTTP 与 HTTPS 的区别

    HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer）,即HTTP下加入SSL层，HTTPS的安全基础是SSL，

    

    HTTP是`明文传输`，不安全的，HTTPS是`加密传输`，安全的多

    HTTP标准端口是`80`，HTTPS标准端口是`443`

    HTTP不用认证证书`免费`，HTTPS需要认证证书`要钱`

    `连接方式不同`，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次

    HTTP在OSI网络模型中是在`应用层`，而HTTPS的TLS是在`传输层`

    HTTP是`无状态`的，HTTPS是`有状态`的


    链接：https://juejin.cn/post/6994629873985650696


​    

21. React Hooks 的 useState 为什么不能放到条件语句

    这是因为React通过单链表来管理Hooks。

    ![](https://img-blog.csdnimg.cn/345fad8ae0e74dd2912a10ae77018a25.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY2FrZV9lYXQ=,size_20,color_FFFFFF,t_70,g_se,x_16)

update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。

[烤透 React Hook](https://juejin.cn/post/6867745889184972814)



22. 解释下浏览器的同源策略

## **6. 酷家乐**

**一面**

1. Node 怎么做性能监控

2. React diff 节点移动的具体过程

3. 讲一讲浏览器缓存

   

4. ES5 最优的一种函数继承，静态属性怎么做继承的

5. 前端怎么做性能监控

6. V8 引擎对垃圾回收的优化

7. 导致内存泄漏的方法，怎么监控内存泄漏

8. 作用域和执行上下文区别

9. this的指向问题

10. Array方法，forEach、map 对比

11. for of 和 for in 区别；for of 循环数组时怎么拿到数组索引

12. 移动端布局方案；怎么设置根元素的font-size大小的

13. Webpack bundle、chunk、module的区别

14. Webpack 热更新原理，怎么找到对应的局部模块做更新的

15. 项目经历：babel插件的实现

## **7. 中国人寿**

**一面**

1. HTTP2.0 和 HTTP1.0 的区别，HTTP2.0 有什么缺点

   [一文总结http1.0，http1.1，http2，http3，面试强心剂](https://juejin.cn/post/7001510315514937375)

2. 闭包及闭包的使用场景

   https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9

   https://segmentfault.com/a/1190000039370942

3. 实现一个侧边栏组件思路

4. 浏览器缓存机制

5. 重排与重绘，怎么减少重排

6. DOM 事件机制，不会冒泡的事件

7. cookie 和 session 的区别

8. sql 相关操作，增删查改

9. web 安全，xss、csrf 攻击特点及防御方式

## 8、深信服

1.get和post请求的区别

2.项目的上线流程

3.Vue中key值为什么不能用索引

在vue中为什么不推荐用 index 做 key（https://www.zoo.team/article/vue-index）

5.Async和Await原理

6.手写Promise.all()

https://www.jianshu.com/p/90b6280dd1b6

7.leetcode：三数之和

8.webpack原理

9.webpack的loader和plugin区别

https://juejin.cn/post/6944349196539396133

https://juejin.cn/post/6944668149849522213

Loader是一个模块转换器，将非JS模块转换成JS模块；

Plugin是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。

# [web前端面试 - 面试官系列](https://vue3js.cn/interview/)



# [木易杨前端进阶](https://muyiy.cn/)



# https://github.com/pfan123/Articles

# 字节二面

1、幻影依赖

假设a依赖b，项目中使用npm/yarn安装a后，依赖拍平，node_modules下出现了b，这时候b就是幻影依赖，可以使用pnpm解决这一问题。

2、babel preset和plugin的区别

3、git-hook

4、lodash的get实现

5、monorepo

6、git如何用命令打tag

# 虾皮一面

1、`<meta name='viewport'/>`在手机上怎么设置的？要注意的点。

2、em与rem的区别？

​	em：font-size是相对于父元素的font-size；width/height等是相对于自身的font-size。

​	rem：相对于html根元素的font-size。

​	使用场景：

- 在视觉稿要求固定尺寸的元素上使用px。比如1px线，4px的圆角边框。

- 在字号、（大多数）间距上使用rem。

- 慎用em。

3、NodeJS默认是单线程还是多线程，单线程和多线程的适用场景。

​	默认是单线程，但是可以利用循环事件（Event Loop)l来实现并发执行任务。追究其本质，NodeJs实际上使用了两种不同的线程，一个是用于处理循环事件的主线程一个是工作池（Worker pool）里面的一些辅助线程。

​	[锋利的NodeJS之NodeJS多线程](https://www.cnblogs.com/freephp/p/14640156.html)

4、协商缓存和强制缓存的区别，强制缓存中的Cache-control和Expires的区别，为什么Expires被淘汰了？

5、OPTIONS请求的作用是什么？

​	列出请求资源支持的请求方法，用来跨域请求

​	OPTIONS请求方法的主要用途有两个：

1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。

2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。

​	[Http协议：什么情况下发生了options请求？](https://network.51cto.com/article/627066.html)

6、post请求中application/x-www-form-urlencoded和multipart/form-data两种content-type有什么区别？

OST请求的两种编码格式：`application/x-www-urlencoded`是浏览器默认的编码格式，用于键值对参数，参数之间用`&`间隔；`multipart/form-data`常用于文件等二进制，也可用于键值对参数，最后连接成一串字符传输(参考Java OK HTTP)。

作者：DeppWang
链接：https://www.jianshu.com/p/53b5bd0f1d44

7、Http2.0特点，http1.1有keep-alive功能，跟http2.0的多路复用有什么区别？

**长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

**多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面

**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，因为传输格式是文本的，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞
- HTTP/2多个请求可同时在一个连接上并行执行（由于支持二进制的格式，可以无序）某个请求任务耗时严重，不会影响到其它连接的正常执行

[http1.1的长连接和http2.0的多路复用到底有啥区别](https://zhuanlan.zhihu.com/p/348307320)

8、如何防范xss，sql注入？



9、vuex的实现原理。

# Blibli一面

1、闭包，追问闭包保存的变量是只有引入的变量还是父函数内声明的所有变量？如果只有引入的变量，那为什么会有内存泄露问题？

理论上讲所有变量可见，实现上运行时会优化成一个closure对象引用，哪来的内存溢出？面试官是不是不太懂闭包？

2、es6创建对象和es5创建对象的区别

这有什么区别？不都是new?

3、react dom diff

追问旧的fiber不存在，新的fiber存在，新的fiber有很多子节点，这时候怎么优化插入的，面试官回答通过innerHTML插入

4、async await原理

追问生成器函数里面局部变量是否是共用的？你说共用他又会问你原理，前一段函数不是执行完了，为什么局部变量保存下来了？

无栈协程

5、浏览器支持import，为什么不直接再浏览器中用import

当然可以直接import了，不操心兼容性和延迟的话。

6、服务器端渲染ssr原理

服务器端执行js呗

7、本地导入图片，怎么转换成链接展示出来？

blob://

网友答案：

1,4问题本质上都是问内存回收机制，基本上回答标记清除，引用计数的实现方式就能解释这些问题。理解变量名的本质是一个标签，指向变量值本身的一个地址。内存回收的是存储值本身。顺便分清不同语言常量内存池有哪些。前端们，别把自己局限于js，语言是想通的。

可以参考《深入浅出Nodejs》

1，v8的gc更新过很多次了，闭包现在不会有内存问题了吧。

是的，谁在说闭包内存泄露干死丫的。内存回收机制这一块已经做了，循环引用都被解决了。

