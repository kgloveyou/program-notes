# 前端面试题

## React

- React 的 diff 算法工作过程
- React 中的 setState 是同步还是异步
- React、Vue /Angular 的区别?（会根据你简历中写的技术栈来）
- React 中各种组件复用的优劣势（mixin、render props、hoc、hook）
- React 的 Fiber 架构
- React 性能优化
- React hooks 相关问题
- React新的生命周期，为什么 getDrivedStatefromProps 是静态的？



## 闭包

函数嵌套函数，内部函数就是闭包。

正常情况下，函数执行完成，内部变量会被销毁。

闭包，内部函数没执行完成，外部函数变量不会被销毁。

https://www.bilibili.com/video/BV1E44y1z7XL?spm_id_from=333.999.0.0

闭包的应用：封装一段代码，实现模块化。

https://www.bilibili.com/video/BV1HK4y1g7fA/?spm_id_from=trigger_reload



作用域链：变量会在当前作用域内找，如果没有就继续往上找。

## 什么是防抖和节流？有什么区别？如何实现？

**1、防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间**

举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。

**节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率**

举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。

**2、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。**



防抖：用户触发事件过于频繁，只要取最后一次事件的操作；（只执行最后一次）

https://www.bilibili.com/video/BV1SU4y1G7Hw/?spm_id_from=trigger_reload

```js
function debounce(fn, delay) {
  let t = null;
  return function () {
    if (t != null) {
      clearTimeout(t);
    }
    t = setTimeout(() => {
      fn.call(this);
    }, delay);
  }
}
```

节流：控制高频事件执行次数

https://www.bilibili.com/video/BV1Qo4y1Q7AN/?spm_id_from=trigger_reload

```js
function throttle(fn, delay) {
    let flag = true;
    return function () {
        if (flag) {
            t = setTimeout(() => {
                fn.call(this);
                flag = true;
            }, delay);
        }
        flag = false;
    }
}
```

apulis nlp-frontend实现：

```ts
// 防抖
export const debounce = (fn, time = 1000) => {
  let timeout = null;
  return function d () {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, time)
  }
}

// 节流
export const throttle = (fn, time = 1000) => {
  let canRun = true;
  return function t () {
    if (!canRun) return;
    canRun = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      canRun = true;
    }, time)
  }
}

```



https://www.jianshu.com/p/9cdfff9edce1

## 手写 Promise

【前端面试】手写 Promise

https://zhuanlan.zhihu.com/p/272231637



大厂面试题手写Promise源码

https://www.cnblogs.com/lyt0207/p/12387564.html



## **重绘和重排**

https://www.cnblogs.com/yadongliang/p/10677589.html

一、重绘不一定需要重排，重排必然会导致重绘

1、重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

1）添加、删除可见的dom

2）元素的位置改变

3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）

4）页面渲染初始化

5）浏览器窗口尺寸改变

2、重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

二、减少reflow、repaint

1、不要一条一条的修改DOM的样式，可以先定义好css的class，然后修改DOM的className。

2、不要把DOM结点的属性值放在一个循环里当成循环里的变量。

3、为动画的HTML元件使用fixed或absolute的position，那么修改他们的css是不会reflow

## 什么是 BFC

块级格式化上下文，`Block Formatting Context`

https://juejin.cn/post/6950082193632788493

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用`BFC`呢，`BFC`可以看做是一个`CSS`元素属性

**BFC触发方式**

1. 根元素，即HTML标签
2. 浮动元素：float值为 `left`、 `right`
3. overflow值不为 visible，为 `auto`、 `scroll`、 `hidden`
4. display值为 `inline-block`、 `table-cell`、 `table-caption`、 `table`、 `inline-table`、 `flex`、 `inline-flex`、 `grid`、 `inline-grid`
5. 定位元素：position值为 `absolute`、 `fixed`

**注意** display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。

https://mp.weixin.qq.com/s/J1Y3MkFNyJrY1M03gaDdhA#at

**BFC的规则**

`BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列

`BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签

垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠

计算`BFC`的高度时，浮动元素也参与计算

**BFC解决了什么问题**

1.使用Float脱离文档流，高度塌陷

2.Margin边距重叠

3.两栏布局



10 分钟理解 BFC 原理（※）

https://zhuanlan.zhihu.com/p/25321647



## 你所不知道的scroll事件：为什么scroll事件会失效？

JavaScript事件有两个阶段——（1）**捕获阶段(Capture Phase)**（2）**冒泡阶段(Bubble Phase)**。捕获阶段是事件从`document`到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到`document`的过程。

https://ayase.moe/2018/11/20/scroll-event/



# 艰难环境下，面腾讯、美团、商汤科技等七家大厂前端有感

https://mp.weixin.qq.com/s/Jw98JPgFjHwCzNIjtu9W7g

## **1. 美团**

**一面**

1. 曾经做过的最有挑战的一个项目

2. DOM 的事件机制，怎么阻止事件捕获

   JavaScript事件有两个阶段——（1）**捕获阶段(Capture Phase)**（2）**冒泡阶段(Bubble Phase)**。捕获阶段是事件从`document`到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到`document`的过程。

   https://ayase.moe/2018/11/20/scroll-event/

   DOM2 Events 为事件处理程序的赋值和移除定义了两个方法： addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值， true 表示在捕获阶段调用事件处理程序， false（默认值）表示在冒泡阶段调用事件处理程序。  

   ```js
   e.stopPropagation()  
   ```

   用于取消所有后续事件捕获或事件冒泡。只有 bubbles为 true 才可以调用这个方法  

   ```js
   e.stopImmediatePropagation()  
   ```

   用于取消所有后续事件捕获或事件冒泡，并阻止调用何后续事件处理程序（ DOM3 Events 中新增）  

   

   那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？

　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生

​		示例：https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation

1. 常用的 ES6 语法有哪些，var 怎么实现let

   https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133

2. React Hooks vs Component

   

3. React中的 useCallback 和 useMemo 有什么区别，什么情况下需要用 useCallback

4. 浏览器的 Event Loop 机制

5. setState 是同步还是异步的

6. Set 的用法，用 Set 实现数组去重

7. Graphql 的使用

8. 移动端适配方案, rem 和 em 的区别

   https://zhuanlan.zhihu.com/p/94369298

   对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素。**

   **em**

   - 子元素字体大小的em是相对于父元素字体大小
   - 元素的width/height/padding/margin用em的话是相对于该元素的font-size

   em/rem：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。

9. React 解决了什么问题

   https://segmentfault.com/a/1190000019042501

10. 前端跨域怎么做

    前端常见跨域解决方案（全）

    https://segmentfault.com/a/1190000011145364

    - 通过jsonp跨域

    - document.domain + iframe跨域、location.hash + iframe跨域、window.name + iframe跨域

    - postMessage跨域

    - 跨域资源共享（CORS）

      ```js
      // 前端设置是否带cookie
      xhr.withCredentials = true;
      ```

      

    - nginx代理跨域

    - Nodejs中间件代理跨域

    - WebSocket协议跨域

11. 编程题：用 setTimeout 实现 setInterval

https://www.jianshu.com/p/32479bdfd851

```js
function mySetInterval(fn, millisec){
  function interval(){
    setTimeout(interval, millisec);
    fn();
  }
  setTimeout(interval, millisec)
}
```

**二面**

1. Vue 的双向绑定机制

2. 字节小程序和微信小程序区别

3. React Fiber 机制

   https://juejin.cn/post/7020220688719937573

   其实 Fiber 这一概念并非由 React 定义。Fiber 本义为纤维，在计算机科学中含义为**纤程**，是一种**轻量级**的执行线程。

   遵从上述原则，从上我们可以了解到，线程控制离不开**保持帧的渲染**，所以在实现方案上很自然的就想到 `requestAnimationFrame` 这个API，与之相关的还有 `requestIdleCallback`。

`requestIdleCallback`方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件。

看起相当完美，`requestIdleCallback`仿佛是因此而生一般，Fiber 的早期版本确实却是使用了这样的方案，不过这已经是**过去式**了。在19年的一次更新中，React 团队推翻之前的设计，使用了 `MessageChannel` 来实现了对于线程控制。

React 将上述的集中兼容处理做一封装，最终得到一个与 `requestIdleCallback` 类似的函数 `requestHostCallback`

这种数据结构之所以被叫做fiber，因为fiber的翻译是纤程，它被认为是协程的一种实现形式。协程是比线程更小的调度单位：它的开启、暂停可以被程序员所控制。具体来说，react fiber是通过`requestIdleCallback`这个api去控制的组件渲染的“进度条”。

现在，可以总结一下了：React Fiber是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件更新的流程可以被中断恢复；它把组件渲染的工作分片，到时会主动让出渲染主线程。



4. React Hooks 的原理

5. Node 遇到过哪些性能问题

6. Node 做耗时的计算时候，如何避免阻塞

7. 低代码平台运行时的生成逻辑

8. 低代码平台性能优化

9. 低代码平台组件发布流程

10. 上家公司做了哪些事情以及做事的流程

11. 未来职业规划

12. 感兴趣的工作方向

13. 编程题：输入两个数组 [1,2,3,2,1], [3,2,1,4,7]  返回公共的并且长度最长子数组的长度

**三面**

1. 大文件的分片上传和断点续传怎么做的
2. 抖音APP 与 H5 如何通信
3. 现在需要用新技术，需要从哪些方面思考
4. 如何针对性能指标做优化，有没有了解过业界的性能指标统计方式
5. Express 和 Koa 的区别
6. 项目经历
7. 推动过什么事情
8. 对下一份工作的期望

## **2. 商汤科技**

**一面**

1. less-loader 的 less 转成 css 的底层原理

   https://juejin.cn/post/6944668149849522213

   less-loader的原理很简单，就是调用less库提供的方法，转译less语法后输出，如下：

   ```js
   // less-loader实现（经简化）
   const less = require('less');
   module.exports = function (content) {
     const callback = this.async(); // 转译比较耗时，采用异步方式  
     const options = this.getOptions(); // 获取配置文件中less-loader的options    
     less.render(content, createOptions(options), // less转译的配置    
       (err, output) => {
         callback(err, output.css);
         // 将生成的css代码传递给下一个loader    
       });
   };
   ```

   

2. webpack的 loader 和 plugin 区别

   https://juejin.cn/post/6944349196539396133

   `Loader`是一个模块转换器，将非JS模块转换成JS模块，供webpack进行打包处理。

   非js模块即样式文件（.css、.less、.scss等），非标准JS文件（.ts、.jsx、.vue），以及其他类型的文件（svg、png | jpg | jpeg等）。

   `Plugin`是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。

   常用的loader:

   - babel-loader

     此 package 允许你使用 [Babel](https://github.com/babel/babel) 和 [webpack](https://github.com/webpack/webpack) 转译 `JavaScript` 文件。

   - less-loader-->postcss-loader-->css-loader-->style-loader

     ```js
     {
         test: /\.less$/i,
             include: [
                 /[\\/]node_modules[\\/].*antd/,
                 /[\\/]node_modules[\\/].*ant-design/,
                 path.resolve(__dirname, './node_modules/@apulis/aistudio-layout'),
                 path.resolve(__dirname, './node_modules/@apulis/table'),
                 path.resolve(__dirname, './node_modules/@apulis/select-lang'),
                 path.resolve(__dirname, './node_modules/@apulis/group-selector')
             ],
                 use: [
                     'style-loader',
                     {
                         loader: 'css-loader',
                         options: {
                             importLoaders: 2,
                         },
                     },
                     'postcss-loader',
                     {
                         loader: 'less-loader',
                         options: {
                             lessOptions: {
                                 modifyVars: {
                                     'primary-color': '#4168AA',
                                     'link-color': '#4168AA',
                                     'border-radius-base': '2px',
                                 },
                                 javascriptEnabled: true,
                             },
                         }
                     },
                 ],
     },
     ```

     

   - sass-loader

     ```js
     {
         test: /\.(css|scss)$/,
             use: [
                 'style-loader',
                 {
                     loader: 'css-loader',
                     options: {
                         importLoaders: 2,
                     },
                 },
                 'postcss-loader',
                 'sass-loader',
             ],
     },
     ```

     

   - file-loader

     ```js
                 {
                     test: /\.(png|jpe?g|gif)$/i,
                     use: [
                         {
                             loader: 'file-loader',
                         },
                     ],
                 },
     ```

     

   - react-svg-loader

     ```js
                 {
                     test: /src[\s\S]*\.svg$/,
                     exclude: /node_modules/,
                     use: [
                         'babel-loader',
                         {
                             loader: 'react-svg-loader',
                             query: {
                                 svgo: {
                                     plugins: [{ pretty: true }, { cleanupIDs: false }],
                                 },
                             },
                         },
                     ],
                 },
     ```

     

   - worker-loader

     ```js
                 {
                     test: /\.worker\.js$/,
                     exclude: /3rdparty/,
                     use: {
                         loader: 'worker-loader',
                         options: {
                             publicPath: '/AIStudio/admagic/',
                             name: '[name].[contenthash].js',
                         },
                     },
                 },
     ```

     

   - 

3. webpack 常用插件

   

4. webpack 如何做代码拆分

   https://juejin.cn/post/6844904175235514375

5. webpack tree shaking 原理

   https://juejin.cn/post/7019104818568364069

   

   https://juejin.cn/post/7004297344300777502

   首先，要明确一点：**Tree Shaking 只支持 ESM 的引入方式，不支持 Common JS 的引入方式。**

   

6. webpack 动态导入原理

7. webpack 热更新原理

8. webpack5 新特性

9. esm 和 commonjs 的区别

10. TS 的 type 和 interface 的区别

    https://juejin.cn/post/6844903749501059085

11. TS 怎么做枚举

12. TS 泛型

13. canvas 绘制流程，canvas 里的图片跨域怎么处理

    https://juejin.cn/post/6856555980415582216

    https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/

14. 项目经历：babel 插件的实现

15. 编程题：实现一个深拷贝

**二面**

1. 链表和线性表 crud 比较
2. 了解哪些设计模式，实现其中一个设计模式
3. canvas 绘制流程，遇到了哪些问题
4. 从输入URL到浏览器显示页面过程中都发生了什么？
5. 移动端布局方案
6. 浏览器 Event Loop
7. 对图形绘制了解多少
8. ES6 为什么要转成 ES5
9. H5 开发时遇到了哪些问题，怎么定位的
10. DOM 事件流
11. 平时怎么做性能优化
12. 最有亮点的两个项目

**三面**

1. HTTPS 加解密过程
2. 哈希表原理，哈希碰撞时怎么处理
3. 内存回收机制
4. 栈内存和堆内存的概念
5. 线上错误监控怎么做
6. CI/CD 流程，有哪些改进点
7. 进程间如何通信
8. 低代码平台的实现
9. 对下一份工作的期望

## **3. 神策**

**一面**

1. CSS 预处理器对比

2. CSS 定位有哪些取值

3. 原型与原型链，函数怎么实现继承

4. this的指向，call、apply的区别

5. Vue 3.0 和 2.0 区别

6. Vue.$nextTick 作用

7. Vue 和 React 的 diff 有什么区别

   https://juejin.cn/post/6978370715573714952#heading-4

   ### 相同点

   - 都是两组虚拟dom的对比(react16.8之后是fiber与虚拟dom的对比)
   - 只对同级节点进行对比，简化了算法复杂度
   - 都用key做为唯一标识，进行查找，只有key和标签类型相同时才会复用老节点
   - 遍历前都会根据老的节点构建一个map，方便根据key快速查找

   ### 不同点

   - react在diff遍历的时候，只对需要修改的节点进行了记录，形成effect list，最后才会根据effect list 进行真实dom的修改，修改时先删除，然后更新与移动，最后插入
   - vue 在遍历的时候就用真实dom`insertBefore`方法，修改了真实dom，最后做的删除操作
   - react 采用单指针从左向右进行遍历
   - vue采用双指针，从两头向中间进行遍历
   - react的虚拟diff比较简单，vue中做了一些优化处理，相对复杂，但效率更高

   
   

8. proxy 拦截器的用法

9. DNS 解析流程

   https://segmentfault.com/a/1190000023694985

   **DNS查询步骤**

   假设一台主机想知道y.abc.com这个域名的IP地址，那么整个的查询过程如下：

   1. 主机先向其本地域名服务器进行递归查询
   2. 本地域名服务器采用迭代的查询，它先向根域名服务器查询
   3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址。
   4. 本地域名服务器向顶级域名服务器发起查询。
   5. 顶级域名服务器告诉本地域名服务器，下一次应查询的权限域名服务器IP地址
   6. 本地域名服务器向权限域名服务器发起查询。
   7. 权限域名服务器告诉本地域名服务器所查询的IP地址。
   8. 本地域名服务器把查询结果告诉主机

   给这个过程做个图示，就是这样的

   ![](https://image-static.segmentfault.com/427/450/4274508305-5f3dd97e6b8ba_fix732)

10. 事件循环

11. 闭包和内存泄漏

12. 最有亮点的一个项目 

**二面**

1. HTTP 幂等性定义和常用方法的幂等性

2. redux 单向数据流有哪些优势，redux 中间件实现原理

3. React HOC vs renderProps

4. 浏览器里的线程与进程

5. requestAnimationFram 与 requestIdleCallback 的区别

6. npm管理痛点，如何解决

7. git flow流程、分支管理

8. websocket建立连接过程

9. 组件/工具库打包时的格式输出，如:CommonJS、ESM、UMD等，他们之间有什么区别

10. Http 301、302 状态码的区别

    301是永久重定向，302是临时重定向。

    https://zhuanlan.zhihu.com/p/110941264

    https://www.cnblogs.com/zhuzhenwei918/p/7582620.html

11. H5 性能优化 

12. 编程题：设计一个flat函数将如下数组arr=[1,2,['3',4,'5',[6,[7,8],9]]]输出为1,2,'3',4,'5',6,7,8,9。至少写出两种方法,要求不能改变数组中的原始数据类型

**三面**

1. BI 可视化系统介绍
2. 在字节之后的提升有哪些
3. 目前前端可以做的优化有哪些
4. 新旧系统重构的时候，怎么过渡上线
5. Vue React 的区别
6. 字节小程序介绍一下
7. 自己未来的规划。自己的优缺点、周围人人对自己的评价
8. 如何学习一门新技术
9. 对神策数据的了解
10. 对大数据的了解

## **4. 王者荣耀**

**一面**

1. 进程通信的几种方式
2. TCP/IP 如何保证传输稳定性
3. 对称加密和非对称加密的使用场景
4. 浏览器帧卡顿检测
5. Vue 和 React的设计理念
6. 性能指标FP、FCP和FMP分别跟哪些因素有关
7. 低代码平台的技术原理
8. 业界其他低代码平台实现方式，对比差异
9. nginx怎么做反向代理与负载均衡
10. 编程题：设计和实现一个 LRU (最近最少使用) 缓存机制，满足：1.获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。2.写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。

##  **5. 天眼查**

**一面**

1. JS 有哪些数据类型
2. JS 数据类型识别的方式，有什么缺点
3. 原型和原型链，函数怎么实现继承
4. new 发生了什么
5. symbol 类型的用法
6. script 标签里分别设置 defer 和 async， 它们的执行顺序是怎么样的
7. React router 的两种模式模式，怎么动态获取路由上的 id
8. redux 中间件的实现原理
9. React 的 purecomponent 和 component 的区别
10. generator 函数的用法
11. React diff 节点对比的过程
12. Vite 打包工具的使用
13. 箭头函数和普通函数区别
14. 什么是执行上下文
15. 堆内存和栈内存，数组存储在堆内存还是栈内存
16. HTTP2.0 相较于 HTTP1.0 的改进
17. isNaN和number.isNaN区别
18. 闭包和内存泄漏
19. setState 是同步还是异步的
20. HTTP 与 HTTPS 的区别
21. React Hooks 的 useState 为什么不能放到条件语句
22. 解释下浏览器的同源策略

## **6. 酷家乐**

**一面**

1. Node 怎么做性能监控
2. React diff 节点移动的具体过程
3. 讲一讲浏览器缓存
4. ES5 最优的一种函数继承，静态属性怎么做继承的
5. 前端怎么做性能监控
6. V8 引擎对垃圾回收的优化
7. 导致内存泄漏的方法，怎么监控内存泄漏
8. 作用域和执行上下文区别
9. this的指向问题
10. Array方法，forEach、map 对比
11. for of 和 for in 区别；for of 循环数组时怎么拿到数组索引
12. 移动端布局方案；怎么设置根元素的font-size大小的
13. Webpack bundle、chunk、module的区别
14. Webpack 热更新原理，怎么找到对应的局部模块做更新的
15. 项目经历：babel插件的实现

## **7. 中国人寿**

**一面**

1. HTTP2.0 和 HTTP1.0 的区别，HTTP2.0 有什么缺点

2. 闭包及闭包的使用场景

   https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9

   https://segmentfault.com/a/1190000039370942

3. 实现一个侧边栏组件思路

4. 浏览器缓存机制

5. 重排与重绘，怎么减少重排

6. DOM 事件机制，不会冒泡的事件

7. cookie 和 session 的区别

8. sql 相关操作，增删查改

9. web 安全，xss、csrf 攻击特点及防御方式

## 8、深信服

1.get和post请求的区别

2.项目的上线流程

3.Vue中key值为什么不能用索引

在vue中为什么不推荐用 index 做 key（https://www.zoo.team/article/vue-index）

5.Async和Await原理

6.手写Promise.all()

https://www.jianshu.com/p/90b6280dd1b6

7.leetcode：三数之和

8.webpack原理

9.webpack的loader和plugin区别

https://juejin.cn/post/6944349196539396133

https://juejin.cn/post/6944668149849522213

Loader是一个模块转换器，将非JS模块转换成JS模块；

Plugin是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。

