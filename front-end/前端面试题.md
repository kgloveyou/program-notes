# 前端面试题

## React

- React 的 diff 算法工作过程
- React 中的 setState 是同步还是异步
- React、Vue /Angular 的区别?（会根据你简历中写的技术栈来）
- React 中各种组件复用的优劣势（mixin、render props、hoc、hook）
- React 的 Fiber 架构
- React 性能优化
- React hooks 相关问题
- React新的生命周期，为什么 getDrivedStatefromProps 是静态的？



## 闭包

函数嵌套函数，内部函数就是闭包。

正常情况下，函数执行完成，内部变量会被销毁。

闭包，内部函数没执行完成，外部函数变量不会被销毁。

https://www.bilibili.com/video/BV1E44y1z7XL?spm_id_from=333.999.0.0

闭包的应用：封装一段代码，实现模块化。

https://www.bilibili.com/video/BV1HK4y1g7fA/?spm_id_from=trigger_reload



作用域链：变量会在当前作用域内找，如果没有就继续往上找。

## 什么是防抖和节流？有什么区别？如何实现？

**1、防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间**

举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。

**节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率**

举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。

**2、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。**



防抖：用户触发事件过于频繁，只要取最后一次事件的操作；（只执行最后一次）

https://www.bilibili.com/video/BV1SU4y1G7Hw/?spm_id_from=trigger_reload

```js
function debounce(fn, delay) {
  let t = null;
  return function () {
    if (t != null) {
      clearTimeout(t);
    }
    t = setTimeout(() => {
      fn.call(this);
    }, delay);
  }
}
```

节流：控制高频事件执行次数

https://www.bilibili.com/video/BV1Qo4y1Q7AN/?spm_id_from=trigger_reload

```js
function throttle(fn, delay) {
    let flag = true;
    return function () {
        if (flag) {
            t = setTimeout(() => {
                fn.call(this);
                flag = true;
            }, delay);
        }
        flag = false;
    }
}
```

apulis nlp-frontend实现：

```ts
// 防抖
export const debounce = (fn, time = 1000) => {
  let timeout = null;
  return function d () {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, time)
  }
}

// 节流
export const throttle = (fn, time = 1000) => {
  let canRun = true;
  return function t () {
    if (!canRun) return;
    canRun = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      canRun = true;
    }, time)
  }
}

```



https://www.jianshu.com/p/9cdfff9edce1

## 手写 Promise

【前端面试】手写 Promise

https://zhuanlan.zhihu.com/p/272231637



大厂面试题手写Promise源码

https://www.cnblogs.com/lyt0207/p/12387564.html



## **重绘和重排**

https://www.cnblogs.com/yadongliang/p/10677589.html

一、重绘不一定需要重排，重排必然会导致重绘

1、重排：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

1）添加、删除可见的dom

2）元素的位置改变

3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）

4）页面渲染初始化

5）浏览器窗口尺寸改变

2、重绘：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

二、减少reflow、repaint

1、不要一条一条的修改DOM的样式，可以先定义好css的class，然后修改DOM的className。

2、不要把DOM结点的属性值放在一个循环里当成循环里的变量。

3、为动画的HTML元件使用fixed或absolute的position，那么修改他们的css是不会reflow

## 什么是 BFC

块级格式化上下文，`Block Formatting Context`



## 你所不知道的scroll事件：为什么scroll事件会失效？

JavaScript事件有两个阶段——（1）**捕获阶段(Capture Phase)**（2）**冒泡阶段(Bubble Phase)**。捕获阶段是事件从`document`到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到`document`的过程。

https://ayase.moe/2018/11/20/scroll-event/



# 艰难环境下，面腾讯、美团、商汤科技等七家大厂前端有感

https://mp.weixin.qq.com/s/Jw98JPgFjHwCzNIjtu9W7g

## **1. 美团**

**一面**

1. 曾经做过的最有挑战的一个项目

2. DOM 的事件机制，怎么阻止事件捕获

   JavaScript事件有两个阶段——（1）**捕获阶段(Capture Phase)**（2）**冒泡阶段(Bubble Phase)**。捕获阶段是事件从`document`到传递到目标元素的过程，而冒泡阶段是事件从目标元素传递到`document`的过程。

   https://ayase.moe/2018/11/20/scroll-event/

   DOM2 Events 为事件处理程序的赋值和移除定义了两个方法： addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值， true 表示在捕获阶段调用事件处理程序， false（默认值）表示在冒泡阶段调用事件处理程序。  

   ```js
   e.stopPropagation()  
   ```

   用于取消所有后续事件捕获或事件冒泡。只有 bubbles为 true 才可以调用这个方法  

   ```js
   e.stopImmediatePropagation()  
   ```

   用于取消所有后续事件捕获或事件冒泡，并阻止调用何后续事件处理程序（ DOM3 Events 中新增）  

   

   那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？

　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生

​		示例：https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation

1. 常用的 ES6 语法有哪些，var 怎么实现let

   https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133

2. React Hooks vs Component

3. React中的 useCallback 和 useMemo 有什么区别，什么情况下需要用 useCallback

4. 浏览器的 Event Loop 机制

5. setState 是同步还是异步的

6. Set 的用法，用 Set 实现数组去重

7. Graphql 的使用

8. 移动端适配方案, rem 和 em 的区别

   https://zhuanlan.zhihu.com/p/94369298

   对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素。**

   **em**

   - 子元素字体大小的em是相对于父元素字体大小
   - 元素的width/height/padding/margin用em的话是相对于该元素的font-size

   em/rem：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰。

9. React 解决了什么问题

   https://segmentfault.com/a/1190000019042501

10. 前端跨域怎么做

    前端常见跨域解决方案（全）

    https://segmentfault.com/a/1190000011145364

    - 通过jsonp跨域

    - document.domain + iframe跨域、location.hash + iframe跨域、window.name + iframe跨域

    - postMessage跨域

    - 跨域资源共享（CORS）

      ```js
      // 前端设置是否带cookie
      xhr.withCredentials = true;
      ```

      

    - nginx代理跨域

    - Nodejs中间件代理跨域

    - WebSocket协议跨域

11. 编程题：用 setTimeout 实现 setInterval

https://www.jianshu.com/p/32479bdfd851

```js
function mySetInterval(fn, millisec){
  function interval(){
    setTimeout(interval, millisec);
    fn();
  }
  setTimeout(interval, millisec)
}
```

**二面**

1. Vue 的双向绑定机制
2. 字节小程序和微信小程序区别
3. React Fiber 机制
4. React Hooks 的原理
5. Node 遇到过哪些性能问题
6. Node 做耗时的计算时候，如何避免阻塞
7. 低代码平台运行时的生成逻辑
8. 低代码平台性能优化
9. 低代码平台组件发布流程
10. 上家公司做了哪些事情以及做事的流程
11. 未来职业规划
12. 感兴趣的工作方向
13. 编程题：输入两个数组 [1,2,3,2,1], [3,2,1,4,7]  返回公共的并且长度最长子数组的长度

**三面**

1. 大文件的分片上传和断点续传怎么做的
2. 抖音APP 与 H5 如何通信
3. 现在需要用新技术，需要从哪些方面思考
4. 如何针对性能指标做优化，有没有了解过业界的性能指标统计方式
5. Express 和 Koa 的区别
6. 项目经历
7. 推动过什么事情
8. 对下一份工作的期望

## **2. 商汤科技**

**一面**

1. less-loader 的 less 转成 css 的底层原理

2. webpack的 loader 和 plugin 区别

3. webpack 常用插件

4. webpack 如何做代码拆分

5. webpack tree shaking 原理

6. webpack 动态导入原理

7. webpack 热更新原理

8. webpack5 新特性

9. esm 和 commonjs 的区别

10. TS 的 type 和 interface 的区别

    https://juejin.cn/post/6844903749501059085

11. TS 怎么做枚举

12. TS 泛型

13. canvas 绘制流程，canvas 里的图片跨域怎么处理

    https://juejin.cn/post/6856555980415582216

    https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/

14. 项目经历：babel 插件的实现

15. 编程题：实现一个深拷贝

**二面**

1. 链表和线性表 crud 比较
2. 了解哪些设计模式，实现其中一个设计模式
3. canvas 绘制流程，遇到了哪些问题
4. 从输入URL到浏览器显示页面过程中都发生了什么？
5. 移动端布局方案
6. 浏览器 Event Loop
7. 对图形绘制了解多少
8. ES6 为什么要转成 ES5
9. H5 开发时遇到了哪些问题，怎么定位的
10. DOM 事件流
11. 平时怎么做性能优化
12. 最有亮点的两个项目

**三面**

1. HTTPS 加解密过程
2. 哈希表原理，哈希碰撞时怎么处理
3. 内存回收机制
4. 栈内存和堆内存的概念
5. 线上错误监控怎么做
6. CI/CD 流程，有哪些改进点
7. 进程间如何通信
8. 低代码平台的实现
9. 对下一份工作的期望

## **3. 神策**

**一面**

1. CSS 预处理器对比
2. CSS 定位有哪些取值
3. 原型与原型链，函数怎么实现继承
4. this的指向，call、apply的区别
5. Vue 3.0 和 2.0 区别
6. Vue.$nextTick 作用
7. Vue 和 React 的 diff 有什么区别
8. proxy 拦截器的用法
9. DNS 解析流程
10. 事件循环
11. 闭包和内存泄漏
12. 最有亮点的一个项目 

**二面**

1. HTTP 幂等性定义和常用方法的幂等性

2. redux 单向数据流有哪些优势，redux 中间件实现原理

3. React HOC vs renderProps

4. 浏览器里的线程与进程

5. requestAnimationFram 与 requestIdleCallback 的区别

6. npm管理痛点，如何解决

7. git flow流程、分支管理

8. websocket建立连接过程

9. 组件/工具库打包时的格式输出，如:CommonJS、ESM、UMD等，他们之间有什么区别

10. Http 301、302 状态码的区别

    301是永久重定向，302是临时重定向。

    https://zhuanlan.zhihu.com/p/110941264

    https://www.cnblogs.com/zhuzhenwei918/p/7582620.html

11. H5 性能优化 

12. 编程题：设计一个flat函数将如下数组arr=[1,2,['3',4,'5',[6,[7,8],9]]]输出为1,2,'3',4,'5',6,7,8,9。至少写出两种方法,要求不能改变数组中的原始数据类型

**三面**

1. BI 可视化系统介绍
2. 在字节之后的提升有哪些
3. 目前前端可以做的优化有哪些
4. 新旧系统重构的时候，怎么过渡上线
5. Vue React 的区别
6. 字节小程序介绍一下
7. 自己未来的规划。自己的优缺点、周围人人对自己的评价
8. 如何学习一门新技术
9. 对神策数据的了解
10. 对大数据的了解

## **4. 王者荣耀**

**一面**

1. 进程通信的几种方式
2. TCP/IP 如何保证传输稳定性
3. 对称加密和非对称加密的使用场景
4. 浏览器帧卡顿检测
5. Vue 和 React的设计理念
6. 性能指标FP、FCP和FMP分别跟哪些因素有关
7. 低代码平台的技术原理
8. 业界其他低代码平台实现方式，对比差异
9. nginx怎么做反向代理与负载均衡
10. 编程题：设计和实现一个 LRU (最近最少使用) 缓存机制，满足：1.获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。2.写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。

##  **5. 天眼查**

**一面**

1. JS 有哪些数据类型
2. JS 数据类型识别的方式，有什么缺点
3. 原型和原型链，函数怎么实现继承
4. new 发生了什么
5. symbol 类型的用法
6. script 标签里分别设置 defer 和 async， 它们的执行顺序是怎么样的
7. React router 的两种模式模式，怎么动态获取路由上的 id
8. redux 中间件的实现原理
9. React 的 purecomponent 和 component 的区别
10. generator 函数的用法
11. React diff 节点对比的过程
12. Vite 打包工具的使用
13. 箭头函数和普通函数区别
14. 什么是执行上下文
15. 堆内存和栈内存，数组存储在堆内存还是栈内存
16. HTTP2.0 相较于 HTTP1.0 的改进
17. isNaN和number.isNaN区别
18. 闭包和内存泄漏
19. setState 是同步还是异步的
20. HTTP 与 HTTPS 的区别
21. React Hooks 的 useState 为什么不能放到条件语句
22. 解释下浏览器的同源策略

## **6. 酷家乐**

**一面**

1. Node 怎么做性能监控
2. React diff 节点移动的具体过程
3. 讲一讲浏览器缓存
4. ES5 最优的一种函数继承，静态属性怎么做继承的
5. 前端怎么做性能监控
6. V8 引擎对垃圾回收的优化
7. 导致内存泄漏的方法，怎么监控内存泄漏
8. 作用域和执行上下文区别
9. this的指向问题
10. Array方法，forEach、map 对比
11. for of 和 for in 区别；for of 循环数组时怎么拿到数组索引
12. 移动端布局方案；怎么设置根元素的font-size大小的
13. Webpack bundle、chunk、module的区别
14. Webpack 热更新原理，怎么找到对应的局部模块做更新的
15. 项目经历：babel插件的实现

## **7. 中国人寿**

**一面**

1. HTTP2.0 和 HTTP1.0 的区别，HTTP2.0 有什么缺点

2. 闭包及闭包的使用场景

   https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9

   https://segmentfault.com/a/1190000039370942

3. 实现一个侧边栏组件思路

4. 浏览器缓存机制

5. 重排与重绘，怎么减少重排

6. DOM 事件机制，不会冒泡的事件

7. cookie 和 session 的区别

8. sql 相关操作，增删查改

9. web 安全，xss、csrf 攻击特点及防御方式

## 8、深信服

1.get和post请求的区别

2.项目的上线流程

3.Vue中key值为什么不能用索引

在vue中为什么不推荐用 index 做 key（https://www.zoo.team/article/vue-index）

5.Async和Await原理

6.手写Promise.all()

https://www.jianshu.com/p/90b6280dd1b6

7.leetcode：三数之和

8.webpack原理

9.webpack的loader和plugin区别

https://juejin.cn/post/6944349196539396133

https://juejin.cn/post/6944668149849522213

Loader是一个模块转换器，将非JS模块转换成JS模块；

Plugin是webpack运行生命周期的各个阶段上挂载的事件，会被指定的时间节点被触发（相当于订阅/发布模式），能够改变构建结果、拆分和优化bundle等。

