点击上方 前端Q，关注公众号  

回复加群，加入前端Q技术交流群

在前端开发中，随着项目迭代升级，日志打印逐渐风格不一，合理的日志输出是监控应用状态、调试代码和跟踪用户行为的重要手段。一个好的日志系统能够帮助开发者快速定位问题，提高开发效率。本文将介绍如何在前端项目中制定日志输出规范。

### 1\. 日志等级

首先，我们需要定义不同的日志等级，以便根据消息的重要性进行分类。通常，日志等级从低到高可以分为以下几类：

-   DEBUG: 详细的开发时信息，用于调试应用。
    
-   INFO: 重要事件的简要信息，如系统启动、配置等。
    
-   WARN: 系统能正常运行，但有潜在错误的情况。
    
-   ERROR: 由于严重的问题，某些功能无法正常运行。
    
-   FATAL: 非常严重的问题，可能导致系统崩溃。
    

### 2\. 日志内容

日志内容应该包含足够的信息，以便于开发者理解发生了什么。一个完整的日志消息通常包括：

-   时间戳：精确到毫秒的事件发生时间。
    
-   日志等级：当前日志消息的等级。
    
-   消息内容：描述事件的详细信息。
    
-   错误堆栈：如果是错误，提供错误堆栈信息。
    

### 3\. 日志格式

日志的格式应该统一，以便于阅读和解析。一个常见的日志格式如下：

```auto
[时间戳] [日志等级] [消息内容] [错误堆栈]
```

例如：

```auto
[2024-04-01T12:00:00.000Z] [ERROR] Failed to load user data. {stack}
```

### 4\. 日志输出

在前端项目中，我们通常使用console对象进行日志输出。不同的日志等级可以使用不同的console方法：

-   console.debug用于DEBUG级别。
    
-   console.info用于INFO级别。
    
-   console.warn用于WARN级别。
    
-   console.error用于ERROR和FATAL级别。
    

### 5\. 日志封装

为了更好地控制日志输出，我们可以封装一个日志工具，来统一管理日志输出。以下是一个简单的日志工具实现：

```js
class Logger {
  static log(level, message, error) {
    const timestamp = new Date().toISOString();
    const stack = error ? error.stack : '';
    const formattedMessage = `[${timestamp}] [${level}] ${message} ${stack}`;

    switch (level) {
      case 'DEBUG':
        console.debug(formattedMessage);
        break;
      case 'INFO':
        console.info(formattedMessage);
        break;
      case 'WARN':
        console.warn(formattedMessage);
        break;
      case 'ERROR':
      case 'FATAL':
        console.error(formattedMessage);
        break;
      default:
        console.log(formattedMessage);
    }
  }

  static debug(message) {
    this.log('DEBUG', message);
  }

  static info(message) {
    this.log('INFO', message);
  }

  static warn(message) {
    this.log('WARN', message);
  }

  static error(message, error) {
    this.log('ERROR', message, error);
  }

  static fatal(message, error) {
    this.log('FATAL', message, error);
  }
}

// 使用示例
Logger.info('Application is starting...');
Logger.error('Failed to load user data', new Error('Network Error'));
```

### 6\. 日志收集

在生产环境中，我们可能需要将日志发送到后端服务器进行收集和分析。这可以通过AJAX请求或专门的日志服务来实现。例如，我们可以修改Logger工具，添加一个方法来发送日志：

```js
class Logger {
  // ...其他方法

 // 根据环境变量判断是否发送日志到后端
if (process.env.NODE_ENV === 'production') {
  this.sendLog(formattedMessage);
}

  static sendLog(message) {
    // 假设我们有一个日志收集的API
    const logEndpoint = '/api/logs';
 fetch(logEndpoint, {
  method: 'POST', 
  headers: {
   'Content-Type': 'application/json', 
  }, body: JSON.stringify({ message }), }).catch((error) => {
  console.error('Failed to send log', error); 
 });
}
```

### 7\. 日志等级控制

在开发环境中，我们可能希望看到尽可能多的日志输出，以便更好地调试应用。但在生产环境中，为了避免性能损耗和过多的日志信息，我们可能只希望输出`WARN`和以上等级的日志。我们可以在`Logger`中添加一个等级控制：

```js
class Logger {
  static level = 'DEBUG'; // 默认为DEBUG级别

  static setLevel(newLevel) {
    this.level = newLevel;
  }

  static shouldLog(level) {
    const levels = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];
    return levels.indexOf(level) >= levels.indexOf(this.level);
  }

  static log(level, message, error) {
    if (!this.shouldLog(level)) {
      return;
    }
    // ...日志输出逻辑
  }

  // ...其他方法
}

// 生产环境中设置日志等级
if (process.env.NODE_ENV === 'production') {
  Logger.setLevel('WARN');
}

// 使用示例
Logger.debug('This will not be logged in production');
Logger.warn('This will be logged in production');
```

### 8\. 日志格式化

为了进一步提高日志的可读性，我们可以添加格式化功能，比如为不同等级的日志添加颜色，或者为错误堆栈提供更好的格式化。

```js
class Logger {
  // ...其他方法

  static formatStack(stack) {
    if (!stack) return '';
    // 格式化错误堆栈的逻辑
    return stack.split('\n').map(line => `    at ${line}`).join('\n');
  }

  static log(level, message, error) {
    // ...日志输出逻辑

    // 格式化错误堆栈
    if (error) {
      formattedMessage += `\n${this.formatStack(error.stack)}`;
    }

    // ...输出逻辑
  }

  // ...其他方法
}
```

### 最后

通过以上步骤，我们可以建立一个前端项目的日志输出规范。一个好的日志系统应该是灵活的，能够根据不同的环境和需求进行适当的调整。日志是帮助我们更好地理解和维护应用的工具，合理的使用和管理日志对于任何规模的前端项目都是非常重要的。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/D7MJlTPSSr6Oa72xMxnt7RPsQtO1D57IAib9HJAvDCTkxtAqwY6KZACpmdKNmDicNjb0hKiaicZIx1F1gnibbJ0Zmmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

往期推荐

  

[又一次变革，Vue 更彻底的拥抱了函数式](http://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649861539&idx=1&sn=54ba74abef0f96c4532ee923fed44c20&chksm=f1756760c602ee76e44fc6f802ae2545bb54ca4d1c44701c3b301323ab9c91841c5cbcd11d9f&scene=21#wechat_redirect)  

![图片](https://mmbiz.qpic.cn/mmbiz_png/US10Gcd0tQHPicsvHJNw24sa8QTMZOa4ugfmq6V4LP0EcOfPvPX541nslney3MMhdw4uJzygunTfAtu4NRFaicDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

[面试官：谈谈前端路由的实现原理【hash＆history】](http://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649861539&idx=2&sn=d095f3be9e7ad1ea50b6d97bfcfb808c&chksm=f1756760c602ee76cfe0496baaa894be457ea4f17f20f1dc2a27a6f45445d01bf5326e720c74&scene=21#wechat_redirect)  

![图片](https://mmbiz.qpic.cn/mmbiz_png/6aVaON9Kibf6ouXic7Uuc3Q22Yho6GQp2ESgu6l68tycQYQPPAZtZiajdeiaHghFg8N5GlWNX8k28VYPbh1JK31Mgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

[前端代码规范 - 图片相关](http://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649861513&idx=1&sn=9faed4045e07ed3855ab91cb8b3eabe2&chksm=f175674ac602ee5c790d25f2d3f93f44ed5ef6a7654947497ee300391e0fc539f31ea96042c6&scene=21#wechat_redirect)  

![图片](https://mmbiz.qpic.cn/mmbiz_png/6aVaON9Kibf6ouXic7Uuc3Q22Yho6GQp2ESgu6l68tycQYQPPAZtZiajdeiaHghFg8N5GlWNX8k28VYPbh1JK31Mgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


最后

  

  

-   欢迎加我微信，拉你进技术群，长期交流学习...  
    
-   欢迎关注「前端Q」,认真学前端，做个专业的技术人...
    

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2wV7LicL762ZePKQemg99H6tkm8KTFVk0Nib7DXYY4O45q6WQG4GElKAZMbt2MgD5zlLibLqbeDAl0nnhhQc203Ww/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC6BGNLOQxwBmMTOGmO0dSd31LlXL5HoZWBH6fKtSSeKQ2DOeTfVR7nHVXl0U7RSAchUVoia2bErYfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

点个**在看**支持我吧

![图片](https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6BGNLOQxwBmMTOGmO0dSd3NmOWsZBMWg3BC1msdwtyvBkNLYh1xGLQibm4QsHibClwxWfzuibicbJcIA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)